<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剑指Offer题解</title>
    <link href="/2021/10/01/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/10/01/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本文简要介绍算法复杂度分析，并给出《剑指 Offer 第 2 版》 系列题目的解题思路以及参考答案。</p><span id="more"></span><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>算法复杂度旨在计算在输入数据量 $N$ 的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 $N$ 」而增大的速度。</p><p>有关算法时间复杂度的详细叙述可见知乎高赞答案<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="如何理解算法时间复杂度的表示法(http://www.zhihu.com/question/21387264)">[1]</span></a></sup>。</p><p>根据从小到大排列，常见的算法时间复杂度主要有：</p><script type="math/tex; mode=display">O(1)<O(\log N)<O(N)<O(N \log N)<O\left(N^{2}\right)<O\left(2^{N}\right)<O(N !)</script><p>本部分复杂度分析详细可见<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="图解算法与数据结构(https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/)">[2]</span></a></sup>。</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">9. 用两个栈实现队列</a></h3><p><strong>题目描述</strong>：用两个栈实现一个队列。完成两个操作：</p><ul><li>队列尾部插入整数；</li><li>队列头部删除整数，队列为空则返回 -1。</li></ul><p><strong>解题思路</strong>：本题只需理清从队列头部删除整数的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stk1, stk2;<br>    <span class="hljs-built_in">CQueue</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        stk1.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(!stk1.<span class="hljs-built_in">empty</span>()) &#123;<br>                stk2.<span class="hljs-built_in">push</span>(stk1.<span class="hljs-built_in">top</span>());<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>            res = stk2.<span class="hljs-built_in">top</span>();<br>            stk2.<span class="hljs-built_in">pop</span>(); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">30. 包含min函数的栈</a></h3><p><strong>题目描述</strong>：定义栈的数据结构，实现四个操作：</p><ul><li><code>void push(int x)</code>，元素入栈；</li><li><code>void pop()</code>，元素出栈；</li><li><code>int top()</code>，返回栈顶元素；</li><li><code>int min()</code>，返回栈中最小的元素；</li></ul><p>调用 <code>min</code>、<code>push</code> 及 <code>pop</code> 的时间复杂度都是 O(1)。</p><p><strong>解题思路</strong>：维护 <code>stk2</code> 为单调递减的单调栈。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stk1, stk2;<br>    <span class="hljs-built_in">MinStack</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">empty</span>() || stk2.<span class="hljs-built_in">top</span>() &gt;= x) &#123;<br>            stk2.<span class="hljs-built_in">push</span>(x);<br>        &#125; <br>        stk1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">top</span>() == stk2.<span class="hljs-built_in">top</span>()) stk2.<span class="hljs-built_in">pop</span>();<br>        stk1.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk1.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">59 - I. 滑动窗口的最大值</a></h3><p><strong>题意描述</strong>：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br></code></pre></div></td></tr></table></figure><p>注意：<em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>解题思路</strong>：单调队列，滑动窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (deq.<span class="hljs-built_in">size</span>() &amp;&amp; deq.<span class="hljs-built_in">front</span>() &lt;= i - k) deq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(deq.<span class="hljs-built_in">size</span>() &amp;&amp; nums[deq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) deq.<span class="hljs-built_in">pop_back</span>();<br>        deq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) res.<span class="hljs-built_in">push_back</span>(nums[deq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">59 - II. 队列的最大值</a></h3><p><strong>题意描述</strong>：请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数 <code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的均摊时间复杂度都是 $O(1)$ 。若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 $-1$。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: <br>[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双端队列 + 队列。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : deq.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span>(deq.<span class="hljs-built_in">size</span>() &amp;&amp; deq.<span class="hljs-built_in">back</span>() &lt; value) deq.<span class="hljs-built_in">pop_back</span>();<br>        deq.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (que.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> res = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (deq.<span class="hljs-built_in">front</span>() == res) deq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">6. 从尾到头打印链表</a></h3><p><strong>题意描述</strong>：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [1,3,2]<br>输出：[2,3,1]<br></code></pre></div></td></tr></table></figure><p>限制：<code>0 &lt;= 链表长度 &lt;= 10000</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span>(head) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(res.<span class="hljs-built_in">rbegin</span>(), res.<span class="hljs-built_in">rend</span>());<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">24. 反转链表</a></h3><p><strong>题意描述</strong>：输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br></code></pre></div></td></tr></table></figure><p>递归法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>迭代法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;<br>    ListNode* pre = <span class="hljs-literal">nullptr</span>, *cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        ListNode* p = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35. 复杂链表的复制</a></h3><p><strong>题意描述</strong>：实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" div align=center/></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br></code></pre></div></td></tr></table></figure><p>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" div align=center/></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br></code></pre></div></td></tr></table></figure><p>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" div align=center/></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：假设原始链表为下图所示，图中对于 <code>next</code> 指针和 <code>random</code> 指针，指向空的不做标记，红色表示 <code>random</code> 指针。</p><p><img src="../$%7Bfigs%7D/20211115155712.png" div align=center/></p><p>第一步：我们将每个节点复制一遍（忽略 <code>random</code> 指针），如下图所示：</p><p><img src="../$%7Bfigs%7D/20211115160033.png" div align=center/></p><p>第二步：复制 <code>random</code> 指针，遍历链表，对于非空的 <code>cur-&gt;random</code> ，让 <code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</code>。</p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211115160256.png" div align=center /></p><p>第三步：分离两个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>    Node* cur = head;<br>    <span class="hljs-comment">// 链表复制</span><br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        Node* tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>        tmp-&gt;next = cur-&gt;next;<br>        cur-&gt;next = tmp;<br>        cur = tmp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// random 指针复制</span><br>    cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;random) &#123;<br>            cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 链表分割</span><br>    Node* pre = head;<br>    cur = head-&gt;next;<br>    Node* newHead = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next) &#123;<br>        pre-&gt;next = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        pre = pre-&gt;next;<br>        cur = cur-&gt;next;<br>    &#125;<br>    pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>vector</code> 数组实现：</p><ul><li>初始：空数组，分配常数空间；</li><li><code>push_back()</code> ：若空间不够，重新申请 $2$ 倍大小的连续空间，拷贝到新空间，释放旧空间；</li><li><code>pop_back()</code> ：若空间利用率不到 $25\%$ ，释放一半的空间；</li></ul><p>均摊 $O(1)$ </p><p>在空数组中连续插入 $n$ 个元素，总插入 / 拷贝次数为 $n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}… &lt; 2n$ </p><p>一次扩容到下次释放，至少需要再删除 $(1-2\times0.25)*n=0.5n$ 次</p><h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h3><p><strong>题意描述</strong>：把字符串 <code>s</code> 中的每个空格替换成 <code>&quot;%20&quot;</code>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;We are happy.&quot;<br>输出：&quot;We%20are%20happy.&quot;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：假设初始字符串 <code>s</code> 的长度为 $n$。 </p><ul><li>统计字符串 <code>s</code> 中的空格个数 $cnt$，将字符串长度调整为 $n + 2 \times cnt$；</li><li>从后往前遍历字符串，遇到空格就替换为字符串 <code>&quot;%20&quot;</code>。</li></ul><p>在本题中我们用两个指针 <code>i</code> 和 <code>j</code> 分别指向 <code>n - 1</code> 和  <code>n + 2 * cnt - 1</code> 的位置，直到 <code>i == j</code> 时我们结束循环。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * cnt);<br>    <span class="hljs-keyword">int</span> j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) s[j--] = s[i--];<br>        <span class="hljs-keyword">else</span> &#123;<br>            i--;<br>            s[j--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            s[j--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            s[j--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58 - II. 左旋转字符串</a></h3><p><strong>题意描述</strong>：实现字符串的左旋操作，也就是把字符串前面的若干个字符转移到字符串的尾部。</p><p><strong>解题思路</strong>：字符串三次翻转。———-&gt;—-&gt;，&lt;—-&lt;———-，—-&gt;&lt;———-，—-&gt;———-&gt;</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: s = &quot;abcdefg&quot;, k = 2<br>输出: &quot;cdefgab&quot;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n - k);<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n - k, s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">20. 表示数值的字符串</a></h3><p><strong>题意描述</strong>：实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">数值：[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]<br>非数值：[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]<br></code></pre></div></td></tr></table></figure><ul><li>小数可以没有整数部分，例如 <code>.123</code> 等于 <code>0.123</code>；</li><li><p>小数点后面可以没有数字，例如 <code>233.</code> 等于 <code>233.0</code>；</p></li><li><p>小数点前面和后面可以有数字，例如 <code>233.666</code>；</p></li><li>当 <code>e</code> 或 <code>E</code> 前面没有数字时，整个字符串不能表示数字，例如 <code>.e1</code>、<code>e1</code>；</li><li>当 <code>e</code> 或 <code>E</code> 后面没有整数时，整个字符串不能表示数字，例如 <code>12e</code>、<code>12e+5.4</code>;</li></ul><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li></ul><p><strong>解题思路1</strong>：模拟字符串处理，整个字符串遍历一次，时间复杂度为 $O(N)$。</p><ol><li>先去除行首和行尾空格；</li><li>行首如果有一个正负号，直接忽略；</li><li>如果字符串为空或只有一个 <code>&#39;.&#39;</code> ，则不是一个合法数；</li><li>循环整个字符串，去掉以下几种情况：<ol><li><code>&#39;.&#39;</code> 或 <code>&#39;e&#39;</code> 多于 1 个；</li><li><code>&#39;.&#39;</code> 在 <code>&#39;e&#39;</code> 后面出现；</li><li><code>&#39;e&#39;</code> 后面或前面为空，或者 <code>&#39;e&#39;</code> 前面紧跟着 <code>&#39;.&#39;</code>；</li><li><code>&#39;e&#39;</code> 后面紧跟着正负号，但正负号后面为空；</li></ol></li><li>剩下的都是合法情况；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-comment">// 去除行首行尾空格</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; s[j] == <span class="hljs-string">&#x27; &#x27;</span>) j--;<br>    <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 行首如果只有一个正负号，直接忽略</span><br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>() || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">int</span> dot = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>        &#123;<br>            dot++;<br>            <span class="hljs-keyword">if</span> (e || dot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <span class="hljs-comment">// . 多余一个，. 在 e 后面出现</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;e&#x27;</span> || s[i] == <span class="hljs-string">&#x27;E&#x27;</span>) <br>        &#123;<br>            e++;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == s.<span class="hljs-built_in">size</span>() || !i || e &gt; <span class="hljs-number">1</span> || i == <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// . 后面紧跟正负号，但是正负号后面为空</span><br>            <span class="hljs-keyword">if</span> (s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">67. 把字符串转换成整数</a></h3><p><strong>题意描述</strong>：写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 <code>atoi</code> 或者其他类似的库函数。</p><ul><li>函数需要移除开头空格字符，从第一个非空格的字符开始；</li><li>当第一个非空字符为 <code>+</code> 或者 <code>-</code> 时，需要将该符号和后面尽可能多的连续数字组合起来，作为该整数的正负号；</li><li>若第一个非空字符是数字，则直接将其余之后连续的数字字符组合起来，形成整数；</li><li>有效的整数部分之后多余的字符应当忽略；</li><li>假设该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</li></ul><p>在任何情况下，若函数不能进行有效的转换，返回 0；</p><p><strong>解题思路</strong>：根据题意需要考虑以下四种情况：</p><ol><li>首部空格：删除即可；</li><li>符号位：<code>+</code>, <code>-</code>, <code>无符号位</code>；新建一个变量保存符号位，返回前判断正负号；</li><li>非数字字符：遇到首个非数字的字符，立即返回；</li><li>数字字符：<ul><li>字符转数字：ASCII 码直接相减即可；</li><li>数字拼接：从左向右遍历数字，设当前位字符为 <code>c</code>，数字结果为 <code>res</code>：<code>res = 10*res+c-&#39;0&#39;</code></li></ul></li></ol><p><strong>数字越界处理：</strong></p><p>题目要求返回的数值范围在 $[-2^{31}, 2^{31} - 1]$ ，因此需要考虑数字越界问题。而题目指出环境只能存储 <code>32</code> 位大小的有符号整数，因此判断数字越界时，要保持 <code>res</code> 在 <code>int</code> 类型的取值范围内。</p><p>在每轮数字拼接前，判断 <code>res</code> 在此轮拼接之后是否超过 $2147483647$ ，若超过则加上符号位直接返回。设数字拼接边界为 $214748364$，则以下两种情况越界：</p><script type="math/tex; mode=display">\left \{ \begin{align}{}& res>214748364 \qquad \qquad \text{情况1:执行拼接} 10\times res \geq 2147483650 \text{越界} \\ & res = 214748364,x>7 \quad \text{情况2:拼接后是}2147483648\text{或者}2147483649越界\\ \end{align}\right.</script><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">// 全是空格</span><br><br>    <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;              <span class="hljs-comment">// 记录正负</span><br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) is_minus = <span class="hljs-literal">true</span>, i++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;+&#x27;</span>) i++;<br><br>    <span class="hljs-keyword">if</span> (str[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || str[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 首个非空字符为非数字字符</span><br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, boundry = INT_MAX / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (str[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || str[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 非法字符停止遍历</span><br>        <span class="hljs-keyword">if</span> (res &gt; boundry || res == boundry &amp;&amp; str[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> is_minus ? INT_MIN : INT_MAX;<br>        &#125;<br>        res = res * <span class="hljs-number">10</span> + (str[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> is_minus ? -res : res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">03. 数组中重复的数字</a></h3><p><strong>题意描述</strong>：在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0～n-1$ 的范围内。找出数组中任意一个重复的数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 <br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：</p><ul><li>方法1：哈希表统计，一次遍历数组中的元素，当遍历到重复数字时 <code>break</code>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>  x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (hash[x] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x;<br>        hash[x]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>方法2：原地交换。</li></ul><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211115173654.png" width = 600px div align = center/></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(i != nums[i] &amp;&amp; nums[i] != nums[nums[i]]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="53-I-在排序数组中查找数字-I"><a href="#53-I-在排序数组中查找数字-I" class="headerlink" title="53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">53 - I. 在排序数组中查找数字 I</a></h3><p><strong>题意描述</strong>：统计一个数字在排序数组中出现的次数。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br><br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：两次二分查找，在数组中找出这个数字的左边界和右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[r] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = r;<br>        l = left, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">53 - II. 0～n-1中缺失的数字</a></h3><p><strong>题意描述</strong>：一个长度为 $n-1$ 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 $0 \sim n-1$ 之内。在范围 $0 \sim n-1$ 内的 $n$ 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [0,1,3]<br>输出: 2<br><br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：二分查找。查找满足性质 <code>mid != nums[mid]</code> 的区段的左边界。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mid != nums[mid]) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04. 二维数组中的查找</a></h3><p><strong>题意描述</strong>：在一个 $n \times m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">matrix = [<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><br>target = 5, return true;<br>target = 20, return false;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：从数组右上角开始遍历，当该元素大于 <code>target</code> 时，到下一列的位置开始遍历，否则到下一行的位置开始遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11. 旋转数组的最小数字</a></h3><p><strong>题意描述</strong>：数组的旋转是指把数组最开始的若干个元素搬到数组的末尾。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：[3,4,5,1,2]<br>输出：1<br></code></pre></div></td></tr></table></figure><p>解题思路：题中数组满足部分有序，可尝试使用二分查找解法。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) r = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == nums[r]) r--;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[r];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50. 第一个只出现一次的字符</a></h3><p><strong>题意描述</strong>：在字符串 $s$ 中找出第一个只出现一次的字符。如果没有，返回一个单空格。$s $ 只包含小写字母。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;abaccdeff&quot;<br>输出：&#x27;b&#x27;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：两次遍历，第一次用哈希表统计字符串中每个字母出现的次数，第二次遍历查看出现一次的字母。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>        hash[x]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>        <span class="hljs-keyword">if</span> (hash[x] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h3 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">07. 重建二叉树</a></h3><p><strong>题意描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]<br></code></pre></div></td></tr></table></figure><p>限制：0 &lt;= 节点个数 &lt;= 5000</p><p><strong>解题思路</strong>：分治思想。前序遍历的首元素是根节点 <code>root</code> 的值。利用哈希表 <code>hash</code> 存储中序遍历中值与索引的映射，提高查询效率。<code>preL &gt; preR</code> 表示已经越过了叶节点，函数返回。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hash[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preL &gt; preR || inL &gt; inR) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preL]);<br>        <span class="hljs-keyword">int</span> index = hash[preorder[preL]];<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, preL + <span class="hljs-number">1</span>, index - inL + preL, inorder, inL, index - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, index - inL + preL + <span class="hljs-number">1</span>, preR, inorder, index + <span class="hljs-number">1</span>, inR);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">16. 数值的整数次方</a></h3><p><strong>题意描述</strong>：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：x = 2.00000, n = 10<br>输出：1024.00000<br><br>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25<br></code></pre></div></td></tr></table></figure><p>注意：</p><ul><li>$-100.0 &lt; x &lt; 100.0$</li><li>$-2^{31} &lt;= n &lt;= 2^{31}-1$</li><li>$-10^4 &lt;= x^n &lt;= 10^4$</li></ul><p><strong>解题思路</strong>：分治思想，快速幂模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k = n;<br>    <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>        is_minus = <span class="hljs-literal">true</span>;<br>        k = -k;<br>    &#125;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res *= x;<br>        x *= x;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> is_minus ? <span class="hljs-number">1</span> / res : res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">33. 二叉搜索树的后序遍历序列</a></h3><p><strong>题意描述</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,3,2,6,5]<br>输出: true<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：基于分治的思想，递归实现。</p><ul><li><code>l &gt;= r</code> 表示到达叶子节点，返回 <code>true</code>；</li><li>左子树节点值应当小于根节点的值 <code>rootVal</code>，且右子树节点值应当大于根节点的值 <code>rootVal</code>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> rootVal = postorder[r];<br>        <span class="hljs-keyword">int</span> k = l;<br>        <span class="hljs-keyword">while</span>(k &lt; r &amp;&amp; postorder[k] &lt; rootVal) k++;     <span class="hljs-comment">// k 应指向右子树首个节点的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; r; i++) &#123;<br>            <span class="hljs-keyword">if</span> (postorder[i] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, l, k - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">dfs</span>(postorder, k, r - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">17. 打印从1到最大的n位数</a></h3><p><strong>题意描述</strong>：输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]<br></code></pre></div></td></tr></table></figure><p>说明：用返回一个整数列表来代替打印；n 为正整数</p><p><strong>解题思路</strong>：打印数范围 $[1,10^n-1]$</p><p><img src = "https://pic.leetcode-cn.com/83f4b5930ddc1d42b05c724ea2950ee7f00427b11150c86b45bd88405f8c7c87-Picture1.png" width = 500px /></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    string s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        s.<span class="hljs-built_in">resize</span>(n, <span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            <span class="hljs-built_in">save</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            s[u] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(n, u + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 除去首部的 0</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(ptr &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[ptr] == <span class="hljs-string">&#x27;0&#x27;</span>) ptr++;<br>        <span class="hljs-keyword">if</span> (ptr != s.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(ptr)));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">51. 数组中的逆序对</a></h3><p><strong>题意描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [7,5,6,4]<br>输出: 5<br></code></pre></div></td></tr></table></figure><p>限制：<code>0 &lt;= 数组长度 &lt;= 50000</code></p><p><strong>解题思路</strong>：归并排序。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        tmp.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        res += <span class="hljs-built_in">merge_sort</span>(nums, l, mid);<br>        res += <span class="hljs-built_in">merge_sort</span>(nums, mid + <span class="hljs-number">1</span>, r);<br><br>        <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) tmp[k++] = nums[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                tmp[k++] = nums[j++];<br>                res += mid - i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) nums[i] = tmp[j];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="搜索与回溯算法"><a href="#搜索与回溯算法" class="headerlink" title="搜索与回溯算法"></a>搜索与回溯算法</h2><h3 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32 - I. 从上到下打印二叉树</a></h3><p><strong>题意描述</strong>：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7]<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>   <br>输出：[3,9,20,15,7]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：BFS，二叉树的层序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="32-II-从上到下打印二叉树-II"><a href="#32-II-从上到下打印二叉树-II" class="headerlink" title="32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">32 - II. 从上到下打印二叉树 II</a></h3><p><strong>题意描述</strong>：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>输出其层序遍历结果：<br>[ [3],<br>  [9,20],<br>  [15,7]]<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">32 - III. 从上到下打印二叉树 III</a></h3><p><strong>题意描述</strong>：实现一个函数按照之字形顺序打印二叉树。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>输出层次遍历结果：<br>[ [3],<br>  [20,9],<br>  [15,7]]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：同前几题类似，直接贴出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        flag = !flag;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            tmp.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) res.<span class="hljs-built_in">emplace_back</span>(tmp.<span class="hljs-built_in">rbegin</span>(), tmp.<span class="hljs-built_in">rend</span>());<br>        <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">emplace_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">26. 树的子结构</a></h3><p><strong>题意描述</strong>：输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。（约定空树不是任意一个树的子结构）</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定的树 A:<br>     3<br>    / \<br>   4   5<br>  / \<br> 1   2<br>给定的树 B：<br>   4 <br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：递归法。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 空树不是任何树的子结构</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSubStr</span>(A, B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStr</span><span class="hljs-params">(TreeNode* p1, TreeNode* p2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p1 || p1-&gt;val != p2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStr</span>(p1-&gt;left, p2-&gt;left) &amp;&amp; <span class="hljs-built_in">isSubStr</span>(p1-&gt;right, p2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">27. 二叉树的镜像</a></h3><p><strong>题意描述</strong>：输入一个二叉树，该函数输出它的镜像。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>     4<br>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>镜像输出：<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1<br></code></pre></div></td></tr></table></figure><p>递归解法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">auto</span> tmp = root-&gt;right;<br>    root-&gt;right = <span class="hljs-built_in">mirrorTree</span>(root-&gt;left);<br>    root-&gt;left = <span class="hljs-built_in">mirrorTree</span>(tmp);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>辅助栈解法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    stack&lt;TreeNode*&gt; stk;<br>    stk.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> node = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node-&gt;left) stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">28. 对称的二叉树</a></h3><p><strong>题意描述</strong>：判断一棵二叉树是不是对称的。对称二叉树定义：二叉树和它的镜像一样。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">二叉树 [1,2,2,3,4,4,3] 是对称的<br>1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：递归法。</p><ul><li>空树满足对称二叉树的性质；</li><li>不满足对称二叉树的情况：左右子儿子中存在空节点，左右子儿子节点值不相等。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">12. 矩阵中的路径</a></h3><p><strong>题意描述</strong>：给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;<br>输出：true<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：DFS + 回溯。首先遍历网格 <code>board</code> ，查找单词首字母。由于同一个单元格内的字母不能重复使用，因此在搜索的过程中我们需要标记已经访问过的位置，并在本次搜索结束时进行回溯。 </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">// 标记已访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n &amp;&amp; board[a][b] == word[u]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, a, b, u + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        board[x][y] = t;        <span class="hljs-comment">// 回溯</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">13. 机器人的运动范围</a></h3><p><strong>题意描述</strong>：地上有一个 $m$ 行 $n$ 列的方格，从坐标 [0, 0] 到坐标 [m - 1, n - 1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。求机器人能够到达多少个格子。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。<br><br>输入：m = 2, n = 3, k = 1<br>输出：3<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：DFS。<code>vis</code> 数组标记已经访问过的位置，<code>canArrived</code> 函数判断数组的位置是否可达。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; vis;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vis = vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(m, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">canArrived</span>(x, y, k)) <span class="hljs-keyword">return</span>;<br><br>        res++;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n &amp;&amp; !vis[a][b]) &#123;<br>                <span class="hljs-built_in">dfs</span>(a, b, m, n, k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canArrived</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a) &#123;<br>            t += a % <span class="hljs-number">10</span>;<br>            a /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b) &#123;<br>            t += b % <span class="hljs-number">10</span>;<br>            b /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t &lt;= k;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">34. 二叉树中和为某一值的路径</a></h3><p><strong>题意描述</strong>：给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。<strong>叶子节点</strong> 是指没有子节点的节点。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：DFS + 回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> curSum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>        curSum += root-&gt;val;<span class="hljs-comment">// curSum 是传值，所以不需要回溯</span><br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (curSum == target &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, curSum, target);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, curSum, target);<br>        path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">36. 二叉搜索树与双向链表</a></h3><p><strong>题意描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211116191037.png" width = 300px div align = center/></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" width = 500px div align = center/></p><p><strong>解题思路</strong>：二叉搜索树的中序遍历为<strong>递增序列</strong>。算法流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">dfs(cur): 递归法中序遍历；<br>1. 终止条件：当 cur 为 空表示越过叶子节点，需返回；<br>2. 递归左子树 dfs(cur-&gt;left)<br>3. 构建链表：<br>当 pre 为空时：代表正在访问链表头节点，记为 head；<br>当 pre 不为空时：修改双向节点指向，pre-&gt;right = cur，cur-&gt;left = pre；<br>保存 cur: 更新 pre = cur, 即节点 cur 是后继节点的 pre；<br>4. 递归右子树 dfs(cur-&gt;right)<br></code></pre></div></td></tr></table></figure><p>注意：在本算法中，需要特判根节点为 <code>nullptr</code> 的情况，中序遍历完成后，<code>head</code> 指向头节点，<code>pre</code> 指向尾节点，主函数中修改 <code>head</code> 和 <code>pre</code> 的双向节点指向。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Node *pre, *head;<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>) head = cur;<br>        <span class="hljs-keyword">else</span> &#123;<br>            pre-&gt;right = cur;<br>            cur-&gt;left = pre;<br>        &#125;<br>        pre = cur;<br>        <span class="hljs-built_in">dfs</span>(cur-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">54. 二叉搜索树的第k大节点</a></h3><p><strong>题意描述</strong>：给定一棵二叉搜索树，请找出其中第 $k$ 大的节点。（1 ≤ k ≤ 二叉搜索树元素个数）</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / \<br> 1   4<br>  \<br>   2<br>输出: 4<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：二叉搜索树的中序遍历为递增序列。若按照右中左顺序遍历就可以得到递减序列。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, k);<br>        k--;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k) <span class="hljs-built_in">dfs</span>(root-&gt;left, k);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">55 - I. 二叉树的深度</a></h3><p><strong>题意描述</strong>：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树 [3,9,20,null,null,15,7]，<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路 1</strong>：DFS 遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// DFS 遍历</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span> (!left || !right) <span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路 2</strong>：BFS 求二叉树的层数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(n--) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">55 - II. 平衡二叉树</a></h3><p><strong>题意描述</strong>：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树 [3,9,20,null,null,15,7]<br><br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回 true 。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：平衡二叉树的定义是其<strong>任意节点</strong>的左右子树的深度相差不超过 1。本题本质上是需要求二叉树的高度，因此可以套用上一题的解题思路来解本题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="68-I-叉搜索树的最近公共祖先"><a href="#68-I-叉搜索树的最近公共祖先" class="headerlink" title="68 - I. 叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68 - I. 叉搜索树的最近公共祖先</a></h3><p><strong>题意描述</strong>：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>祖先</strong>： 若节点 $p$ 在节点 $root$ 的左（右）子树中，或 $p = root$ ，则称 $root$ 是 $p$ 的祖先。</p><p><strong>最近公共祖先</strong>： 设节点 $root$ 为节点 $p, q$ 的某公共祖先，若其左子节点 <code>root-&gt;left</code> 和右子节点 <code>root-&gt;right</code> 都不是 $p, q$ 的公共祖先，则称 $root$ 是最近的公共祖先。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6 <br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>所有节点的值都是唯一的；</li><li><code>p</code> 与 <code>q</code> 为不同节点且均存在于给定的二叉搜索树中；</li></ul><p><strong>解题思路</strong>：题中两个重要条件：1）树为二叉搜索树；2）树中所有节点的值都是唯一的。根据这两个条件可以得到 <code>p,q</code> 与 <code>root</code> 的关系：</p><ul><li>若 <code>root-&gt;val == p-&gt;val</code>，<code>root</code> 和 <code>p</code> 指向同一个节点；</li><li>若 <code>root-&gt;val &gt; p-&gt;val</code>，<code>p</code> 在 <code>root</code> 的左子树中；</li><li>若 <code>root-&gt;val &lt; p-&gt;val</code>，<code>p</code> 在 <code>root</code> 的右子树中；</li></ul><p><strong>解法 1：迭代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">// 算法流程<br>while root 不为空<br>if p,q 都在 root 的右子树中：<br>遍历 root-&gt;right<br>else if p,q 都在 root 的左子树中：<br>遍历 root-&gt;left<br>else 找到了最近公共祖先，break<br>return root<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(root) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) <br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">// 迭代法优化：有序性——&gt; p-&gt;val &lt;= q-&gt;val</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;val &gt; q-&gt;val) &#123;<br>        <span class="hljs-built_in">swap</span>(p, q);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(root) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; q-&gt;val) <br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val) <br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>解法 2：递归</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">// 算法流程<br>当 p,q 都在 root 的右子树中，进入递归 root-&gt;right 并返回<br>当 p,q 都在 root 的左子树中，进入递归 root-&gt;left 并返回<br>返回值：最近公共祖先 root<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="68-II-二叉树的最近公共祖先"><a href="#68-II-二叉树的最近公共祖先" class="headerlink" title="68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68 - II. 二叉树的最近公共祖先</a></h3><p><strong>题意描述</strong>：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><br></code></pre></div></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>解题思路</strong>：针对 <code>root</code> 是 <code>p,q</code> 的最近公共祖先，则可能是以下情况之一：</p><ol><li><code>p</code> 和 <code>q</code> 在 <code>root</code> 的子树中，且分别位于 <code>root</code> 的两侧；</li><li><code>p == root</code> ，且 <code>q</code> 在 <code>root</code> 的左或右子树中；</li><li><code>q == root</code> ，且 <code>p</code> 在 <code>root</code> 的左或右子树中。</li></ol><p><strong>函数返回值分析</strong>：</p><ul><li><code>left</code> 和 <code>right</code> 同时为空：<code>root</code> 的左 / 右子树中都不包含 <code>p,q</code> ，返回 <code>nullptr</code>；</li><li><code>left</code> 和 <code>right</code> 同时不为空：说明 <code>p,q</code> 分列在 <code>root</code> 的异侧，因此 <code>root</code> 为最近公共祖先，返回 <code>root</code>；</li><li><code>left</code> 为空，<code>right</code> 不为空：<code>p,q</code> 都不在 <code>root</code> 的左子树中，直接返回 <code>right</code>，具体可分为两种情况：<ul><li><code>p,q</code> 其中一个在 <code>root</code> 的右子树中，此时 <code>right</code> 指向 <code>p</code> （假设为 <code>p</code>）；</li><li><code>p,q</code> 两节点都在 <code>root</code> 的右子树中，此时 <code>right</code> 指向 最近公共祖先节点。</li></ul></li><li><code>left</code> 不为空，<code>right</code> 为空：与情况 3 类似分析过程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">37. 序列化二叉树</a></h3><p><strong>题意描述</strong>：请实现两个函数，分别用来序列化和反序列化二叉树。你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-built_in">dfs_s</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode* root, string&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            res += <span class="hljs-string">&quot;null &quot;</span>;                     <span class="hljs-comment">// null + 空格表示</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        res += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span>;      <span class="hljs-comment">// 节点值 + 空格表示</span><br>        <br>        <span class="hljs-comment">// 递归处理左子树和右子树</span><br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, res);<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;right, res);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 当前遍历字符串中的位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(data, u);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs_d</span><span class="hljs-params">(string&amp; data, <span class="hljs-keyword">int</span>&amp; u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == data.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        // data 中字符的下标从 0 到 data.size() - 1, data[data.size() - 1] 的位置是空格</span><br><span class="hljs-comment">        // 最后一次递归结束，u = k + 1，所以 u == data.size() 为函数终止条件</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-keyword">int</span> k = u;      <span class="hljs-comment">// 记录空格的位置</span><br>        <span class="hljs-keyword">while</span> (data[k] != <span class="hljs-string">&#x27; &#x27;</span>) k++;<br>        <br>        <span class="hljs-keyword">if</span> (data[u] == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;       <span class="hljs-comment">// 当前遍历的是 &quot;null&quot;，此时 u 指向 &#x27;n&#x27;, k 指向 &quot;null&quot; 后的空格</span><br>            u = k + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;         <span class="hljs-comment">// 结束本次递归，返回空指针</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 判断当前值是否是负数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                is_minus = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            val = val * <span class="hljs-number">10</span> + data[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (is_minus) val = -val;       <span class="hljs-comment">// 负数特判</span><br>        u = k + <span class="hljs-number">1</span>;                      <span class="hljs-comment">// 下一个需要遍历的位置</span><br>        <br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        root-&gt;left = <span class="hljs-built_in">dfs_d</span>(data, u);<br>        root-&gt;right = <span class="hljs-built_in">dfs_d</span>(data, u);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">38. 字符串的排列</a></h3><p><strong>题意描述</strong>：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;abc&quot;<br>输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]<br></code></pre></div></td></tr></table></figure><p>限制：<code>1 &lt;= s 的长度 &lt;= 8</code></p><p><strong>解题思路</strong>：对于一个长度为 $n$ 的字符串（假设字符互不重复），其排列方案数有：$n \times (n - 1) \times (n - 2) \times … \times 2 \times 1$</p><p>当字符串存在重复的字符时，排列方案也存在重复的排列方案。为排除重复方案，需要在固定某位字符的时候，保证每种字符只在此位固定一次，即遇到重复字符时不交换，直接跳过。</p><p><img src = "https://pic.leetcode-cn.com/1599403497-GATdFr-Picture2.png" width = "500px" /></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string str;<br>    <span class="hljs-keyword">int</span> state;<span class="hljs-comment">// 记录访问状态</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 记得先排序，方便去重</span><br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; s[i - <span class="hljs-number">1</span>] == s[i] &amp;&amp; !(state &amp; (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)))) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!(state &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>                state ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>                str += s[i];<br>                <span class="hljs-built_in">dfs</span>(s, u + <span class="hljs-number">1</span>);<br>                str.<span class="hljs-built_in">pop_back</span>();<br>                state ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">10- I. 斐波那契数列</a></h3><p><strong>题意描述</strong>：输入 $n$ 求斐波那契（Fibonacci）数列的第 <code>n</code> 项。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br></code></pre></div></td></tr></table></figure><p>答案需要取模 1e9+7（1000000007），<code>0 &lt;= n &lt;= 100</code>。</p><p><strong>解题思路</strong>：题中已经给出了 $f[n]$ 的状态表示，考虑动态规划。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = b;<br>        b = (a + b) % MOD;<br>        a = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>快速幂解法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; res = <span class="hljs-built_in">qmi</span>(A, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">qmi</span>(vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A, <span class="hljs-keyword">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(k) &#123;<br>            <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br>                ret = <span class="hljs-built_in">mul</span>(ret, A);<br>            &#125;<br>            A = <span class="hljs-built_in">mul</span>(A, A);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">mul</span>(vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A, vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; B) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; res = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                res[i][j] = (A[i][<span class="hljs-number">0</span>] * B[<span class="hljs-number">0</span>][j] + A[i][<span class="hljs-number">1</span>] * B[<span class="hljs-number">1</span>][j])  % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10- II. 青蛙跳台阶问题</a></h3><p><strong>题意描述</strong>：每次可以跳 $1$ 级台阶也可以跳 $2$ 级台阶，求青蛙跳上一个 $n$ 级台阶总共有多少种跳法。答案对 $1e9+7$ 取模。</p><p><strong>解题思路</strong>：状态计算：$f[i] = f[i - 1] + f[i - 2]$。特别地，对于第 $0$ 级台阶有 $1$ 种跳法。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> c = (a + b) % <span class="hljs-number">1000000007</span>;<br>        a = b;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">63. 股票的最大利润</a></h3><p><strong>题意描述</strong>：把某股票的价格按照时间先后顺序存储在数组中，求买卖该股票一次可能获得的最大利润。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [7,1,5,3,6,4]<br>输出: 5<br><br>输入: [7,6,4,3,1]<br>输出: 0<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：遍历整个数组，每次遍历到一个元素时计算到目前为止的最低价格，并求得当前股价与最低价格之差（差值与本来结果取 $max$）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minPrice = INT_MAX, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : prices) &#123;<br>        minPrice = <span class="hljs-built_in">min</span>(minPrice, x);<br>        res = <span class="hljs-built_in">max</span>(res, x - minPrice);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">42. 连续子数组的最大和</a></h3><p><strong>题意描述</strong>：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：贪心。直接在原数组上进行遍历，只有数组中前一个元素大于 0 时才会对当前连续子数组的最大和有贡献价值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>        res = <span class="hljs-built_in">max</span>(res, nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">47. 礼物的最大价值</a></h3><p><strong>题意描述</strong>：在一个 $m \times n$ 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，求礼物最大价值。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: <br>[ [1,3,1],<br>  [1,5,1],<br>  [4,2,1]]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：DP 状态计算：$\text{f[i][j] = max(f[i][j - 1], f[i - 1][j]) + grid[i][j]}$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[m][n];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">46. 把数字翻译成字符串</a></h3><p><strong>题意描述</strong>：给定一个数字，我们定义翻译规则：$0 \sim 25$  分别翻译成 $a \sim z$ 。给定一个数字，求一共有多少种不同的翻译方法。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：考虑动态规划。定义状态表示：$dp[i]$ 为将前 $i$ 个数字翻译为字符串的方案数，其中 $dp[0] = 1$。</p><p>状态计算：$dp[i] = dp[i - 1] + dp[i - 2]$。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    string s = <span class="hljs-built_in">to_string</span>(num);<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 边界情况 dp[0] = 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> t = (s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">9</span> &amp;&amp; t &lt; <span class="hljs-number">26</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">48. 最长不含重复字符的子字符串</a></h3><p><strong>题意描述</strong>：给定一个字符串，求它的最长的不包含重复字符的子字符串的长度。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：哈希表 + 滑动窗口。核心思想：保持窗口 $\text{[j, i]}$ 内不含有重复字母。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        hash[s[i]]++;<br>        <span class="hljs-keyword">while</span>(hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j++]]--;<br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">19. 正则表达式匹配</a></h3><p><strong>题意描述</strong>：实现一个函数用来匹配包含 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code> 的正则表达式。模式中的字符 <code>&#39;.&#39;</code> 表示任意一个字符，而 <code>&#39;*&#39;</code> 表示它前面的字符可以出现任意次（含0次）。模板串需要匹配整个字符串。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">s = &quot;aa&quot;<br>p = &quot;a*&quot;<br>输出: true<br><br>s = &quot;aab&quot;<br>p = &quot;c*a*b&quot;<br>输出: true<br></code></pre></div></td></tr></table></figure><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母；</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code> ，无连续的 <code>*</code></li></ul><p><strong>解题思路 1</strong>：动态规划。</p><p><strong>状态表示</strong> <code>f[i][j]</code>：</p><ul><li><p>集合：所有 $s[1] \sim s[i]$ 和 $p[1] \sim p[j]$ 的匹配方案，这里假设下标从 $1$ 开始，并有 <code>f[0][0] = true</code>。</p></li><li><p>属性：<code>bool</code> 是否存在一个合法方案</p></li></ul><p><strong>状态计算</strong>：</p><ul><li><p>$p[j] \neq *$  </p><p><code>f[i][j] = (s[i] == p[j] || p[j] == &#39;.&#39;) &amp;&amp; f[i - 1][j - 1]</code></p></li><li><p>$p[j] = *$</p><p><code>f[i][j] = f[i][j-2] || f[i-1][j-2] &amp;&amp; (s[i] == p[j-1] || p[j-1] == &#39;.&#39;) || f[i-2][j-2] &amp;&amp; (s[i] == p[j-1] &amp;&amp; s[i-1] == p[j-1] || p[j-1] == &#39;.&#39;) || ...</code></p><p>上述式子表示：<code>p[j-1]p[j]</code> 匹配 $s$ 中 $0$ 个字符的情况 || 匹配 $s$ 中 $1$ 个字符的情况 || 匹配 $s$ 中 $2$ 个字符的情况 || …</p><p>状态转移过程优化到 $O(1)$ 时间：考虑 <code>f[i-1][j]</code> 的情况</p><p><code>f[i-1][j] = f[i-1][j-2] || f[i-2][j-2] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &#39;.&#39;) || ...</code></p><p><strong>找到共同点：</strong></p><p><code>f[i][j] = f[i][j-2] || f[i-1][j] &amp;&amp; (s[i] == p[j-1] || p[j-1] == &#39;.&#39;)</code></p></li></ul><p>循环枚举 $i$ 从 $0 \sim n$ ，$j$ 从 $1 \sim m$ ，因为 <code>f[0][j]</code> 有意义。</p><p>此时状态数量是 $nm$，转移需要 $O(1)$ 时间，总的时间复杂度就是 $n^2$ 级别。  </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = p.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>        s = <span class="hljs-string">&#x27; &#x27;</span> + s, p = <span class="hljs-string">&#x27; &#x27;</span> + p;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= m &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (i &amp;&amp; p[j] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    f[i][j] = f[i][j - <span class="hljs-number">2</span>] || i &amp;&amp; f[i - <span class="hljs-number">1</span>][j] &amp;&amp; (s[i] == p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路 2</strong>：动态规划（记忆化搜索），$n,m$ 分别表示 $s,p$ 的长度，状态转移复杂度是 $O(1)$，总的时间复杂度为 $O(nm)$。</p><p><strong>状态表示</strong> <code>f[i][j]</code>：</p><ul><li><p>集合： $s[i,…]$ 和 $p[j…]$ 的匹配方案。</p></li><li><p>属性：<code>bool</code> 是否存在一个合法方案</p></li></ul><p><strong>状态计算</strong>：</p><p>由于 <code>.</code> 可以匹配任意字符，<code>*</code> 表示其前面的字符可以出现任意次数。</p><ol><li><p>$p[j+1]$ 不是 <code>*</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f[i][j] = (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; f[i + <span class="hljs-number">1</span>][j +<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure></li><li><p>$p[j + 1]$ 是 <code>*</code> </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// p[j]p[j+1] 表示 p[j] 出现 0次 || ... 出现 1 次 || ... 出现 2 次</span><br>f[i][j] = f[i][j + <span class="hljs-number">2</span>] || (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; f[i + <span class="hljs-number">1</span>][j]<br></code></pre></div></td></tr></table></figure></li></ol><p><u>第二种情况解释</u>：</p><p>最直观的转移方式是：枚举通配符 <code>*</code> 可以匹配多少个 <code>p[j]</code>，只要有一种情况可以匹配，则 <code>f[i][j]</code> 就为真。但是，我们可以发现，<code>f[i][j]</code> 除了枚举 $0$ 个 <code>p[j]</code> 之外，其余的枚举操作都包含在 <code>f[i + 1][j]</code> 中，因此我们只要判断 <code>(s[i] == p[j] || p[j] == &#39;.&#39;) &amp;&amp; f[i + 1][j]</code> 即可。</p><p>边界：<code>f[n][m] = true</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; f;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        m = p.<span class="hljs-built_in">size</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s, p);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, string&amp; s, string&amp; p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][y];<br>        <span class="hljs-keyword">if</span> (y == m) &#123;<br>            <span class="hljs-keyword">return</span> f[x][y] = x == n;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> first_match = x &lt; n &amp;&amp; (s[x] == p[y] || p[y] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">bool</span> ans;<br>        <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; m &amp;&amp; p[y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            ans = <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">2</span>, s, p) || first_match &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, s, p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = first_match &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, s, p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x][y] = ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">49. 丑数</a></h3><p><strong>题意描述</strong>：丑数是指：只包含质因子 <code>2,3,5</code> 的数。求按照从小到大的顺序的第 $n$ 个丑数。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：从小到大枚举每一个丑数，并用指针索引 <code>a,b,c</code> 分别指示由 <code>2,3,5</code> 因子转移而来的丑数位置。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span> * dp[a], <span class="hljs-built_in">min</span>(<span class="hljs-number">3</span> * dp[b], <span class="hljs-number">5</span> * dp[c]));<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">2</span> * dp[a]) a++;<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">3</span> * dp[b]) b++;<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">5</span> * dp[c]) c++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">60. n个骰子的点数</a></h3><p><strong>题意描述</strong>：将一个骰子投掷 $n$ 次，获得的总点数为 $s$ ，$s$ 的可能范围是 $n \sim 6n$ 。输入 $n$ ，打印出 $s$ 的所有可能的值出现的概率。用一个浮点数数组返回答案，其中第 $i$ 个元素代表这 $n$ 个骰子所能掷出的点数集合中第 $i$ 小的那个的概率。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br></code></pre></div></td></tr></table></figure><p>限制：<code>1 &lt;= n &lt;= 11</code></p><p><strong>解题思路 1</strong>：DFS。<code>dfs(n, s)</code>：一共投掷了 $n$ 次，总和是 $s$ 的情况下的方案数目。（<strong>TLE</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= n * <span class="hljs-number">6</span>; i++) &#123;<br>            nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dfs</span>(n, i));       <span class="hljs-comment">// 投掷 n 次，总和是 i 的方案数目</span><br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res[i] = (<span class="hljs-keyword">double</span>)nums[i] / sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> !sum;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            res += <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, sum - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路 2</strong>：动态规划。<code>f[i][j]</code>：前 <code>i</code> 次，总和是 <code>j</code> 的方案数。由于第 <code>i</code> 次可能扔出的点数为 $1 \sim 6$，所以：</p><script type="math/tex; mode=display">f[i][j] = f[i - 1][j - 1] + f[i - 1][j - 2] + f[i - 1][j - 3]+f[i - 1][j - 4]+ f[i - 1][j - 5] + f[i - 1][j - 6]</script><p>，我们只需要用到最后一次的结果，可以使用滚动数组优化空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化前</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;      <span class="hljs-comment">// 枚举 n 次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i * <span class="hljs-number">6</span>; j++) &#123;      <span class="hljs-comment">// 枚举总点数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-number">6</span>, j); k++) &#123;      <span class="hljs-comment">// 最后一次投掷的点数</span><br>                f[i][j] += f[i - <span class="hljs-number">1</span>][j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= n * <span class="hljs-number">6</span>; i++) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(f[n][i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans[i] = (<span class="hljs-keyword">double</span>)res[i] / sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 优化后</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) dp[i] = <span class="hljs-number">1</span>;     <span class="hljs-comment">// DP初始值，表示1个骰子扔出的可能数为 1~6</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;              <span class="hljs-comment">// 第 2 ~ n 次投掷</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">6</span> * i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;      <span class="hljs-comment">// 投掷总点数</span><br>            dp[j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">6</span>; k &gt;= <span class="hljs-number">1</span>; k--) &#123;      <span class="hljs-comment">// 上一次投掷结果</span><br>                <span class="hljs-keyword">if</span> (j - k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                dp[j] += dp[j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(dp.begin() + n, dp.end())</span></span>;<br><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans[i] = (<span class="hljs-keyword">double</span>)res[i] / sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>用于解决一类<strong>基于 “子段” 的统计问题</strong>。子段：数组中连续的一段（下标范围可以用一个闭区间来表示）。这类题目的朴素做法都是两重循环的枚举，枚举左端点 $l$ 、右端点 $r$ （$l \leq r$） ，优化手段都是找到枚举中的冗余部分，将其去除。</p><p><strong>优化策略：</strong></p><ul><li>固定右端点，看左端点的取值范围<ul><li>例如左端点的取值范围是一个前缀，可以用<u>前缀和</u>等算法维护前缀信息</li></ul></li><li>移动一个端点，看另一个端点的变化情况<ul><li>例如一个端点跟随另一个端点单调移动，<u>滑动窗口</u></li><li><u>双指针扫描</u></li></ul></li></ul><h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">18. 删除链表的节点</a></h3><p><strong>题意描述</strong>：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br></code></pre></div></td></tr></table></figure><p>说明：</p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><p><strong>解题思路</strong>：题中说了链表节点值互不相同，我们只需按照节点的值进行查找遍历即可。注意要删除的点可能是链表的头节点，因此我们需要设置虚拟头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* cur = dummy;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22. 链表中倒数第k个节点</a></h3><p><strong>题意描述</strong>：输入一个链表，输出该链表中倒数第k个节点。（链表的尾节点是倒数第1个节点。）</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双指针。设置指针 $\text{p1}$ 指向 $\text{head}$，指针 $\text{p2}$ 指向 $\text{head}$ 后面的第 $k$ 个节点的位置。同时移动两个指针节点，直到 $\text{p2}$ 指向 $\text{nullptr}$ 为止。 </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode *p1 = head, *p2 = head;<br>    <span class="hljs-keyword">while</span> (k--) <br>        p2 = p2-&gt;next;<br>    <span class="hljs-keyword">while</span>(p2) &#123;<br>        p1 = p1-&gt;next, p2 = p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25. 合并两个排序的链表</a></h3><p><strong>题意描述</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双指针。两个指针分别指向链表当前遍历到的节点，比较大小关系即可。同样本题需要设置虚拟头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">auto</span> cur = dummy;<br>    <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            cur-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1) cur-&gt;next = l1;<br>    <span class="hljs-keyword">else</span> cur-&gt;next = l2;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h3><p><strong>题意描述</strong>：输入两个链表，找出它们的第一个公共节点。如果两个链表没有交点，返回空节点。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br>输出第一个公共节点c1<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双指针。两个指针分别指向两个链表，各自依次往后遍历，直到两个指针指向的链表节点相等为止。循环内，当某个节点遍历到 $\text{nullptr}$ 时，我们让其从另一个链表的位置开始遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p1 = headA, p2 = headB;<br>    <span class="hljs-keyword">while</span>(p1 != p2) &#123;<br>        p1 = p1 ? p1-&gt;next : headB;<br>        p2 = p2 ? p2-&gt;next : headA;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">21. 调整数组顺序使奇数位于偶数前面</a></h3><p><strong>题意描述</strong>：输入一个整数数组，我们需要调整数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [1,2,3,4]<br>输出：[1,3,2,4] <br>注：[3,1,2,4] 也是正确的答案之一。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双指针。两个指针分别数组的头和尾，指针 $i$ 从前往后找偶数位置，指针 $j$ 从后往前找奇数位置，满足 $i &lt; j$ 时则交换两个元素的值，直到两个指针位置交错时循环结束。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>)) i++;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)) j--;<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">57. 和为s的两个数字</a></h3><p><strong>题意描述</strong>：输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：双指针。两个指针分别指向数组的头和尾，根据判断条件向中间收缩。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> &#123;nums[i], nums[j]&#125;;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">58 - I. 翻转单词顺序</a></h3><p><strong>题意描述</strong>：输入一个字符串，翻转字符串中单词的顺序，但单词内字符的顺序不变。（标点符号和普通字母一样处理）</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: &quot;  hello world!  &quot;<br>输出: &quot;world! hello&quot;<br></code></pre></div></td></tr></table></figure><p>注意：</p><ul><li><p>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></li><li><p>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></li></ul><p><strong>解题思路</strong>：双指针。保持区间 $[i, j)$ 内的字符串恰好是一个单词，然后我们翻转该单词，并用 $k$ 来标记期望输出字符串的长度。循环结束我们 <code>resize</code> 字符串长度，并反转字符串即可得到符合要求的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>        <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">int</span> j = i;<br>        <span class="hljs-keyword">while</span>(j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + j);<br>        <span class="hljs-keyword">if</span> (k) s[k++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) s[k++] = s[i++];<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(k);<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">45. 把数组排成最小的数</a></h3><p><strong>题意描述</strong>：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [10,2]<br>输出: &quot;102&quot;<br><br>输入: [3,30,34,5,9]<br>输出: &quot;3033459&quot;<br></code></pre></div></td></tr></table></figure><p>说明：</p><ul><li>输出结果可能非常大，我们返回一个字符串即可；</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0；</li></ul><p><strong>解题思路</strong>：自定义一个排序逻辑，针对数组 $nums$ 中任意两个数字的字符串为 $x$ 和 $y$，规定 $x + y &lt; y + x$ ，则 $x$ 应该排在 $y$ 的前面。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [=](<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)&#123;<br>        string stra = <span class="hljs-built_in">to_string</span>(a), strb = <span class="hljs-built_in">to_string</span>(b);<br>        <span class="hljs-keyword">return</span> stra + strb &lt; strb + stra;<br>    &#125;);<br><br>    <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>        res += <span class="hljs-built_in">to_string</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title=" 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/"> 61. 扑克牌中的顺子</a></h3><p><strong>题意描述</strong>：从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,2,3,4,5]<br>输出: True<br><br>输入: [0,0,1,2,5]<br>输出: True<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：对数组进行排序，并统计数组中为 0 的元素个数。5 张牌是顺子的条件：</p><ul><li>除了大小王之外，不含有重复的元素；</li><li>数组中最大的元素 - 数组中最小的非零元素 $\leq$ 4；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nums[cnt] == <span class="hljs-number">0</span>) &#123;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cnt + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">back</span>() - nums[cnt] &lt;= <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">40. 最小的k个数</a></h3><p><strong>题意描述</strong>：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：排序：快速排序，归并排序，堆排序。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">quick_sort</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        arr.<span class="hljs-built_in">resize</span>(k);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[(l + r) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>        <span class="hljs-built_in">quick_sort</span>(arr, l, j), <span class="hljs-built_in">quick_sort</span>(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 归并排序子函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(arr, l, mid), <span class="hljs-built_in">merge_sort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = arr[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = arr[j++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) arr[i] = tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">41. 数据流中的中位数</a></h3><p><strong>题意描述</strong>：设计一个支持以下两种操作的数据结构：</p><ul><li><code>void addNum(int num)</code> ：从数据流中添加一个整数到数据结构中。</li><li><code>double findMedian()</code>：返回目前所有元素的中位数。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：设计两个堆，一个大根堆 <code>maxHeap</code>，一个小根堆 <code>minHeap</code>。</p><ul><li>维持大根堆 <code>maxHeap</code> 内元素数量<strong>至多</strong>比小根堆 <code>minHeap</code> 多一个。<ul><li>若 <code>maxHeap.size() == minHeap.size()</code>，中位数是两者堆顶元素的均值；</li><li>若 <code>maxHeap.size() == minHeap.size() + 1</code>，中位数是 <code>maxHeap.top()</code>； </li></ul></li><li>有序性：<code>maxHeap.top() &lt;= minHeap.top()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    priority_queue&lt;<span class="hljs-keyword">int</span>&gt; maxHeap;    <span class="hljs-comment">// 默认大根堆</span><br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap; <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-built_in">MedianFinder</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        maxHeap.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() &gt; minHeap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(maxHeap.<span class="hljs-built_in">top</span>());<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (minHeap.<span class="hljs-built_in">size</span>() &amp;&amp; maxHeap.<span class="hljs-built_in">top</span>() &gt; minHeap.<span class="hljs-built_in">top</span>()) &#123;<br>            <span class="hljs-keyword">int</span> x = maxHeap.<span class="hljs-built_in">top</span>(), y = minHeap.<span class="hljs-built_in">top</span>();<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            maxHeap.<span class="hljs-built_in">push</span>(y);<br>            minHeap.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() == minHeap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (maxHeap.<span class="hljs-built_in">top</span>() + minHeap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">15. 二进制中1的个数</a></h3><p><strong>题意描述</strong>：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>解题思路</strong>：<code>n&amp;(n-1)</code> 每次移除最低位上的比特 <code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        res++;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">65. 不用加减乘除做加法</a></h3><p><strong>题意描述</strong>：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: a = 1, b = 1<br>输出: 2<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 0</li><li>结果不会溢出 32 位整数</li></ul><p><strong>解题思路</strong>：不进位加法：<code>a^b</code>，进位：<code>a&amp;b</code>。 </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b) &#123;<br>        <span class="hljs-keyword">int</span> sum = a ^ b;<br>        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        a = sum;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">56 - I. 数组中数字出现的次数</a></h3><p><strong>题意描述</strong>：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：位运算，假设答案分别为 $a$ 和 $b$，且 <code>t = a ^ b</code>。</p><ul><li>遍历数组先求 $t$ ；</li><li>求 $t$ 的第几位上是 $1$；</li><li>遍历数组求 $a$，<code>b = t ^ a</code>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>        t ^= num;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!(t &gt;&gt; i &amp; <span class="hljs-number">1</span>)) &#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num &gt;&gt; i &amp; <span class="hljs-number">1</span>) a ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;a, t ^ a&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="56-II-数组中数字出现的次数-II"><a href="#56-II-数组中数字出现的次数-II" class="headerlink" title="56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">56 - II. 数组中数字出现的次数 II</a></h3><p><strong>题意描述</strong>：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [3,4,3,3]<br>输出：4<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：$res$ 的第 $i$ 个二进制位就是数组中所有元素的第 $i$ 个二进制位之和除以 $3$ 的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>            t += (num &gt;&gt; i &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        res += (t % <span class="hljs-number">3</span>) &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">64. 求1+2+…+n</a></h3><p><strong>题意描述</strong>：求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 3<br>输出: 6<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：运算符 <code>&amp;&amp;</code> 的短路求值特性。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = n;<br>    n &amp;&amp; (res += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">39. 数组中出现次数超过一半的数字</a></h3><p><strong>题意描述</strong>：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：一共三种解法，其中摩尔投票法为最优解法。</p><ul><li>解法1：数组由小到大排序，取中位数；</li><li>解法2：哈希表统计数组元素出现次数；</li><li><strong>解法3</strong>：摩尔投票法，票数正负抵消；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>], cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>            res = nums[i];<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (res == nums[i]) cnt++;<br>            <span class="hljs-keyword">else</span> cnt--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">66. 构建乘积数组</a></h3><p><strong>题意描述</strong>：给定一个数组 $A[0,1,…,n-1]$，请构建一个数组 $B[0,1,…,n-1]$，其中 $B[i]$ 的值是数组 $A$ 中除了下标 $i$ 以外的元素的积, 即 $B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]$。不能使用除法。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有元素乘积之和不会溢出 32 位整数</li><li><code>a.length &lt;= 100000</code></li></ul><p><strong>解题思路</strong>：构建前后缀差分数组。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, t = a[<span class="hljs-number">0</span>]; i &lt; n; i++) &#123;<br>        b[i] = t;<br>        t *= a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>, t = a[n - <span class="hljs-number">1</span>]; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        b[i] *= t;<br>        t *= a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">14- I. 剪绳子</a></h3><p><strong>题意描述</strong>：将一根长度为 $n$ 的绳子剪成整数长度的 $m$ 段（$m,n$ 都是整数，$n,m&gt;1$），每段绳子的长度记为 $k[0],k[1]…k[m-1]$ 。请问  $k[0] \times k[1] \times…\times k[m-1]$ 可能的最大乘积是多少。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br></code></pre></div></td></tr></table></figure><p>提示：<code>2 &lt;= n &lt;= 58</code></p><p><strong>解题思路 1</strong>：<strong>贪心</strong>：将一个正整数 $N$ 拆分成若干个整数有有限种拆法，所以存在最大乘积。<u>重要推论</u>：1）所有绳段长度相等时，乘积最大；2）最优绳段长度为 3；</p><p>假设 $N=n_1 + n_2 + … + n_k$，并且 $n_1 \times n_2 \times n_3 \times … \times n_k$ 是最大乘积。</p><ul><li>显然，$1$ 不会出现在其中；</li><li>如果对于某个 $n_i \geq 5$，那么将 $n_i$ 拆分成 $3 + (n_i - 3)$ ，有 $3 * (n_i - 3) &gt; n_i$</li><li>如果 $n_i = 4$ ，拆分成 $2 + 2$ 乘积不变，所以假设没有 $4$</li><li>如果有 $3$ 个连续以上 $2$，那么 $3 \times 3 &gt; 2 \times 2 \times 2$ ，所以替换成 $3$ 乘积更大；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;       <span class="hljs-comment">// 不能有 4，2 * 2 &gt; 3 * 1</span><br>        res = <span class="hljs-number">4</span>;<br>        n -= <span class="hljs-number">4</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>        res = <span class="hljs-number">2</span>;<br>        n -= <span class="hljs-number">2</span>;<br>    &#125; <br>    <span class="hljs-keyword">while</span>(n) &#123;      <span class="hljs-comment">// e 处取</span><br>        res *= <span class="hljs-number">3</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>解题思路 2</strong>：<strong>动态规划</strong>。定义状态 <code>f[i]</code> 为将长度为 $i$ 的绳子剪成若干段后各段长度乘积的最大值。剪第一刀时，我们有 $n - 1$ 种可能的选择，也就是剪出来的第一段绳子的可能长度分别是 $1,2,..,n-1$。因此 $f[i] = max(f[i], max(j <em> (i - j), j </em> f[i - j]))$。</p><p>减去第一段长度为 $j$ 的绳子之后，可以选择不再剪断，也可选择继续往下剪。若是继续剪，则需要继续求子问题 $f[i - j]$。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>            f[i] = <span class="hljs-built_in">max</span>(f[i], <span class="hljs-built_in">max</span>(j * (i - j), j * f[i - j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="14-II-剪绳子-II"><a href="#14-II-剪绳子-II" class="headerlink" title="14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">14- II. 剪绳子 II</a></h3><p><strong>题意描述</strong>：将一根长度为 $n$ 的绳子剪成整数长度的 $m$ 段（$m,n$ 都是整数，$n,m&gt;1$），每段绳子的长度记为 $k[0],k[1]…k[m-1]$ 。请问  $k[0] \times k[1] \times…\times k[m-1]$ 可能的最大乘积是多少。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>提示：<code>2 &lt;= n &lt;= 1000</code></p><p><strong>解题思路</strong>：本题只能数学推导出答案。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>        res = <span class="hljs-number">4</span>;<br>        n -= <span class="hljs-number">4</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>        res = <span class="hljs-number">2</span>;<br>        n -= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        res = (res* <span class="hljs-number">3</span>) % <span class="hljs-number">1000000007</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="57-II-和s的连续正数序列"><a href="#57-II-和s的连续正数序列" class="headerlink" title="57 - II. 和s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">57 - II. 和s的连续正数序列</a></h3><p><strong>题意描述</strong>：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]<br></code></pre></div></td></tr></table></figure><p>限制：<code>1 &lt;= target &lt;= 10^5</code></p><p><strong>解题思路</strong>：<strong>双指针（滑动窗口）</strong>。设连续正整数序列的左边界 $left$ 和右边界 $right$ ，则可构建滑动窗口从左向右滑动。循环中，每轮判断滑动窗口内的元素和与目标值 $target$ 的大小关系。若相等则记录，若大于 $target$ 则移动左边界 $left$ （以减少窗口内的元素和），若小于 $target$ 则移动右边界 $right$ （以增加窗口内的元素和）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-keyword">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">2</span>, sum = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>            sum -= left;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right++;<br>            sum += right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">62. 圆圈中最后剩下的数字</a></h3><p><strong>题意描述</strong>：$0,1,···,n-1$ 这 $n$ 个数字排成一个圆圈，从数字 $0$ 开始，每次从这个圆圈里删除第 $m$ 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：约瑟夫环问题。由下往上递推：$(\text{当前索引编号} index + m) \mod \text{上一轮元素个数} i$ </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        index = (index + m) % i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 简化版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">lastRemaining</span>(n - <span class="hljs-number">1</span>, m) + m) % n;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="43-1～n-整数中-1-出现的次数"><a href="#43-1～n-整数中-1-出现的次数" class="headerlink" title="43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">43. 1～n 整数中 1 出现的次数</a></h3><p><strong>题意描述</strong>：输入一个整数 $n$ ，求 $1～n$ 这 $n$ 个整数的十进制表示中 $1$ 出现的次数。$1 &lt;= n &lt; 2^{31}$</p><p><strong>解题思路</strong>：本题实际上是数位统计 DP 问题。具体可见算法基础课。假设有一个数为 $abcdefg$，我们需要分析其每一位上 $1$ 的情况，下面我们讨论 $d$ 所在位上 $1$ 的个数。</p><ul><li>假设 $d=0$，是一个组合问题，方案数为 $abc$ 的取值方案数乘以 $efg$ 的取值方案数，也即 $abc$ 可取 $000 \sim abc - 1$， $efg$ 可取 $000 \sim 999$， 得 $abc \times 1000$；</li><li>假设 $d=1$，一共是 $abc \times 1000 + efg+1$ 种，为方便理解分为两种情况计算：<ul><li>$abc$ 取 $000 \sim abc - 1$， 则 $efg$ 取 $000 \sim 999$， 得 $abc \times 1000$；</li><li>$abc$ 取 $abc$， 则 $efg$ 取 $000 \sim efg$， 得 $efg+1$；</li></ul></li><li>假设 $d&gt;1$，即 $abc$ 可取 $000 \sim abc$， $efg$ 可取 $000 \sim 999$， 得 $(abc+1) \times 1000$；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>        <span class="hljs-keyword">while</span>(n) &#123;<br>            nums.<span class="hljs-built_in">push_back</span>(n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 低位到高位逐位计算 1 出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= i + <span class="hljs-number">1</span>; j--) &#123;<br>                left = left * <span class="hljs-number">10</span> + nums[j];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                right = right * <span class="hljs-number">10</span> + nums[j];<br>                p *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) res += left * p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) res += left * p + right + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> res += (left + <span class="hljs-number">1</span>) * p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">44. 数字序列中某一位的数字</a></h3><p><strong>题意描述</strong>：数字以 <code>0123456789101112131415…</code> 的格式序列化到一个字符序列中。在这个序列中，第 $5$ 位（从下标0开始计数）是 $5$，第 $13$ 位是 $1$，第 $19$ 位是$4$，等等。请写一个函数，求任意第 $n$ 位对应的数字。</p><p>限制：<code>0 &lt;= n &lt; 2^31</code></p><p><strong>解题思路</strong>：</p><ol><li>将 $01234567…$ 中的每一位称为<strong>数位</strong>，记为 $n$；</li><li>将 $0,1,2,…$ 称为<strong>数字</strong>，记为 $num$；</li><li>数字 $1$ 是一个一位数，此数字的<strong>位数</strong>为 $1$，记为 $digit$；</li><li>每个 $digit$ 位数的起始数字（即：$1,10,…$），记为 $start$。</li></ol><p><img src = "https://pic.leetcode-cn.com/2cd7d8a6a881b697a43f153d6c10e0e991817d78f92b9201b6ab71e44cb619de-Picture1.png" width = 500px /></p><p>解题过程分为三步：</p><ol><li>确定 $n$ 所在数字的位数 $digit$；</li><li>确定 $n$ 所在数字 $num$；</li><li>确定 $n$ 是 $num$ 中的哪一位数位，返回结果；</li></ol><hr><p>一、确定 $n$ 所在数字的位数 $digit$</p><p>循环执行 $n$ 减去一位数、两位数、… 的数位数量 $count$，直到 $n \leq count$ 跳出。</p><p>循环结束时，$n$ 是从每个 $digit$ 位数的起始数字 $start$ 开始计数的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>, start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">while</span>(n &gt; count) &#123;<br>    n -= count;<br>    start *= <span class="hljs-number">10</span>;<br>    digit++;<br>    count = <span class="hljs-number">9</span> * start * digit;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>二、确定 $n$ 所在数字 $num$</p><p>所求数位在从数字 $start$ 开始的第 $\frac{n-1}{digit}$ 个数字中，$start$ 为第 $0$ 个数字；</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">num = start + (n - <span class="hljs-number">1</span>) / digit;<br></code></pre></div></td></tr></table></figure><p>三、确定 $n$ 是 $num$ 中的哪一位数位，返回结果</p><p>所求数位为数字 $num$ 的第 $(n - 1) \% digit$ 位（数字的首个数位为第 $0$ 位）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">s = <span class="hljs-built_in">to_string</span>(num);<br>res = <span class="hljs-built_in">stoi</span>(s[(n - <span class="hljs-number">1</span>) % digit]);<br></code></pre></div></td></tr></table></figure><hr><ul><li>时间复杂度 $O(\text{log }n)$：所求数位 $n$ 对应数字 $num$ 的位数 $digit$ 最大为  $O(\text{log }n)$ ；第一步最多循环  $O(\text{log }n)$ 次；第三步中将 $num$ 转化为字符串使用  $O(\text{log }n)$ 时间；因此总体为  $O(\text{log }n)$。</li><li>空间复杂度  $O(\text{log }n)$：将数字 $num$ 转化为字符串 $s$ ，占用  $O(\text{log }n)$ 的空间。</li></ul><blockquote><p>参考<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/">Krahets 题解</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; count) &#123;<br>        n -= count;<br>        start *= <span class="hljs-number">10</span>;<br>        digit++;<br>        count = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">9</span> * start * digit;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = start + (n - <span class="hljs-number">1</span>) / digit;<br>    string s = <span class="hljs-built_in">to_string</span>(num);<br>    <span class="hljs-keyword">return</span> s[(n - <span class="hljs-number">1</span>) % digit] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">29. 顺时针打印矩阵</a></h3><p><strong>题意描述</strong>：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br></code></pre></div></td></tr></table></figure><p>限制：<code>0 &lt;= matrix.length &lt;= 100</code>，<code>0 &lt;= matrix[i].length &lt;= 100</code></p><p><strong>解题思路</strong>：代码中以 <code>st</code> 数组来标记元素是否被访问过，尽管有点浪费空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(m, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(matrix[x][y]);<br>        st[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> a = x + dx[d], b = y + dy[d];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= m || b &lt; <span class="hljs-number">0</span> || b &gt;= n || st[a][b]) &#123;<br>            d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            a = x + dx[d], b = y + dy[d];<br>        &#125;<br>        x = a, y = b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">31. 栈的压入、弹出序列</a></h3><p><strong>题意描述</strong>：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br></code></pre></div></td></tr></table></figure><p><strong>解题思路</strong>：见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pushed.<span class="hljs-built_in">size</span>() != popped.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : pushed) &#123;<br>            stk.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == popped[i]) &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>如何理解算法时间复杂度的表示法(<a href="http://www.zhihu.com/question/21387264">http://www.zhihu.com/question/21387264</a>)<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>图解算法与数据结构(<a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/</a>)<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms">Master theorem</a>)<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.acwing.com/">https://www.acwing.com/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下vim与tmux的使用</title>
    <link href="/2021/09/10/vim%E4%B8%8Etmux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/10/vim%E4%B8%8Etmux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><code>vim</code> 编辑器是在终端运行的文本代码编辑器。</p><p><code>tmux</code> 是 linux 中一种管理窗口的程序，支持多标签、分割窗口以及窗口组随时存储和恢复的功能。</p><span id="more"></span><h2 id="Vim-使用指南"><a href="#Vim-使用指南" class="headerlink" title="Vim 使用指南"></a>Vim 使用指南</h2><p><code>vim</code> 编辑器是在终端运行的文本代码编辑器。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sequence">Title: 标题：Vim 编辑器三种模式切换<br>命令模式-&gt;插入模式: 输入 i<br>Note left of 命令模式: 进入 vim 的初始状态<br>Note right of 底线命令模式: 保存退出:wq，退出:q，强制退出:q!<br>插入模式-&gt;命令模式: ESC<br>命令模式-&gt;底线命令模式: 输入:<br>底线命令模式-&gt;命令模式: 命令以回车结束运行<br># participant C<br># Note right of C: 没人陪我玩<br></code></pre></div></td></tr></table></figure><pre><code class=" mermaid">graph LRA[修改vim配置文件]--&gt; B[配置相应命令]</code></pre><p>一般我们可以在 <code>github</code> 上找别人配置好的 <code>.vimrc</code>  文件。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim ~/.vimrc<span class="hljs-comment">#在当前用户的根目录下新建 .vimrc 文件</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 底线命令模式输入以下命令</span><br><span class="hljs-meta">$</span><span class="bash"> syntax on<span class="hljs-comment"># 语法高亮</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span> number<span class="hljs-comment"># 设置行号</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span> nonumber<span class="hljs-comment"># 取消行号设置</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置好 vim 配置文件之后，保存退出之后，下次再进入就自动设置了语法高亮并且设置了行号</span><br></code></pre></div></td></tr></table></figure><p>常用的 <code>vim</code> 快捷键</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">h（左） j（下） k（上） l （右）<br>w# 每次跳一个单词<br>b# 往回跳<br>ctrl + f# forword 往下翻页<br>ctrl + b# 往上翻页<br>88gg# 跳到 88 行<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 往下，往上跳指定行</span> <br>10j# 往下跳 10 行<br>10k# 往上跳 10 行<br><br>/[内容]# 查找内容 <br>按下 n 键可以跳到下一个查找的目标结果，shift + n 跳到上一个目标结果<br><br>cc# 剪贴当前行<br>c2c# 剪贴底下两行<br>u# 撤销删除操作<br>pp# 粘贴刚刚剪贴的内容<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 批量选择</span><br><span class="hljs-meta">#</span><span class="bash"> 1. 命令模式中，按下 v 进入 visual 模式，然后搭配 hjkl（左下上右）键位使用，进行批量选择。</span><br><span class="hljs-meta">#</span><span class="bash"> 2. 搭配 c（剪贴） p（粘贴） u（撤销）键位使用</span><br>yy# 复制当前行内容<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 自动补全</span><br>ctrl + n# 出现选项之后，按下 enter<br></code></pre></div></td></tr></table></figure><p>:star: <code>vim</code> 插件管理器 + <strong>vim 自动补全插件</strong></p><ul><li>预先安装 <code>git</code> 和 <code>curl</code></li><li>安装 vim plug 插件（vim 插件管理软件），在 github 上下载；<a href="https://github.com/junegunn/vim-plug">链接</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br></code></pre></div></td></tr></table></figure><ul><li>修改 <code>~/.vimrc</code> 文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 末尾添加</span><br>call plug#begin()<br>Plug &#x27;scrooloose/nerdtree&#x27;# 添加的插件名字<br>call plug#end()<br></code></pre></div></td></tr></table></figure><ul><li>任意打开一个文件，假设我们 <code>vim code.cpp</code>，然后在 <code>code.cpp</code> 的底线命令模式下输入 <code>:PlugInstall</code></li></ul><blockquote><p><a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a></p><p><a href="https://vimawesome.com/plugin/nerdtree-red">https://vimawesome.com/plugin/nerdtree-red</a></p></blockquote><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E4%B8%8Bvim%E4%BD%BF%E7%94%A8_1.png" width = "600px" /></div><p>:star: 上面所示我们已经安装了一个插件 <code>NERDTree</code> ，使用方式：</p><ol><li><p>首先随意打开一个文件，假设打开 <code>vim code.c</code> </p></li><li><p>输入 <code>:NERDTree</code>，实现像目录一样浏览系统中的文件</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换左右两边窗口</span><br>按两次 ctrl + w<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 打开该文件</span><br>Enter<br></code></pre></div></td></tr></table></figure><p>:star: 每次使用 <code>vim</code> 都打开 <code>NERDTree</code> 插件的解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Just write this line to your .vimrc :</span><br>autocmd VimEnter * NERDTree<br></code></pre></div></td></tr></table></figure><blockquote><p><a href="https://stackoverflow.com/questions/3788903/how-to-start-vim-with-nerd-tree-opened-automatically#">execute nerdtree automatically</a></p></blockquote><p>:star: 删除插件的方法</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">PlugClean<br></code></pre></div></td></tr></table></figure><h2 id="Tmux-使用指南"><a href="#Tmux-使用指南" class="headerlink" title="Tmux 使用指南"></a>Tmux 使用指南</h2><p><code>tmux</code> 是 linux 中一种管理窗口的程序，支持多标签、分割窗口以及窗口组随时存储和恢复的功能。<code>tmux</code> 的主要元素分为三层：</p><ul><li><em>Session</em> 一组窗口的集合， 通常用来概括同一个任务。<em>session</em> 可以有自己的名字便于任务之间的切换。</li><li><em>Window</em> 单个可见窗口。<em>Windows</em> 有自己的编号，也可以认为和 ITerm2 中的 <em>Tab</em> 类似。</li><li><em>Pane</em> 窗格，被划分成小块的窗口，类似于 <em>Vim</em> 中 C-w +v 后的效果。</li></ul><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E4%B8%8Btmux%E4%BD%BF%E7%94%A8_1.png" width = "500px"/></div><p><code>tmux</code>：即使关闭 tmux，下次重新 attch 时，之前的东西还在服务器后台运行。为便于表述我们定义 <code>pre = ctrl + b</code> ，实际上我们使用时一般会修改 <code>tmux</code> 配置文件 <code>vim ~/.tmux.conf</code>，将快捷键 <code>ctrl+b</code> 改为 <code>ctrl+a</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">### panes</span><br>pre + %<span class="hljs-comment"># 水平分割 pane</span><br>pre + <span class="hljs-string">&quot;# 垂直分割 pane</span><br><span class="hljs-string">exit# 退出pane</span><br><span class="hljs-string">pre + z# 放大当前的 pane</span><br><span class="hljs-string">pre + z# 复原之前的 pane 状态(缩小)</span><br><span class="hljs-string">pre + 上下左右# 切换 pane</span><br><span class="hljs-string">alt + 上下左右# 切换 pane（这个需要修改配置文件）</span><br><span class="hljs-string"></span><br><span class="hljs-string">### windows</span><br><span class="hljs-string">pre + c# 创建一个新的 window</span><br><span class="hljs-string">pre + 数字1，2# 在不同window 之间移动</span><br><span class="hljs-string">pre + &amp;# 关闭当前 window</span><br><span class="hljs-string"># 重命名window，创建一个新的 window 之后，除了数字编号不同外，window 名称都是一样的</span><br><span class="hljs-string">pre + ,# 更改 window 名称</span><br><span class="hljs-string"></span><br><span class="hljs-string">### session</span><br><span class="hljs-string">tmux ls# 查看所有的 session(正常运行显示 attach)</span><br><span class="hljs-string">pre + $# 每个 session 一般对应于一个 project</span><br><span class="hljs-string">tmux new -s [名字]# 创建 session 时直接命名</span><br><span class="hljs-string">pre + d# 退出session（挂起）</span><br><span class="hljs-string">tmux a -t [名字]# 重新连接某个session</span><br><span class="hljs-string">tmux a# 仅有一个session 时这是最快的连接方式</span><br><span class="hljs-string">tmux kill-session -a -t [名字] # 删除[名字]以外的session</span><br></code></pre></div></td></tr></table></figure><p>从 <code>tmux</code> 中往外复制东西的方法：</p><p>先按住 <code>shift</code> 不放，用鼠标选中复制的内容，松开 <code>shift</code> ，再按 <code>ctrl+insert</code> 复制；然后在电脑上按 <code>shift+insert</code> 粘贴。 </p><p>常用的 <code>tmux</code> 配置，<code>vim ~/.tmux.conf</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Send prefix: ctr + b 改为 ctr + a</span><br>set-option -g prefix C-a<br>unbind-key C-a<br>bind-key C-a send-prefix<br><br><span class="hljs-comment"># Use Alt-arrow keys to switch panes</span><br><span class="hljs-comment"># 不用 prefix，直接 alt + 箭头在 pane 之间 switch</span><br><span class="hljs-built_in">bind</span> -n M-Left select-pane -L<br><span class="hljs-built_in">bind</span> -n M-Right select-pane -R<br><span class="hljs-built_in">bind</span> -n M-Up select-pane -U<br><span class="hljs-built_in">bind</span> -n M-Down select-pane -D<br><br><span class="hljs-comment"># Shift arrow to switch windows</span><br><span class="hljs-comment"># 不用按prefix，直接用shift+箭头在window之间switch</span><br><span class="hljs-built_in">bind</span> -n S-Left previous-window<br><span class="hljs-built_in">bind</span> -n S-Right next-window<br><br><span class="hljs-comment"># Mouse mode</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Set easier window split keys</span><br>bind-key v split-window -h<br>bind-key h split-window -v<br><br><span class="hljs-comment"># Easy config reload</span><br>bind-key r source-file ~/.tmux.conf \; display-message <span class="hljs-string">&quot;tmux.conf reloaded&quot;</span><br></code></pre></div></td></tr></table></figure><p>更改了 <code>.tmux.conf</code> 后，在 <code>tmux</code> 里的快捷键没有变化。<code>tmux</code> 只有在新建 <em>session</em> 的时候，才会去找 <code>tmux.conf</code> 文件。</p><p>所以，之前创建的 <em>session</em> 都没有参考 <code>tmux.conf</code>， 所以可以用<code>tmux lstmux kill-session -a</code> 仅仅保留当前 <em>session</em>。再删除当前 <code>session</code>  <code>tmux kill-session -t py27</code>。这下删除了所有创建好的 <em>session</em>。</p><blockquote><p><a href="https://www.jianshu.com/p/fd3bbdba9dc9">tmux简洁教程及config关键配置</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p><p><a href="http://cenalulu.github.io/linux/tmux/">http://cenalulu.github.io/linux/tmux/</a></p><p><a href="https://harttle.land/2015/11/06/tmux-startup.html">https://harttle.land/2015/11/06/tmux-startup.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Vim</category>
      
      <category>tmux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的基本使用</title>
    <link href="/2021/09/09/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/09/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Git ：开源的分布式版本控制系统，可以有效、高速地处理项目的版本管理。</p><div class="table-container"><table><thead><tr><th style="text-align:center">集中式版本控制</th><th style="text-align:center">分布式版本控制</th></tr></thead><tbody><tr><td style="text-align:center">仅中心服务器拥有一份代码</td><td style="text-align:center">每个人的电脑上都有一份代码</td></tr><tr><td style="text-align:center">需要联网才能工作</td><td style="text-align:center">不需要联网也能工作</td></tr><tr><td style="text-align:center">新建分支相当于复制一份完整代码</td><td style="text-align:center">新建/合并分支速度很快</td></tr></tbody></table></div><span id="more"></span><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/image-20211129194208864.png" width = 700px></div><center>git 工作流</center><p>新建一个仓库 <code>workspace</code> 之后，当前目录就成了一个工作区，工作区下有一个隐藏目录 <code>.git</code> ，其属于 <code>Git</code> 的版本库。</p><p>版本库有一个 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p><div align = center><img src = "https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208195941661.png" width = 550px></div><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>创建本地仓库的克隆版本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> /path/to/repository<br></code></pre></div></td></tr></table></figure><p>克隆远端服务器上的仓库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> username@host:/path/to/repository<br></code></pre></div></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。</p><p>第一个是你的 <code>工作目录</code>，它持有实际文件；</p><p>第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；</p><p>最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>提出更改（把它们添加到暂存区）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add &lt;filename&gt;<br>$ git add *<br></code></pre></div></td></tr></table></figure><p>实际提交改动：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;代码提交信息&quot;</span><br></code></pre></div></td></tr></table></figure><p>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。将这些改动提交到远端仓库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push origin master<br></code></pre></div></td></tr></table></figure><p>可以把 <em>master</em> 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git remote add origin &lt;server&gt;<br></code></pre></div></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/image-20211129213001037.png" width = 550px></div><br><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -b feature_x<span class="hljs-comment"># 创建一个叫做“feature_x”的分支，并切换过去</span><br>$ git checkout master<span class="hljs-comment"># 切换回主分支</span><br>$ git branch -d feature_x<span class="hljs-comment"># 把新建的分支删掉</span><br><span class="hljs-comment"># 除非你将分支推送到远端仓库，不然该分支就是仅自己可见的</span><br>$ git push origin &lt;branch&gt;<br></code></pre></div></td></tr></table></figure></p><h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git pull<span class="hljs-comment"># 更新本地仓库获取（fetch） 并 合并（merge） 远端的改动</span><br>$ git merge &lt;branch&gt;<span class="hljs-comment"># 要合并其他分支到你的当前分支（例如 master）</span><br><span class="hljs-comment"># 此时可能出现冲突（conflicts），需要手动合并这些冲突（conflicts）</span><br>$ git add &lt;filename&gt;<span class="hljs-comment"># 改动后，将它们标记为合并成功</span><br>$ git diff &lt;source_branch&gt; &lt;target_branch&gt;<span class="hljs-comment"># 合并改动前，预览差异</span><br></code></pre></div></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git tag 1.0.0 1b2e1d63ff<span class="hljs-comment"># 创建一个叫做 1.0.0 的标签</span><br><span class="hljs-comment"># 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符</span><br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 获取提交 ID</span><br></code></pre></div></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><span class="hljs-comment"># 了解本地仓库的历史记录</span><br>$ git <span class="hljs-built_in">log</span> --author=bob<span class="hljs-comment"># 只看某一个人的提交记录</span><br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<span class="hljs-comment"># 一个压缩后的每一条提交记录只占一行的输出</span><br>$ git <span class="hljs-built_in">log</span> --graph --oneline --decorate --all<span class="hljs-comment"># ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span><br>$ git <span class="hljs-built_in">log</span> --name-status<span class="hljs-comment"># 看看哪些文件改变了</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">help</span><br></code></pre></div></td></tr></table></figure><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -- &lt;filename&gt;<br></code></pre></div></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><hr><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git fetch origin<br>$ git reset --hard origin/master<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简明指南</a></p><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#git-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88">CSNotes-Git</a></p><p><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git(opens new window)</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 : Git 教程(opens new window)</a></p><p><a href="https://learngitbranching.js.org/">Learn Git Branching</a></p><p>Git 中文教程<a href="https://git-scm.com/book/zh/v2">文档地址</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2021/09/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/09/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本文将对 Linux 系统进行简要介绍，并总结概括 Linux 系统下常用命令。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><span id="more"></span><div class="table-container"><table><thead><tr><th></th><th>区别</th><th>联系</th></tr></thead><tbody><tr><td>Linux</td><td>开源；可移植性强；使用简单；个人或企业用户；</td><td>网络为核心的设计思想源于Unix</td></tr><tr><td>Unix</td><td>商业软件银行（IBM 的 AIX）；高端定制化应用；</td></tr></tbody></table></div><h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><p><strong>Linux 启动流程：</strong></p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211114165855.png" width = 700px></p><p><strong>内核引导</strong>：<code>BOIS</code> 自检并按照 <code>BIOS</code> 中设置的启动设备（硬盘）启动。</p><p><strong>运行</strong> <code>init</code> ：<code>init</code> 进程是系统所有进程的起点；</p><p><strong>运行级别</strong>：许多程序需要开机启动，Windows 系统中称为服务 <code>service</code>，Linux 系统中是守护进程 <code>daemon</code> 。<code>init</code> 进程任务之一就是去运行这些开机启动的程序。（Linux 系统服务器用作服务器时，需要启动 <code>Apache</code>）。运行级别就是针对不同场合设置不同的程序启动时机，Linux 系统中有 7 级。</p><p><strong>系统初始化</strong>：激活交换分区，检查磁盘，加载硬件模块等。</p><p><strong>用户登录系统</strong>：命令行、<code>ssh</code> 登录、图形界面；</p><p><strong>Linux 关机流程</strong>：</p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211114170537.png" width = 500px></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ man<span class="hljs-comment"># 查看帮助文档</span><br>$ sync<span class="hljs-comment"># 将数据由内存同步到硬盘中。</span><br>$ shutdown<span class="hljs-comment">#关机指令</span><br>$ reboot<span class="hljs-comment">#重启 == shutdown –r now和init 6</span><br>$ halt<span class="hljs-comment">#关闭系统 == shutdown –h now 和 poweroff和 init 0</span><br></code></pre></div></td></tr></table></figure><hr><figure class="highlight bash"><figcaption><span>/</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">├── bin -&gt; usr/bin<span class="hljs-comment"># 常用的程序和指令</span><br>├── boot<span class="hljs-comment"># 启动 Linux 的内核文件，包括连接文件和镜像文件</span><br>├── dev<span class="hljs-comment"># Linux 外部设备</span><br>├── etc<span class="hljs-comment"># 系统的配置文件和子目录列表。更改将可能导致系统不能启动</span><br>├── home<span class="hljs-comment"># 普通用户的主目录</span><br>├── lib -&gt; usr/lib<span class="hljs-comment"># lib 基本代码库（C++库），基本动态连接共享库</span><br>├── lib32 -&gt; usr/lib32<br>├── lib64 -&gt; usr/lib64<br>├── libx32 -&gt; usr/libx32<br>├── lost+found<span class="hljs-comment"># 一般情况下是空的，当系统非法关机后，这里会存放一些文件</span><br>├── media<span class="hljs-comment"># 类似 Windows 的其他设备</span><br>├── mnt<span class="hljs-comment"># 共享文件夹（实现Windows和Linux虚拟机文件共享）</span><br>├── opt<span class="hljs-comment"># 默认为空，我们安装额外软件可以放在这个里面</span><br>├── proc<span class="hljs-comment"># 管理内存空间</span><br>├── root<span class="hljs-comment"># 系统管理员用户主目录</span><br>├── run<span class="hljs-comment"># 临时文件系统，存放系统启动以来的信息</span><br>├── sbin -&gt; usr/sbin<span class="hljs-comment"># 系统管理员才能用的程序和指令</span><br>├── srv<span class="hljs-comment"># 存放服务启动后需要提取的数据</span><br>├── swapfile<br>├── sys<span class="hljs-comment"># 内核源代码默认的放置目录</span><br>├── tmp<span class="hljs-comment"># 存放临时文件</span><br>├── usr<span class="hljs-comment"># unix shared resources，存放很多应用软件和文件</span><br>└── var<span class="hljs-comment"># 不断更改的文件，各种日志文件</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>命令解析器</strong>：Linux 系统中提供了 <code>shell</code> （/bin/sh）、<code>bash</code>（/bin/bash）等，一般默认使用 <code>bash</code> 作为解析器。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tab<span class="hljs-comment"># 补齐命令，补齐路径，显示当前目录下的所有目录</span><br>$ clear<span class="hljs-comment"># 清屏</span><br>$ ctrl + l<span class="hljs-comment"># 清屏</span><br>$ ctrl + c<span class="hljs-comment"># 中断进程</span><br>$ ctrl + u<span class="hljs-comment"># 删除光标前所有内容</span><br>$ ctrl + k<span class="hljs-comment"># 删除光标后的所有内容</span><br></code></pre></div></td></tr></table></figure><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="ls-命令-–-显示指定目录下的内容及属性信息"><a href="#ls-命令-–-显示指定目录下的内容及属性信息" class="headerlink" title="ls 命令 – 显示指定目录下的内容及属性信息"></a>ls 命令 – 显示指定目录下的内容及属性信息</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ls [参数] 目录路径<br>$ ls -l<span class="hljs-comment"># 查看当前目录下的详细信息，功能等价于 ll 命令</span><br>$ ls -a<span class="hljs-comment"># 查看当前目录下的所有文件（包含隐藏文件）</span><br>$ ls -la <span class="hljs-comment"># 查看当前目录下的所有文件（包含隐藏文件）的详细信息</span><br>$ ls -lh<span class="hljs-comment"># 查看当前目录下的文件的详细信息（增加可读性，带单位）</span><br>$ ls --<span class="hljs-built_in">help</span><span class="hljs-comment"># 查看命令帮助文档</span><br></code></pre></div></td></tr></table></figure><h3 id="cd-命令-切换目录"><a href="#cd-命令-切换目录" class="headerlink" title="cd 命令 - 切换目录"></a>cd 命令 - 切换目录</h3><p>相对路径：不是以 <code>/</code> 开头的路径。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">.<span class="hljs-comment"># 表示当前目录</span><br>..<span class="hljs-comment"># 表示当前目录的上一级目录</span><br>~<span class="hljs-comment"># 表示当前用户的根目录，切记是当前用户</span><br><br>$ <span class="hljs-built_in">cd</span> ./bin<span class="hljs-comment"># 进入当前目录下的 bin 目录，功能等价于 cd bin/</span><br>$ <span class="hljs-built_in">cd</span> ../etc<span class="hljs-comment"># 进入和当前目录同级的 etc 目录</span><br></code></pre></div></td></tr></table></figure><h3 id="mkdir-命令-–-创建目录"><a href="#mkdir-命令-–-创建目录" class="headerlink" title="mkdir 命令 – 创建目录"></a>mkdir 命令 – 创建目录</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mkdir dir<span class="hljs-comment"># 在当前目录下创建一个 dir 目录，功能等价于 mkdir ./dir</span><br>$ mkdir/root/tmp<span class="hljs-comment"># 在 /root 目录下创建一个 tmp 目录</span><br>$ mkdir -p a/b/c<span class="hljs-comment"># 在当前目录下创建 3 级目录</span><br></code></pre></div></td></tr></table></figure><h3 id="rmdir-命令-–-删除空目录"><a href="#rmdir-命令-–-删除空目录" class="headerlink" title="rmdir 命令 – 删除空目录"></a>rmdir 命令 – 删除空目录</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rmdir [参数] 目录路径<span class="hljs-comment"># 默认仅删除空目录</span><br>$ rmdir./dir<span class="hljs-comment"># 删除当前目录下的 dir 目录</span><br>$ rmdir -p a/b/c<span class="hljs-comment"># 删除当前目录下的 a/b/c 目录</span><br></code></pre></div></td></tr></table></figure><h3 id="touch-命令-创建文件"><a href="#touch-命令-创建文件" class="headerlink" title="touch 命令 - 创建文件"></a>touch 命令 - 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ touch 1.txt<span class="hljs-comment"># 当前目录下创建一个 1.txt 文件</span><br>$ touch ~/1.txt<span class="hljs-comment"># 当前用户的根目录下创建一个 1.txt 文件</span><br></code></pre></div></td></tr></table></figure><h3 id="rm-命令-删除文件"><a href="#rm-命令-删除文件" class="headerlink" title="rm 命令 - 删除文件"></a>rm 命令 - 删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rm [参数] 路径<br>$ rm -r a<span class="hljs-comment"># 递归删除当前目录下 a 以及 a 目录 下的所有内容</span><br>$ rm -f 1.txt<span class="hljs-comment"># 强制删除该文件，不会提示</span><br>$ rm -rf a/<span class="hljs-comment"># 强制删除当前目录下的 a 目录以及 a 目录下的所有内容</span><br>$ rm -rf *<span class="hljs-comment"># 强制删除当前目录下的所有内容</span><br>$ rm -rf *.txt<span class="hljs-comment"># 强制删除当前目录下的所有 txt 文件</span><br>$ rm -rf *s*<span class="hljs-comment"># 删除当前目录下所有名字中包含 s 的文件或文件夹</span><br></code></pre></div></td></tr></table></figure><h3 id="pwd-命令-—-查看当前路径"><a href="#pwd-命令-—-查看当前路径" class="headerlink" title="pwd 命令 — 查看当前路径"></a>pwd 命令 — 查看当前路径</h3><p>Linux 下所有的绝对路径都是从根目录 <code>/</code> 开始，<code>/root</code> 是 root 用户的根目录，<code>/home</code> 是其他用户的默认根目录。</p><h3 id="cp-命令-–-拷贝文件"><a href="#cp-命令-–-拷贝文件" class="headerlink" title="cp 命令 – 拷贝文件"></a>cp 命令 – 拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cp 1.txt a/<span class="hljs-comment"># 将 1.txt 文件拷贝到 a 目录下</span><br>$ cp 1.txt 2.txt<span class="hljs-comment"># 将 1.txt 文件内容拷贝到 2.txt 文件中</span><br>$ cp -r a data<span class="hljs-comment"># 将 a 目录递归地拷贝 data 目录中</span><br></code></pre></div></td></tr></table></figure><h3 id="scp-命令-远程拷贝文件"><a href="#scp-命令-远程拷贝文件" class="headerlink" title="scp 命令 - 远程拷贝文件"></a>scp 命令 - 远程拷贝文件</h3><p>该命令可以将本地文件拷贝到远程服务器，也可以将远程服务器的文件拷贝到本地，也可将一台服务器文件拷贝到另一台服务器。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将本地文件拷贝到远程服务器</span><br>$ scp -r 本地文件路径 用户名@ip[:port]:远程路径<br><span class="hljs-comment"># 将本地的 2.txt 文件拷贝到 172.18.7.111 的 /root/data/ 目录下</span><br>$ scp -r 2.txt root@172.18.7.111:/root/data/<br><br><span class="hljs-comment"># 远程文件拷贝到本地</span><br>$ scp -r 用户名@ip[:port]:远程文件路径 本地路径<br><span class="hljs-comment"># 将远程的/root/2.txt 文件拷贝到本地的 /root/data 目录</span><br>$ scp -r root@172.18.7.111:/root/2.txt /root/data<br><br><span class="hljs-comment"># 服务器与服务器之间</span><br>$ scp -r 用户名@ip[:port]:远程文件路径 用户名@ip[:port]:远程文件路径<br><span class="hljs-comment"># 将 /root/tmp 拷贝到远程的 /root/data 目录下</span><br>scp -r root@192.168.5.105:/root/tmp root@192.168.5.105:/root/data/<br></code></pre></div></td></tr></table></figure><h3 id="mv命令-–-移动或改名文件"><a href="#mv命令-–-移动或改名文件" class="headerlink" title="mv命令 – 移动或改名文件"></a>mv命令 – 移动或改名文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mv 1.txt 2.txt<span class="hljs-comment"># 文件 1.txt 改名为 2.txt 文件</span><br>$ mv a b<span class="hljs-comment"># 目录 a 改名为 b</span><br>$ mv 1.txt b<span class="hljs-comment"># 文件 1.txt 移动到 b 目录下</span><br></code></pre></div></td></tr></table></figure><h3 id="tar-命令-文件打包以及解打包"><a href="#tar-命令-文件打包以及解打包" class="headerlink" title="tar 命令 - 文件打包以及解打包"></a>tar 命令 - 文件打包以及解打包</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar [选项] 打包文件名 文件<span class="hljs-comment"># 文件打包以及解打包</span><br>$ tar -cvf<span class="hljs-comment"># 创建归档文件</span><br>$ tar -xvf<span class="hljs-comment"># 解除归档文件</span><br>$ tar -tvf<span class="hljs-comment"># 查看归档文件内容</span><br><br>$ tar cvf 2.tar 2.txt<span class="hljs-comment"># 将 2.txt 压缩为 2.tar 包</span><br>$ tar cvf a.tar a<span class="hljs-comment"># 将 a 目录下打包到 a.tar 文件中</span><br><br>$ tar xvf 2.tar<span class="hljs-comment"># 将 2.tar 解压到当前目录</span><br>$ tar xvf 2.tar -C a/<span class="hljs-comment"># 将 2.tar 解压到 a 目录</span><br>$ tar xvf data.tar<span class="hljs-comment"># 解压 data.tar 到当前目录</span><br><br>$ tar zcvftm.tar.gz tm<span class="hljs-comment"># 将当前目录下的 tm 目录压缩为 tm.tar.gz</span><br>$ tar zxvf tm.tar.gz<span class="hljs-comment"># 将 tm.tar.gz 解压到当前目录</span><br></code></pre></div></td></tr></table></figure><h3 id="gzip-命令-文件压缩和解压缩"><a href="#gzip-命令-文件压缩和解压缩" class="headerlink" title="gzip 命令 - 文件压缩和解压缩"></a>gzip 命令 - 文件压缩和解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gzip [选项] 被压缩文件<span class="hljs-comment"># tar 和 gzip 命令结合使用实现文件打包、压缩</span><br><span class="hljs-comment">#-d解压</span><br><span class="hljs-comment">#-r压缩所有文件</span><br><br>$ gzip 2.txt<span class="hljs-comment"># 将 2.txt 压缩为 2.txt.gz</span><br>$ gzip data.tar <span class="hljs-comment"># 将 data.tar 压缩为 data.tar.gz</span><br></code></pre></div></td></tr></table></figure><h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><h3 id="echo-命令-–-输出字符串或提取-Shell-变量的值"><a href="#echo-命令-–-输出字符串或提取-Shell-变量的值" class="headerlink" title="echo 命令 – 输出字符串或提取 Shell 变量的值"></a>echo 命令 – 输出字符串或提取 Shell 变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello<span class="hljs-comment"># 打印 Hello</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-comment"># 打印环境变量 PATH 的值，$ 是取变量值的符号，用法：$变量名 或者 $&#123;变量名&#125;</span><br>$ <span class="hljs-built_in">echo</span> -n Hello<span class="hljs-comment"># 打印内容但不换行</span><br></code></pre></div></td></tr></table></figure><h3 id="gt-和-gt-gt-命令-输出符号"><a href="#gt-和-gt-gt-命令-输出符号" class="headerlink" title="&gt; 和 &gt;&gt; 命令 - 输出符号"></a>&gt; 和 &gt;&gt; 命令 - 输出符号</h3><p><code>&gt;</code> 表示覆盖（删除原文件的内容），<code>&gt;&gt;</code> 表示追加。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello &gt; 1.txt<span class="hljs-comment"># 将 Hello 输出到当前目录下的 1.txt 文件</span><br><span class="hljs-comment"># 如果当前目录下没有 1.txt 文件，就会创建一个新文件</span><br><span class="hljs-comment"># 如果当前目录下有 1.txt 文件，就会删除原文件的内容</span><br>$ <span class="hljs-built_in">echo</span> 123 &gt;&gt; 1.txt<span class="hljs-comment"># 将 123 追加到当前目录下的 1.txt 文件中，如果不存在该文件需要创建一个新的文件</span><br></code></pre></div></td></tr></table></figure><h3 id="cat命令-–-在终端上显示文件内容"><a href="#cat命令-–-在终端上显示文件内容" class="headerlink" title="cat命令 – 在终端上显示文件内容"></a>cat命令 – 在终端上显示文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cat 1.txt<span class="hljs-comment"># 查看当前目录下 1.txt 文件中的内容</span><br></code></pre></div></td></tr></table></figure><h3 id="more-less-命令-分页查看文件内容"><a href="#more-less-命令-分页查看文件内容" class="headerlink" title="more, less 命令 - 分页查看文件内容"></a>more, less 命令 - 分页查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ more 文件所在路径<span class="hljs-comment"># 按空格或回车会继续加载文件内容，按 q 退出查看，加载到文件末尾时会自动退出</span><br><br>$ less 文件所在路径<span class="hljs-comment"># 按空格继续加载文件，按 q 退出查看，不会自动退出查看</span><br></code></pre></div></td></tr></table></figure><h3 id="head-tail-命令-从头，从尾查看文件内容"><a href="#head-tail-命令-从头，从尾查看文件内容" class="headerlink" title="head, tail 命令 - 从头，从尾查看文件内容"></a>head, tail 命令 - 从头，从尾查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ head -n 文件路径<span class="hljs-comment"># 查看文件的前 n 行数据</span><br>$ tail -n 文件路径<span class="hljs-comment"># 查看文件的后 n 行数据</span><br>$ tail -f 文件路径<span class="hljs-comment"># 动态的查看文件的最后几行内容</span><br></code></pre></div></td></tr></table></figure><p>注意：<code>tail -f</code> 一般用来查看日志文件，按下 <code>ctrl + c</code> （暂停进程）或者 <code>ctrl + z</code> （停止进程）才会退出查看。</p><h3 id="wc-命令-查看文件的单词个数"><a href="#wc-命令-查看文件的单词个数" class="headerlink" title="wc 命令 - 查看文件的单词个数"></a>wc 命令 - 查看文件的单词个数</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ wc -l 1.txt<span class="hljs-comment"># -l 表示 line 行数，统计文件 1.txt 的行数</span><br>$ wc -w 1.txt<span class="hljs-comment"># -w 表示 word 单词个数，统计文件 1.txt 的单词个数</span><br></code></pre></div></td></tr></table></figure><h3 id="find-命令-特定目录下查找文件"><a href="#find-命令-特定目录下查找文件" class="headerlink" title="find 命令 - 特定目录下查找文件"></a>find 命令 - 特定目录下查找文件</h3><p>使用参数 <code>-name</code> 按文件名查询，使用参数 <code>-size</code> 按照文件大小查询，使用参数 <code>-type</code> 按照文件类型查询。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ find 路径 -name <span class="hljs-string">&quot;文件名&quot;</span><br>$ find /home -name <span class="hljs-string">&quot;a.txt&quot;</span><br>$ find *.txt<span class="hljs-comment"># 查找 txt 文件</span><br><br>$ find 路径 -size 范围<br><span class="hljs-comment"># +100k# 大小大于 100k</span><br><span class="hljs-comment"># -100k# 大小小于 100k</span><br><br>$ find 路径 -<span class="hljs-built_in">type</span> 类型<br><span class="hljs-comment"># d 目录, l 符号链接, b 块设备文件, c 字符设备文件, s socket 文件, p 管道</span><br></code></pre></div></td></tr></table></figure><h3 id="grep-命令-查找内容"><a href="#grep-命令-查找内容" class="headerlink" title="grep 命令 - 查找内容"></a>grep 命令 - 查找内容</h3><p>:star: <code>grep</code> 对文本文件进行模式匹配，如果找到匹配模式，<code>grep</code> 打印包含模式的所有行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ grep [-选项] <span class="hljs-string">&#x27;搜索内容串&#x27;</span> 文件名<br><span class="hljs-comment"># -v 显示不包含匹配文本的所有行</span><br><span class="hljs-comment"># -n 显示匹配行以及行号</span><br><span class="hljs-comment"># -i 忽略大小写</span><br><br>grep cat 1.txt<span class="hljs-comment"># 在 1.txt 文件中查找包含 cat 的行</span><br><br>| 管道符号<span class="hljs-comment"># 连接两个命令，将前一个命令的查询结果传给后一个命令</span><br>$ ps -ef | grep sshd<span class="hljs-comment"># 查看系统中 sshd 的进程</span><br><br>$ grep -v cat 1.txt<span class="hljs-comment"># 查找 1.txt 文件中不包含 1.txt 的行</span><br>$ ps -ef | grep sshd | grep -v grep<span class="hljs-comment"># 查询 sshd 进程，不包含 grep 的行</span><br></code></pre></div></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="free-命令-查看系统内存"><a href="#free-命令-查看系统内存" class="headerlink" title="free 命令 - 查看系统内存"></a>free 命令 - 查看系统内存</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ free<span class="hljs-comment"># 查看系统内存的使用情况</span><br>$ free -h<span class="hljs-comment"># 查看内存使用情况，以合适度量单位进行显示</span><br></code></pre></div></td></tr></table></figure><h3 id="df-命令-列出文件系统的整体磁盘使用量"><a href="#df-命令-列出文件系统的整体磁盘使用量" class="headerlink" title="df 命令 - 列出文件系统的整体磁盘使用量"></a>df 命令 - 列出文件系统的整体磁盘使用量</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ df<span class="hljs-comment"># 查看系统磁盘的使用情况</span><br>$ df -h<span class="hljs-comment"># 查看系统硬盘使用，以合适度量单位进行显示</span><br></code></pre></div></td></tr></table></figure><h3 id="du-命令-检查磁盘空间使用量"><a href="#du-命令-检查磁盘空间使用量" class="headerlink" title="du 命令 - 检查磁盘空间使用量"></a>du 命令 - 检查磁盘空间使用量</h3><h3 id="ps-命令-查看系统进程的命令"><a href="#ps-命令-查看系统进程的命令" class="headerlink" title="ps 命令 - 查看系统进程的命令"></a>ps 命令 - 查看系统进程的命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ps -aux<br>$ ps -ef<br></code></pre></div></td></tr></table></figure><h3 id="kill-命令-结束进程"><a href="#kill-命令-结束进程" class="headerlink" title="kill 命令 - 结束进程"></a>kill 命令 - 结束进程</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 88742<span class="hljs-comment"># 结束 PID 为 88742 的进程</span><br><span class="hljs-built_in">kill</span> -9 PID_id<span class="hljs-comment"># 强制结束进程</span><br></code></pre></div></td></tr></table></figure><h2 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h2><h3 id="groupadd-groupdel-命令-创建-删除一个用户组"><a href="#groupadd-groupdel-命令-创建-删除一个用户组" class="headerlink" title="groupadd / groupdel 命令 - 创建/删除一个用户组"></a>groupadd / groupdel 命令 - 创建/删除一个用户组</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ groupadd bows<span class="hljs-comment"># 创建一个叫 bows 的用户组</span><br>$ groupdel bows<span class="hljs-comment"># 当 bows 用户组下没有用户时，删除 bows 用户组</span><br></code></pre></div></td></tr></table></figure><h3 id="useradd-userdel-命令-创建-删除用户，用户管理"><a href="#useradd-userdel-命令-创建-删除用户，用户管理" class="headerlink" title="useradd / userdel 命令 - 创建/删除用户，用户管理"></a>useradd / userdel 命令 - 创建/删除用户，用户管理</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个用户，-g 指定用户的主用户组，-G 指定用户的其他用户组</span><br>$ useradd username [-g 用户组名 -G 用户组名]<br>$ id username<span class="hljs-comment"># 查看用户的 id</span><br><br>$ userdel username<span class="hljs-comment"># 删除用户</span><br><br>$ su username<span class="hljs-comment"># 切换用户，但不加载用户的环境变量</span><br>$ su - username<span class="hljs-comment"># 切换用户，并加载用户的环境变量（建议方式）</span><br><span class="hljs-comment"># 加载用户根目录下的 .bash_profile 环境变量配置文件</span><br><br>$ <span class="hljs-built_in">exit</span><span class="hljs-comment"># 退出当前用户的登录</span><br><br>$ passwd username<span class="hljs-comment"># 修改用户密码</span><br><br>$ r: 读权限，对应数字表示 4<br>$ w: 写权限，对应数字表示 2<br>$ x: 可执行权限，对应数字表示 1<br>$ +: 加上权限，-: 去掉权限<br><br><span class="hljs-comment"># Linux 常用两个命令来修改文件或目录的所属用户和权限</span><br>$ chmod 权限 文件路径<br>$ chmod u+x2.txt/Bob<span class="hljs-comment"># 给文件/用户加上执行权限</span><br></code></pre></div></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="source-命令-让配置文件修改结果立即生效"><a href="#source-命令-让配置文件修改结果立即生效" class="headerlink" title="source 命令 - 让配置文件修改结果立即生效"></a>source 命令 - 让配置文件修改结果立即生效</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> /etc/profile<span class="hljs-comment"># 让配置文件 /etc/profile 生效</span><br></code></pre></div></td></tr></table></figure><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> 导入全局变量（环境变量）<br></code></pre></div></td></tr></table></figure><h3 id="lt-lt-EOF-将-lt-lt-EOF-和-EOF-之间的多行内容传给前面的命令"><a href="#lt-lt-EOF-将-lt-lt-EOF-和-EOF-之间的多行内容传给前面的命令" class="headerlink" title="&lt;&lt; EOF - 将 &lt;&lt; EOF 和 EOF 之间的多行内容传给前面的命令"></a>&lt;&lt; EOF - 将 &lt;&lt; EOF 和 EOF 之间的多行内容传给前面的命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">jnpeng@aliyun:~$ cat &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&gt; A</span><br><span class="hljs-string">&gt; B</span><br><span class="hljs-string">&gt; C</span><br><span class="hljs-string">&gt; EOF</span><br>A<br>B<br>C<br></code></pre></div></td></tr></table></figure><h3 id="cut-命令-截取命令"><a href="#cut-命令-截取命令" class="headerlink" title="cut 命令 - 截取命令"></a>cut 命令 - 截取命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">-f 参数，指定列<br>-d 参数，参数指定列和列之间的分隔符，默认的分隔符是 \t （行向制表符）<br>cut -f 1 1.txt<span class="hljs-comment"># 取 1.txt 文件中的第 1 列内容（列分隔符默认为\t）</span><br>cut -f 1 -d <span class="hljs-string">&#x27;,&#x27;</span> 2.txt<span class="hljs-comment"># 取 2.txt 文件中的第 1 列内容，列分隔符为，</span><br></code></pre></div></td></tr></table></figure><h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ %ns<span class="hljs-comment"># 输出字符串，n 是数字，指代输出几个字符</span><br>$ %ni<span class="hljs-comment"># 输出整数，n 是数字，指代输出几个数字</span><br>$ %m.nf<span class="hljs-comment"># 位数和小数位数。例如：%8.2f 代表输出 8 位数，其中2位是小数，6位是整数</span><br></code></pre></div></td></tr></table></figure><h3 id="service-命令"><a href="#service-命令" class="headerlink" title="service 命令"></a>service 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">enable</span> | <span class="hljs-built_in">disable</span> | start | stop | restart | status<br>start: 启动服务<br>stop: 关闭服务<br>restart: 重启服务<br>status: 查看服务状态<br></code></pre></div></td></tr></table></figure><h3 id="tree-树形显示指定目录内容"><a href="#tree-树形显示指定目录内容" class="headerlink" title="tree - 树形显示指定目录内容"></a>tree - 树形显示指定目录内容</h3><h3 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install &lt;package_name&gt;<span class="hljs-comment"># 安装指定的软件</span><br>$ sudo apt update &lt;package_name&gt;<span class="hljs-comment"># 更新指定的软件</span><br>$ sudo apt update<span class="hljs-comment"># 列出所有可以更新的软件清单命令</span><br>$ sudo apt show &lt;package_name&gt;<span class="hljs-comment"># 显示软件包具体信息</span><br>$ sudo apt remove &lt;package_name&gt;<span class="hljs-comment"># 删除软件包命令</span><br>$ sudo apt upgrade<span class="hljs-comment"># 升级软件包</span><br>$ apt list --upgradeable<span class="hljs-comment"># 列出可更新的软件包及版本信息</span><br></code></pre></div></td></tr></table></figure><h3 id="Linux-文件链接"><a href="#Linux-文件链接" class="headerlink" title="Linux 文件链接"></a>Linux 文件链接</h3><p>Linux 文件链接分为两种：硬链接（Hard Link），符号链接（Symbolic Link）。</p><p><strong>硬链接</strong>：通过索引节点进行链接。Linux 文件系统中每个文件分配了一个索引节点号，Linux 中多个文件名指向同一个索引节点。一个索引节点对应两个不同的文件名，两个文件名指向同一个文件，删除其中一个不会影响另外一个的访问。</p><p><strong>软链接</strong>：类似快捷方式，假设 B 是 A 的软链接，B 的目录项中的 inode 节点号与 A 中的目录项中的 inode 节点号不同，B 和 A 指向的是两个不同的 inode ，继而指向两块不同的数据块。但是 B 的数据块中存放的是 A 的路径名，A 和 B 之间是主从关系，如果 B 删除了，A 仍然存在，但指向一个无效的链接。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> touch f1<span class="hljs-comment">#创建一个测试文件 f1</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln f1 f2<span class="hljs-comment">#创建f1的一个硬连接文件f2</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln -s f1 f3<span class="hljs-comment">#创建f1的一个符号连接文件f3</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -li<span class="hljs-comment"># -i 参数显示文件的inode节点信息</span></span><br></code></pre></div></td></tr></table></figure><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E5%9F%BA%E7%A1%804.png" width = "500px"/></div><p>测试结果：删除原始文件 <code>f1</code> 之后，硬连接 <code>f2</code> 不受影响，但是符号连接 <code>f3</code> 文件失效。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://linux.cn/article-3159-1.html">详解Linux与Unix系统的区别与联系</a></p><p>华为云开发者社区：<a href="https://blog.csdn.net/devcloud/article/details/112648614?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163680083016780357265345%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163680083016780357265345&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-19-112648614.pc_v2_rank_blog_default&amp;utm_term=Linux&amp;spm=1018.2226.3001.4450">Linux 命令大全</a></p><p><a href="https://www.linuxcool.com/">Linux 命令大全</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_7设计模式</title>
    <link href="/2021/09/07/C++%E9%9D%A2%E8%AF%95_7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/07/C++%E9%9D%A2%E8%AF%95_7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式，工厂模式，观察者模式。</p><span id="more"></span><h3 id="1-了解哪些设计模式？-star-4"><a href="#1-了解哪些设计模式？-star-4" class="headerlink" title="1 了解哪些设计模式？:star:4"></a>1 了解哪些设计模式？:star:4</h3><p><strong>设计模式 6 大设计原则</strong>：</p><ul><li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。</li><li>开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li><li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li><li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。</li><li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li><li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li></ul><p><strong>设计模式分为三类</strong>：</p><ul><li>创造型模式：单例模式、工厂模式、建造者模式、原型模式</li><li>结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式</li><li>行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</li></ul><p><strong>下面介绍常见的几种设计模式</strong>：</p><ul><li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式<ul><li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li><li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li><li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li></ul></li><li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。</li><li>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成派生类更为灵活。</li></ul><h3 id="2-什么是单例模式？如何实现？应用场景？-star-5"><a href="#2-什么是单例模式？如何实现？应用场景？-star-5" class="headerlink" title="2 什么是单例模式？如何实现？应用场景？:star:5"></a>2 什么是单例模式？如何实现？应用场景？:star:5</h3><p><strong>单例模式</strong>：保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。</p><p><strong>应用场景</strong>：</p><ul><li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li><li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li></ul><p><strong>实现方式</strong>：</p><p>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响<u>封装性</u>，难以保证别的代码不会对全局变量造成影响。</p><ul><li><strong>默认的构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>赋值构造函数声明为私有的</strong>，这样禁止在类的外部创建该对象；</li><li>全局访问点也要定义成 <strong>静态类型的成员函数</strong>，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li></ul><p>不安全的实现方式：<br>原因：考虑当两个线程同时调用 <code>getInstance</code> 方法，并且同时检测到 <code>instance</code> 是 <code>NULL</code>，两个线程会同时实例化对象，不符合单例模式的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Singleton * instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">NULL</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure><p><strong>分类</strong>：</p><ul><li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li><li>饿汉模式：类定义的时候就实例化。</li></ul><p><strong>线程安全的懒汉模式实现：</strong></p><p><strong>方法1：加锁</strong>。存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-keyword">static</span> Singleton * instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>); <br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">NULL</span>)&#123;            <br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();            <br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">pthread_mutex_t</span> Singleton::mutex;<br></code></pre></div></td></tr></table></figure><p><strong>方法2：内部静态变量</strong>。在全局访问点 <code>getInstance</code> 中定义静态实例。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-keyword">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> &amp;instance;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">pthread_mutex_t</span> Singleton::mutex; <br></code></pre></div></td></tr></table></figure><p>饿汉模式的实现：饿汉模式本身就是线程安全的不用加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br> <span class="hljs-built_in">Singleton</span>()&#123;&#125; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-keyword">return</span> instance;    <br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br></code></pre></div></td></tr></table></figure><h3 id="3-什么是工厂模式？如何实现？应用场景？-star-3"><a href="#3-什么是工厂模式？如何实现？应用场景？-star-3" class="headerlink" title="3 什么是工厂模式？如何实现？应用场景？:star:3"></a>3 什么是工厂模式？如何实现？应用场景？:star:3</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/83535678">C++ 深入浅出工厂模式（初识篇）</a></p></blockquote><h3 id="4-什么是观察者模式？如何实现？应用场景？-star-3"><a href="#4-什么是观察者模式？如何实现？应用场景？-star-3" class="headerlink" title="4 什么是观察者模式？如何实现？应用场景？:star:3"></a>4 什么是观察者模式？如何实现？应用场景？:star:3</h3><p><strong>观察者模式</strong>：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p><p><strong>观察者模式中存在两种角色</strong>：</p><ul><li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li><li>被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li></ul><p><strong>应用场景</strong>：</p><ul><li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li><li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>;</span><br><span class="hljs-comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    string name;<br>    Subject *sub;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Observer</span>(string name, Subject *sub)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = name;<br>        <span class="hljs-keyword">this</span>-&gt;sub = sub;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockObserver</span> :</span> <span class="hljs-keyword">public</span> Observer<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StockObserver</span>(string name, Subject *sub) : <span class="hljs-built_in">Observer</span>(name, sub)<br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBAObserver</span> :</span> <span class="hljs-keyword">public</span> Observer<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NBAObserver</span>(string name, Subject *sub) : <span class="hljs-built_in">Observer</span>(name, sub)<br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-comment">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    list&lt;Observer *&gt; observers;<br><br><span class="hljs-keyword">public</span>:<br>    string action; <span class="hljs-comment">//被观察者对象的状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer *)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer *)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Secretary</span> :</span> <span class="hljs-keyword">public</span> Subject<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer *observer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        observers.<span class="hljs-built_in">push_back</span>(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer *observer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        list&lt;Observer *&gt;::iterator iter = observers.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (iter != observers.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((*iter) == observer)<br>            &#123;<br>                observers.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            ++iter;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        list&lt;Observer *&gt;::iterator iter = observers.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (iter != observers.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            (*iter)-&gt;<span class="hljs-built_in">update</span>();<br>            ++iter;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StockObserver::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (sub-&gt;action == <span class="hljs-string">&quot;梁所长来了!&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NBAObserver::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (sub-&gt;action == <span class="hljs-string">&quot;梁所长来了!&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Subject *dwq = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Secretary</span>();<br>    Observer *xs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NBAObserver</span>(<span class="hljs-string">&quot;xiaoshuai&quot;</span>, dwq);<br>    Observer *zy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NBAObserver</span>(<span class="hljs-string">&quot;zouyue&quot;</span>, dwq);<br>    Observer *lm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StockObserver</span>(<span class="hljs-string">&quot;limin&quot;</span>, dwq);<br><br>    dwq-&gt;<span class="hljs-built_in">attach</span>(xs);<br>    dwq-&gt;<span class="hljs-built_in">attach</span>(zy);<br>    dwq-&gt;<span class="hljs-built_in">attach</span>(lm);<br><br>    dwq-&gt;action = <span class="hljs-string">&quot;去吃饭了！&quot;</span>;<br>    dwq-&gt;<span class="hljs-built_in">notify</span>();<br>    cout &lt;&lt; endl;<br>    dwq-&gt;action = <span class="hljs-string">&quot;梁所长来了!&quot;</span>;<br>    dwq-&gt;<span class="hljs-built_in">notify</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_6语言特性相关</title>
    <link href="/2021/09/06/C++%E9%9D%A2%E8%AF%95_6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/06/C++%E9%9D%A2%E8%AF%95_6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>指针，参数，模板。</p><span id="more"></span><h3 id="1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？-star-4"><a href="#1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？-star-4" class="headerlink" title="1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？:star:4"></a>1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？:star:4</h3><blockquote><p><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a><br><a href="https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/">https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/</a></p></blockquote><h3 id="2-std-move-函数的实现原理-star-3"><a href="#2-std-move-函数的实现原理-star-3" class="headerlink" title="2 std::move() 函数的实现原理 :star:3"></a>2 std::move() 函数的实现原理 :star:3</h3><p><code>std::move()</code> 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：引用折叠原理</p><ul><li>右值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是右值，即 <code>T&amp;&amp; &amp;&amp;</code> 相当于 <code>T&amp;&amp;</code>。</li><li>左值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是左值，即 <code>T&amp;&amp; &amp;</code> 相当于 <code>T&amp;</code>。</li></ul><p>小结：通过引用折叠原理可以知道，<code>move()</code> 函数的形参既可以是左值也可以是右值。</p><p><code>remove_reference</code> 具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//原始的，最通用的版本</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> T type;  <span class="hljs-comment">//定义 T 的类型别名为 type</span><br>&#125;;<br> <br><span class="hljs-comment">//部分版本特例化，将用于左值引用和右值引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&gt; <span class="hljs-comment">//左值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&amp;&gt; <span class="hljs-comment">//右值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;   <br>  <br><span class="hljs-comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span><br><span class="hljs-keyword">int</span> i;<br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::type a;             <span class="hljs-comment">//使用原版本，</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(i)&gt;::type  b;             <span class="hljs-comment">//左值引用特例版本</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">move</span>(i))&gt;::type  b;  <span class="hljs-comment">//右值引用特例版本 </span><br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> var = <span class="hljs-number">10</span>; <br><br>转化过程：<br><span class="hljs-number">1.</span> std::<span class="hljs-built_in">move</span>(var) =&gt; std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp;&amp; &amp;) =&gt; 折叠后 std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp;)<br><br><span class="hljs-number">2.</span> 此时：T 的类型为 <span class="hljs-keyword">int</span>&amp;，<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type 为 <span class="hljs-keyword">int</span>，这里使用 remove_reference 的左值引用的特例化版本<br><br><span class="hljs-number">3.</span> 通过 <span class="hljs-keyword">static_cast</span> 将 <span class="hljs-keyword">int</span>&amp; 强制转换为 <span class="hljs-keyword">int</span>&amp;&amp;<br><br>整个std::move被实例化如下<br>string&amp;&amp; <span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp; t) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结：<br><code>std::move()</code> 实现原理：</p><ol><li>利用引用折叠原理将右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li><li>然后通过 <code>remove_refrence</code> 移除引用，得到具体的类型 <code>T</code>；</li><li>最后通过 <code>static_cast&lt;&gt;</code> 进行强制类型转换，返回 <code>T&amp;&amp;</code> 右值引用。</li></ol><h3 id="3-什么是指针？指针的大小及用法？-star-2"><a href="#3-什么是指针？指针的大小及用法？-star-2" class="headerlink" title="3 什么是指针？指针的大小及用法？:star:2"></a>3 什么是指针？指针的大小及用法？:star:2</h3><p><strong>指针：</strong> 指向另外一种类型的复合类型。</p><p><strong>指针的大小：</strong> 在 64 位计算机中，指针占 8 个字节空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br><br>    <span class="hljs-keyword">char</span> *p1 = <span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p1) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>指针的用法：</strong></p><ol><li><p>指向普通对象的指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向常量对象的指针：常量指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p = &amp;c_var;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向函数的指针：函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun_p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<br>    fun_p = add;<br>    cout &lt;&lt; <span class="hljs-built_in">fun_p</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。特别注意：定义指向成员函数的指针时，要标明指针所属的类。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2; <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> var1 + var2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex;<br>    ex.var1 = <span class="hljs-number">3</span>;<br>    ex.var2 = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;ex.var1; <span class="hljs-comment">// 指向对象成员变量的指针</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (A::*fun_p)();<br>    fun_p = A::add; <span class="hljs-comment">// 指向对象成员函数的指针 fun_p</span><br>    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>this 指针：指向类的当前对象的指针常量。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_name</span><span class="hljs-params">(string tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_age</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_sex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;sex = tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sex: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;sex &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    p-&gt;<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    p-&gt;<span class="hljs-built_in">set_age</span>(<span class="hljs-number">16</span>);<br>    p-&gt;<span class="hljs-built_in">set_sex</span>(<span class="hljs-number">1</span>);<br>    p-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="4-什么是野指针和悬空指针？-star-3"><a href="#4-什么是野指针和悬空指针？-star-3" class="headerlink" title="4 什么是野指针和悬空指针？:star:3"></a>4 什么是野指针和悬空指针？:star:3</h3><p>悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> *p = <span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-built_in">free</span>(p); <span class="hljs-comment">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span><br></code></pre></div></td></tr></table></figure><p>野指针：不确定其指向的指针，未初始化的指针为“野指针”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> *p; <span class="hljs-comment">// 此时 p 是“野指针”。</span><br></code></pre></div></td></tr></table></figure><h3 id="5-C-11-nullptr-比-NULL-优势-star-1"><a href="#5-C-11-nullptr-比-NULL-优势-star-1" class="headerlink" title="5 C++ 11 nullptr 比 NULL 优势 :star:1"></a>5 C++ 11 nullptr 比 NULL 优势 :star:1</h3><ul><li><code>NULL</code>：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 <code>#define NULL 0</code>。</li><li><code>nullptr</code>：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他指针类型。</li></ul><p><code>nullptr</code> 的优势：</p><ol><li>有类型，类型是 <code>typdef decltype(nullptr) nullptr_t;</code>，使用 <code>nullptr</code> 提高代码的健壮性。</li><li>函数重载：因为 <code>NULL</code> 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 <code>NULL</code>，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 <code>nullptr</code> 就不会出现这种情况。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *p)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;fun(char const *p)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;fun(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// fun(char const *p)</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    fun(NULL); // error: call of overloaded &#x27;fun(NULL)&#x27; is ambiguous</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-指针和引用的区别？-star-4"><a href="#6-指针和引用的区别？-star-4" class="headerlink" title="6 指针和引用的区别？:star:4"></a>6 指针和引用的区别？:star:4</h3><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</li><li>指针可以为空，但是引用必须绑定对象。（是否可为空）</li><li>指针可以有多级，但是引用只能一级。（是否能为多级）</li></ul><p>C+11 Standard: § 8.3.2.4</p><blockquote><p>It is unspecified whether or not a reference requires storage (3.7).</p></blockquote><p><strong>引用是否占内存，取决于编译器的实现。</strong></p><ul><li>如果编译器用指针实现引用，那么它占内存。</li><li>如果编译器直接将引用替换为其所指的对象，则其不占内存（毕竟，替换掉之后，该引用实际就不存在了）。</li></ul><p>顺便一提，你无法用 sizeof 得到引用的大小，sizeof 作用于引用时，你得到的是它对应的对象的大小。</p><h3 id="7-常量指针和指针常量的区别-star-4"><a href="#7-常量指针和指针常量的区别-star-4" class="headerlink" title="7 常量指针和指针常量的区别 :star:4"></a>7 常量指针和指针常量的区别 :star:4</h3><p><strong>常量指针</strong>：常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>特点：<code>const</code> 的位置在指针声明运算符 <code>*</code> 的左侧。只要 <code>const</code> 位于 <code>*</code> 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，<code>*</code> 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> * p;<br></code></pre></div></td></tr></table></figure><p>注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;c_var; <br>    *p = <span class="hljs-number">6</span>;            <span class="hljs-comment">// error: assignment of read-only location &#x27;* p&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var1 = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var2 = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;c_var1; <br>    p = &amp;c_var2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>指针常量</strong>：指针常量的本质上是个常量，只不过这个常量的值是一个指针。</p><p>特点：<code>const</code> 位于指针声明操作符右侧，表明该对象本身是一个常量，<code>*</code> 左侧表示该指针指向的类型，即以 <code>*</code> 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> var;<br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var; <br></code></pre></div></td></tr></table></figure><p>注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var, var1;<br>    <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var;<br>    c_p = &amp;var1; <span class="hljs-comment">// error: assignment of read-only variable &#x27;c_p&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意 2：指针的内容可以改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var;<br>    *c_p = <span class="hljs-number">12</span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>常量指针（const int * p）</strong>：指向常量（const int）的指针，可以切换到指向别的常量（const int）；<br><strong>指针常量（int * const p）</strong>：指针的指向不可修改。<br><strong>指向常量的指针常量（const int * const p）</strong>: p的指向不可修改，p所指的内存区域中的值也不可修改（是常量）。</p><p><strong>从右往左读，遇到 <code>p</code> 就替换成  <code>p is a</code> ，遇到 <code>*</code> 就替换成 <code>point to</code>。</strong></p><p>①const int p;</p><p>p is a int const.    ——&gt; p 是一个整型常量。</p><p>②const int* p;</p><p>p is a point to int const.        ——-&gt; p 是一个指向整型常量的指针。</p><p>③int const* p;</p><p>p is a point to const int.        ——-&gt; 同上</p><p>④int * const p;</p><p>p is a const point to int.        ——-&gt;    p 是一个常量指针，指向整型。</p><p>⑤const int * const p;</p><p>p is a const point to int const.        ——-&gt; p 是常量指针，指向整型常量。</p><p>⑥int const * const p;</p><p>p is a const point to const int.        ———&gt; p 是常量指针，指向整型常量。</p><blockquote><p>记忆方法源自《c primer plus》</p></blockquote><h3 id="8-函数指针和指针函数的区别-star-4"><a href="#8-函数指针和指针函数的区别-star-4" class="headerlink" title="8 函数指针和指针函数的区别 :star:4"></a>8 函数指针和指针函数的区别 :star:4</h3><p><strong>指针函数：</strong>指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是<u>返回值是指针</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type</span> &#123;</span><br>  <span class="hljs-keyword">int</span> var1;<br>  <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><span class="hljs-function">Type * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>    Type * t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Type</span>();<br>    t-&gt;var1 = tmp1;<br>    t-&gt;var2 = tmp2;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Type *p = <span class="hljs-built_in">fun</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>函数指针：</strong>函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即<u>指向函数的指针</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> tmp1 * tmp2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> tmp1 / tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun)(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <br>  fun = fun1;<br>  cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <br>  fun = fun2;<br>  cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">75</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>函数指针和指针函数的区别</strong>：</p><ul><li>本质不同<ul><li>指针函数本质是一个函数，其返回值为指针。</li><li>函数指针本质是一个指针变量，其指向一个函数。</li></ul></li><li>定义形式不同<ul><li>指针函数：<code>int* fun(int tmp1, int tmp2);</code>，这里 <code>*</code> 表示函数的返回值类型是指针类型。</li><li>函数指针：<code>int (*fun)(int tmp1, int tmp2);</code>，这里* 表示变量本身是指针类型。</li></ul></li><li>用法不同</li></ul><h3 id="9-强制类型转换有哪几种？-star-4"><a href="#9-强制类型转换有哪几种？-star-4" class="headerlink" title="9 强制类型转换有哪几种？:star:4"></a>9 强制类型转换有哪几种？:star:4</h3><ul><li><p><code>static_cast</code>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p><ol><li>用于基本数据类型的转换。</li><li>用于类层次之间的基类和派生类之间 <strong>指针或者引用</strong> 的转换（<strong>不要求必须包含虚函数，但必须是有相互联系的类</strong>），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 <code>dynamic_cast</code> 进行下行转换。</li><li>可以将空指针转化成目标类型的空指针。</li><li>可以将任何类型的表达式转化成 <code>void</code> 类型。</li></ol></li><li><p><code>const_cast</code>：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p></li><li><p><code>reinterpret_cast</code>：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</p></li><li><p><code>dynamic_cast</code>：</p><ol><li><p>其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。</p></li><li><p>只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 <code>NULL</code>；不能用于基本数据类型的转换。</p></li><li><p>在向上进行转换时，即派生类类的指针转换成基类类的指针和 <code>static_cast</code> 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span> &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Derive *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br><br>    <span class="hljs-comment">//向上类型转换</span><br>    p1 = <span class="hljs-keyword">dynamic_cast</span>&lt;Base *&gt;(p2);<br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//输出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>    Derive *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br><br>    <span class="hljs-comment">//转换成功</span><br>    p3 = <span class="hljs-keyword">dynamic_cast</span>&lt;Derive *&gt;(p1);<br>    <span class="hljs-keyword">if</span> (p3 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    &#125;<br><br>    <span class="hljs-comment">//转换失败</span><br>    p3 = <span class="hljs-keyword">dynamic_cast</span>&lt;Derive *&gt;(p2);<br>    <span class="hljs-keyword">if</span> (p3 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol></li></ul><h3 id="10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？-star-2"><a href="#10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？-star-2" class="headerlink" title="10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？:star:2"></a>10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？:star:2</h3><p>需要重载操作符 <code>==</code> 判断两个结构体是否相等，不能用函数 <code>memcmp</code> 来判断两个结构体是否相等，因为 <code>memcmp</code> 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</p><p><strong>利用运算符重载来实现结构体对象的比较</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">char</span> c_tmp, <span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">c</span>(c_tmp), <span class="hljs-built_in">val</span>(tmp) &#123;&#125;<br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> A &amp;tmp1, <span class="hljs-keyword">const</span> A &amp;tmp2); <span class="hljs-comment">//  友元运算符重载函数</span><br>&#125;;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> A &amp;tmp1, <span class="hljs-keyword">const</span> A &amp;tmp2) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">90</span>)</span>, <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">80</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (ex1 == ex2)<br>        cout &lt;&lt; <span class="hljs-string">&quot;ex1 == ex2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;ex1 != ex2&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="11-参数传递时，值传递、引用传递、指针传递的区别？-star-2"><a href="#11-参数传递时，值传递、引用传递、指针传递的区别？-star-2" class="headerlink" title="11 参数传递时，值传递、引用传递、指针传递的区别？:star:2"></a>11 参数传递时，值传递、引用传递、指针传递的区别？:star:2</h3><p><strong>参数传递的三种方式</strong>：</p><ul><li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li><li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li><li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; <span class="hljs-comment">// 值传递</span><br>    cout &lt;&lt; &amp;tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * tmp)</span></span>&#123; <span class="hljs-comment">// 指针传递</span><br>    cout &lt;&lt; tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;tmp)</span></span>&#123; <span class="hljs-comment">// 引用传递</span><br>    cout &lt;&lt; &amp;tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;var 在主函数中的地址：&quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 值传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun1</span>(var);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 指针传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun2</span>(&amp;var);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 引用传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun3</span>(var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">var 在主函数中的地址：0x23fe4c</span><br><span class="hljs-comment">var 值传递时的地址：0x23fe20</span><br><span class="hljs-comment">var 指针传递时的地址：0x23fe4c</span><br><span class="hljs-comment">var 引用传递时的地址：0x23fe4c</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。</p><blockquote><p><a href="https://www.cnblogs.com/huolong-blog/p/7588335.html">c++值传递，指针传递，引用传递以及指针与引用的区别</a></p></blockquote><h3 id="12-什么是模板？如何实现？-star-3"><a href="#12-什么是模板？如何实现？-star-3" class="headerlink" title="12 什么是模板？如何实现？:star:3"></a>12 什么是模板？如何实现？:star:3</h3><p>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>实现方式：模板定义以关键字 <code>template</code> 开始，后跟一个模板参数列表。</p><ul><li>模板参数列表不能为空；</li><li>模板类型参数前必须使用关键字 <code>class</code> 或者 <code>typename</code> ，在模板参数列表中这两个关键字含义相同，可互换使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, ...&gt;<br></code></pre></div></td></tr></table></figure><p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p><ul><li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li><li>函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; tmp1, <span class="hljs-keyword">const</span> T &amp; tmp2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> tmp1 + tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    cin &gt;&gt; var1 &gt;&gt; var2;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var1, var2);<br><br>    <span class="hljs-keyword">double</span> var3, var4;<br>    cin &gt;&gt; var3 &gt;&gt; var4;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var3, var4);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类模板：类似函数模板，类模板以关键字 <code>template</code> 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Complex</span>(T a, T b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br><br>    <span class="hljs-comment">//运算符重载</span><br>    Complex&lt;T&gt; <span class="hljs-keyword">operator</span>+(Complex &amp;c)<br>    &#123;<br>        <span class="hljs-function">Complex&lt;T&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;a + c.a, <span class="hljs-keyword">this</span>-&gt;b + c.b)</span></span>;<br>        cout &lt;&lt; tmp.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; tmp.b &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T a;<br>    T b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span></span>;<br>    Complex&lt;<span class="hljs-keyword">int</span>&gt; c = a + b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="13-函数模板和类模板的区别？-star-2"><a href="#13-函数模板和类模板的区别？-star-2" class="headerlink" title="13 函数模板和类模板的区别？:star:2"></a>13 函数模板和类模板的区别？:star:2</h3><ul><li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li><li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li><li>默认参数：类模板在模板参数列表中可以有默认参数。</li><li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li><li>调用方式不同：<u>函数模板</u>可以隐式调用，也可以显式调用；<u>类模板</u>只能显式调用。</li></ul><p>函数模板调用方式举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; tmp1, <span class="hljs-keyword">const</span> T &amp; tmp2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> tmp1 + tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    cin &gt;&gt; var1 &gt;&gt; var2;<br>    cout &lt;&lt; add_fun&lt;<span class="hljs-keyword">int</span>&gt;(var1, var2); <span class="hljs-comment">// 显式调用</span><br><br>    <span class="hljs-keyword">double</span> var3, var4;<br>    cin &gt;&gt; var3 &gt;&gt; var4;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var3, var4); <span class="hljs-comment">// 隐式调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="14-什么是可变参数模板？-star-1"><a href="#14-什么是可变参数模板？-star-1" class="headerlink" title="14 什么是可变参数模板？:star:1"></a>14 什么是可变参数模板？:star:1</h3><p>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p><ul><li>模板参数包：表示零个或多个模板参数；</li><li>函数参数包：表示零个或多个函数参数。</li></ul><p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 <code>sizeof...</code> 运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-comment">// Args 是模板参数包</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span></span>; <span class="hljs-comment">// 可变参数模板，rest 是函数参数包</span><br></code></pre></div></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t)</span> </span>&#123;<br>    cout &lt;&lt; t &lt;&lt; endl; <span class="hljs-comment">// 最后一个元素</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args &amp;...args)</span> </span>&#123;<br>    cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">print_fun</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print_fun</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*运行结果：</span><br><span class="hljs-comment">Hello wolrd !</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：可变参数函数通常是递归的，第一个版本的 <code>print_fun</code> 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 <code>print_fun</code> 是可变参数版本，打印绑定到 <code>t</code> 的实参，并用来调用自身来打印函数参数包中的剩余值。</p><h3 id="15-什么是模板特化？为什么特化？-star-3"><a href="#15-什么是模板特化？为什么特化？-star-3" class="headerlink" title="15 什么是模板特化？为什么特化？:star:3"></a>15 什么是模板特化？为什么特化？:star:3</h3><p><strong>模板特化的原因</strong>：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</p><p><strong>模板特化</strong>：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p><ul><li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li><li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li></ul><p><strong>特化分为全特化和偏特化</strong>：</p><ul><li>全特化：模板中的模板参数全部特例化。</li><li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li></ul><p>函数重载与函数模板特化的区分：定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T t1, T t2)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通用版本：&quot;</span>;<br>    <span class="hljs-keyword">return</span> t1 == t2;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-comment">//函数模板特化</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *t1, <span class="hljs-keyword">char</span> *t2)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;特化版本：&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> arr1[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">char</span> arr2[] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">123</span>, <span class="hljs-number">123</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">compare</span>(arr1, arr2) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">通用版本：1</span><br><span class="hljs-comment">特化版本：0</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="16-include-“-“-和-lt-gt-的区别-star-1"><a href="#16-include-“-“-和-lt-gt-的区别-star-1" class="headerlink" title="16 include “ “ 和 &lt;&gt; 的区别 :star:1"></a>16 include “ “ 和 &lt;&gt; 的区别 :star:1</h3><p><code>include&lt;文件名&gt;</code> 和 <code>#include&quot;文件名&quot;</code> 的区别:</p><ul><li>查找文件的位置：<code>include&lt;文件名&gt;</code> 在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；<code>#include&quot;文件名&quot;</code> 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li><li>使用习惯：对于标准库中的头文件常用 <code>include&lt;文件名&gt;</code>，对于自己定义的头文件，常用 <code>#include&quot;文件名&quot;</code></li></ul><h3 id="17-switch-的-case-里为何不能定义变量-star-1"><a href="#17-switch-的-case-里为何不能定义变量-star-1" class="headerlink" title="17 switch 的 case 里为何不能定义变量 :star:1"></a>17 switch 的 case 里为何不能定义变量 :star:1</h3><p><code>switch</code> 下面的这个花括号表示一块作用域，而不是每一个 <code>case</code> 表示一块作用域。如果在某一 <code>case</code> 中定义了变量，其作用域在这块花括号内，按理说在另一个 <code>case</code> 内可以使用该变量，但是在实际使用时，每一个 <code>case</code> 之间互不影响，是相对封闭的，参考如下实例。</p><p>实例：下述代码中，在 <code>switch</code> 的 <code>case</code> 中定义的变量，没有实际意义，仅为了解释上述原因。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量声明</span><br>    <span class="hljs-keyword">char</span> var = <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (var)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义变量</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Excellent.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>        ++cnt;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Good.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Not bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;F&#x27;</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单解释：上述代码中在符合 <code>A</code> 的条件下定义了变量，当符合 <code>B</code> 或者 <code>C</code> 的条件时，对该变量进行自增操作，但是因为不符合条件 <code>A</code> 未对变量进行定义，该变量无法使用。</p><h3 id="18-迭代器的作用？-star-1"><a href="#18-迭代器的作用？-star-1" class="headerlink" title="18 迭代器的作用？:star:1"></a>18 迭代器的作用？:star:1</h3><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式。</p><p>作用：在无需知道容器底层原理的情况下，遍历容器中的元素。</p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 定义迭代器</span><br>    <span class="hljs-keyword">for</span> (; iter != arr.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">1 2 3 4 5 6 7 8 9 0</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="19-泛型编程如何实现？-star-2"><a href="#19-泛型编程如何实现？-star-2" class="headerlink" title="19 泛型编程如何实现？:star:2"></a>19 泛型编程如何实现？:star:2</h3><p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 <code>vector</code> 这样的泛型，或者 <code>find</code> 这样的泛型函数时，编译时会转化为特定的类或者函数。</p><p>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p><ul><li>容器：涉及到 STL 中的容器，例如：<code>vector</code>、<code>list</code>、<code>map</code> 等，可选其中熟悉底层原理的容器进行展开讲解。</li><li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li><li>模板：可参考本章节中的模板相关问题。</li></ul><h3 id="20-什么是类型萃取？-star-1"><a href="#20-什么是类型萃取？-star-1" class="headerlink" title="20 什么是类型萃取？:star:1"></a>20 什么是类型萃取？:star:1</h3><p>类型萃取使用模板技术来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。</p><p>C++ 类型萃取一般用于模板中，当我们定义一个模板函数后，需要知道模板类型形参并加以运用时就可以用类型萃取。</p><p>比如我们需要在函数中进行拷贝，通常我们可以用内置函数 <code>memcpy</code> 或者自己写一个 <code>for</code> 循环来进行拷贝。</p><blockquote><p><a href="https://blog.csdn.net/xuzhangze/article/details/78374890">C++之类型萃取</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_5类相关</title>
    <link href="/2021/09/05/C++%E9%9D%A2%E8%AF%95_5%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/05/C++%E9%9D%A2%E8%AF%95_5%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>虚函数，继承，构造函数，对象实例化，拷贝，多态。</p><span id="more"></span><h3 id="1-什么是虚函数？什么是纯虚函数？-star-5"><a href="#1-什么是虚函数？什么是纯虚函数？-star-5" class="headerlink" title="1 什么是虚函数？什么是纯虚函数？:star:5"></a>1 什么是虚函数？什么是纯虚函数？:star:5</h3><p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">v_fun</span>(); <span class="hljs-comment">// B::v_fun()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>纯虚函数</strong>：</p><ul><li>纯虚函数在类中声明时，加上 <code>=0</code>；</li><li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li></ul><p><strong>说明</strong>：</p><ul><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li><li>可以声明抽象类指针，可以声明抽象类的引用；</li><li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li></ul><h3 id="2-虚函数和纯虚函数的区别？-star-3"><a href="#2-虚函数和纯虚函数的区别？-star-3" class="headerlink" title="2 虚函数和纯虚函数的区别？:star:3"></a>2 虚函数和纯虚函数的区别？:star:3</h3><ul><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）；</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 <code>virtual</code> 关键字，纯虚函数定义时除了加上 <code>virtual</code> 关键字还需要加上 <code>=0</code> ；</li><li>虚函数必须实现，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li><strong>析构函数最好定义为虚函数，特别是对于含有继承关系的类</strong>；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li></ul><h3 id="3-虚函数的实现机制-star-5"><a href="#3-虚函数的实现机制-star-5" class="headerlink" title="3 虚函数的实现机制:star:5"></a>3 虚函数的实现机制:star:5</h3><p><strong>实现机制</strong>：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p><p><strong>虚函数表相关知识点</strong>：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul><p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p><p><strong>实例</strong>：无虚函数覆盖的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB9.png" width="100px" /></div><p>基类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB10.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB11.png" width="750px" /></div><p>主函数中基类的指针 <code>p</code> 指向了派生类的对象，当调用函数 <code>B_fun1()</code> 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p><h3 id="4-单继承和多继承的虚函数表结构-star-4"><a href="#4-单继承和多继承的虚函数表结构-star-4" class="headerlink" title="4 单继承和多继承的虚函数表结构 :star:4"></a>4 单继承和多继承的虚函数表结构 :star:4</h3><p><strong>编译器处理虚函数表</strong>：</p><ul><li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li><li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li><li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li><li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li></ul><ol><li><p>单继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB12.png" width="100px" /></div><p>基类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB13.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB14.png" width="800px" /></div></li><li><p>单继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB15.png" width="800px" /></div></li><li><p>多继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B1_fun1</span>(); <span class="hljs-comment">// Base1::B1_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB16.png" width="550px" /></div><p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB17.png" width="800px" /></div></li><li><p>多继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base2 *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base3 *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p1-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p2-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p3-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB18.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB19.png" width="700px" /></div></li></ol><h3 id="5-如何禁止构造函数的使用？-star-2"><a href="#5-如何禁止构造函数的使用？-star-2" class="headerlink" title="5 如何禁止构造函数的使用？:star:2"></a>5 如何禁止构造函数的使用？:star:2</h3><p>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;    <br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>)</span></span>; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-什么是类的默认构造函数？-star-3"><a href="#6-什么是类的默认构造函数？-star-3" class="headerlink" title="6 什么是类的默认构造函数？:star:3"></a>6 什么是类的默认构造函数？:star:3</h3><p>默认构造函数：未提供任何实参，来控制默认初始化过程的构造函数称为默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123; <span class="hljs-comment">// 类的默认构造函数</span><br>        var = <span class="hljs-number">10</span>;<br>        c = <span class="hljs-string">&#x27;q&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">char</span> c;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex;<br>    cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">q</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述程序中定义变量 <code>ex</code> 时，未提供任何实参，程序运行时会调用默认的构造函数。</p><h3 id="7-构造函数、析构函数是否需要定义成虚函数？为什么？-star-4"><a href="#7-构造函数、析构函数是否需要定义成虚函数？为什么？-star-4" class="headerlink" title="7 构造函数、析构函数是否需要定义成虚函数？为什么？:star:4"></a>7 构造函数、析构函数是否需要定义成虚函数？为什么？:star:4</h3><p>构造函数一般不定义为虚函数，原因：</p><ul><li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ul><p><strong>析构函数一般定义成虚函数</strong>，原因：析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</p><h3 id="8-如何避免拷贝？-star-2"><a href="#8-如何避免拷贝？-star-2" class="headerlink" title="8 如何避免拷贝？:star:2"></a>8 如何避免拷贝？:star:2</h3><p>最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 <code>private</code>，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p><p>解决方法：C++ 11 中使用弃置函数 <code>delete</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">noncopyable</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">noncopyable</span>(<span class="hljs-keyword">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    noncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span> :</span> <span class="hljs-keyword">private</span> noncopyable &#123; <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>关于继承应该用 <code>private</code> 还是 <code>public</code> 的争论<br>虽然 <code>public</code> 继承也可以达到要求，但最好还是用<code>private</code>继承</p><p>原因见《Effective C++》书中以下条款：<br>条款06：若不想使用编译器自动生成的函数，就该明确拒绝<br>条款32：确定你的 <code>public</code> 继承塑造出 is-a 关系<br>条款39：明智而审慎地使用 <code>private</code> 继承</p><h3 id="9-如何减少构造函数开销？-star-2"><a href="#9-如何减少构造函数开销？-star-2" class="headerlink" title="9 如何减少构造函数开销？:star:2"></a>9 如何减少构造函数开销？:star:2</h3><p>在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销，具体原因可以参考本章“为什么用成员初始化列表会快些？”这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>成员初始化列表：在类构造函数中，不在函数体内对变量赋值，而在参数列表后，跟一个冒号和初始化列表。为什么成员初始化列表效率更高？</p><p>答：因为对于非内置类型，少了一次调用默认构造函数的过程。</p><h3 id="10-多重继承时会出现什么状况？如何解决？-star-4"><a href="#10-多重继承时会出现什么状况？如何解决？-star-4" class="headerlink" title="10 多重继承时会出现什么状况？如何解决？:star:4"></a>10 多重继承时会出现什么状况？如何解决？:star:4</h3><p>多重继承（多继承）：是指从多个直接基类中产生派生类。</p><p>多重继承容易出现的问题：命名冲突和数据冗余问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <span class="hljs-comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述程序的继承关系如下：（菱形继承）</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB20.png" width="350px" /></div><p><strong>上述代码中存的问题</strong>：</p><p>对于派生类 <code>Derive</code> 上述代码中存在直接继承关系和间接继承关系。</p><p>直接继承：<code>Base2</code>、<code>Base3</code><br>间接继承：<code>Base1</code><br>对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突。</p><p><strong>解决方法</strong> 1： 声明出现冲突的成员变量来源于哪个类</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="hljs-comment">// 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>解决方法</strong> 2： 虚继承</p><p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p><p>实现方式：在继承方式前面加上 <code>virtual</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类，即虚基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类之间的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB21.png" width="350px" /></div><h3 id="11-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？-star-3"><a href="#11-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？-star-3" class="headerlink" title="11 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？:star:3"></a>11 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？:star:3</h3><p><strong>空类声明时编译器不会生成任何成员函数：</strong></p><p>对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>空类定义时编译器会生成 6 个成员函数：</p><p>当空类 A 定义对象时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class A</span><br><span class="hljs-comment">&#123;&#125;; 该空类的等价写法如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-keyword">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">delete</span> p;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="12-为什么拷贝构造函数必须为引用？-star-2"><a href="#12-为什么拷贝构造函数必须为引用？-star-2" class="headerlink" title="12 为什么拷贝构造函数必须为引用？:star:2"></a>12 为什么拷贝构造函数必须为引用？:star:2</h3><p>原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。</p><p>举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">val</span>(tmp) <span class="hljs-comment">// 带参数构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 拷贝构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>    &#125;<br><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 赋值函数（赋值运算符重载）</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    A ex3 = ex1;<br>    ex2 = ex1;<br>    ex2.<span class="hljs-built_in">fun</span>(ex1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">A &amp;operator=(const A &amp;tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><ul><li><p>说明 1：<code>ex2 = ex1;</code> 和 <code>A ex3 = ex1;</code> 为什么调用的函数不一样？<br>对象 <code>ex2</code> 已经实例化了，不需要构造，此时只是将 <code>ex1</code> 赋值给 <code>ex2</code>，只会调用赋值函数；但是 <code>ex3</code> 还没有实例化，因此调用的是拷贝构造函数，构造出 <code>ex3</code>，而不是赋值函数，这里涉及到构造函数的隐式调用。</p></li><li><p>说明 2：如果拷贝构造函数中形参不是引用类型，<code>A ex3 = ex1;</code> 会出现什么问题？<br>构造 <code>ex3</code>，实质上是 <code>ex3.A(ex1);</code>，假如拷贝构造函数参数不是引用类型，那么将使得 <code>ex3.A(ex1);</code> 相当于 <code>ex1</code> 作为函数 <code>A(const A tmp)</code> 的形参，在参数传递时相当于 <code>A tmp = ex1</code>，因为 <code>tmp</code> 没有被初始化，所以在 <code>A tmp = ex1</code> 中继续调用拷贝构造函数，接下来的是构造 <code>tmp</code>，也就是 <code>tmp.A(ex1)</code> ，必然又会有 <code>ex1</code> 作为函数 <code>A(const A tmp);</code> 的形参，在参数传递时相当于即 <code>A tmp = ex1</code>，那么又会触发拷贝构造函数，就这下永远的递归下去。</p></li><li><p>说明 3：为什么 <code>ex2.fun(ex1);</code> 会调用拷贝构造函数？<br><code>ex1</code> 作为参数传递给 fun 函数， 即 <code>A tmp = ex1;</code>，这个过程会调用拷贝构造函数进行初始化。</p></li></ul><h3 id="13-C-类对象的初始化顺序-star-3"><a href="#13-C-类对象的初始化顺序-star-3" class="headerlink" title="13 C++ 类对象的初始化顺序:star:3"></a>13 C++ 类对象的初始化顺序:star:3</h3><p><strong>构造函数调用顺序</strong>：</p><ul><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；</li></ul><ul><li>按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；</li></ul><ul><li>执行派生类自身的构造函数。</li></ul><p>综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数。</p><p>注：</p><ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关；</li><li>成员变量的初始化顺序与声明顺序有关；</li><li>析构顺序和构造顺序相反。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> :</span> <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B <span class="hljs-comment">// 派生列表</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    B ex1;<br>    A ex2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>程序运行结果分析：</p><ul><li>首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；</li><li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li><li>最后调用派生类的构造函数；</li><li>接下来调用析构函数，和构造函数调用的顺序相反。</li></ul><h3 id="14-如何禁止一个类被实例化？-star-2"><a href="#14-如何禁止一个类被实例化？-star-2" class="headerlink" title="14 如何禁止一个类被实例化？:star:2"></a>14 如何禁止一个类被实例化？:star:2</h3><p>方法一：在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1; <span class="hljs-comment">// error: cannot declare variable &#x27;ex1&#x27; to be of abstract type &#x27;A&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二：将类的构造函数声明为私有 <code>private</code></p><h3 id="15-为什么用成员初始化列表会快一些？-star-3"><a href="#15-为什么用成员初始化列表会快一些？-star-3" class="headerlink" title="15 为什么用成员初始化列表会快一些？:star:3"></a>15 为什么用成员初始化列表会快一些？:star:3</h3><p><strong>说明</strong>：数据类型可分为<u>内置类型</u>和<u>用户自定义类型</u>（类类型），对于用户自定义类型，利用<u>成员初始化列表效率高</u>。</p><p><strong>原因</strong>：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test2</span>() <span class="hljs-comment">// 函数体中赋值的方式</span><br>    &#123;<br>        ex = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test1 ex1;<br>    cout &lt;&lt; endl;<br>    Test2 ex2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">A(int 2)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。</p><h3 id="16-实例化一个对象需要哪几个阶段-star-3"><a href="#16-实例化一个对象需要哪几个阶段-star-3" class="headerlink" title="16 实例化一个对象需要哪几个阶段:star:3"></a>16 实例化一个对象需要哪几个阶段:star:3</h3><ol><li>分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</li><li>初始化：首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</li><li>赋值：对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</li></ol><p>注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li><li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li></ul><h3 id="17-友元函数的作用及使用场景-star-2"><a href="#17-友元函数的作用及使用场景-star-2" class="headerlink" title="17 友元函数的作用及使用场景:star:2"></a>17 友元函数的作用及使用场景:star:2</h3><p><strong>作用</strong>：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p><p><strong>使用场景</strong>：</p><ol><li><p>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp); <span class="hljs-comment">// 声明为类的友元函数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp)<br>&#123;<br>    _cout &lt;&lt; tmp.var;<br>    <span class="hljs-keyword">return</span> _cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; ex &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>友元类：类之间共享数据。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">var</span>(<span class="hljs-number">10</span>)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl; <span class="hljs-comment">// 访问类 A 中的私有成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    A ex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B ex;<br>    ex.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun():10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="18-静态绑定和动态绑定是怎么实现的？-star-3"><a href="#18-静态绑定和动态绑定是怎么实现的？-star-3" class="headerlink" title="18 静态绑定和动态绑定是怎么实现的？:star:3"></a>18 静态绑定和动态绑定是怎么实现的？:star:3</h3><p><strong>静态类型和动态类型</strong>：</p><ul><li>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</li><li>动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。</li></ul><p><strong>静态绑定和动态绑定</strong>：</p><ul><li>静态绑定是指程序在 编译阶段 确定对象的类型（静态类型）。</li><li>动态绑定是指程序在 运行阶段 确定对象的类型（动态类型）。</li></ul><p><strong>静态绑定和动态绑定的区别</strong>：</p><ul><li><p>发生的时期不同：如上。</p></li><li><p>对象的静态类型不能更改，动态类型可以更改。</p></li></ul><p>注：<u>对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>     &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span>; <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(); <span class="hljs-comment">// p 的静态类型是 Base*，动态类型是 Derive*</span><br>    p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun 是虚函数，运行阶段进行动态绑定</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Derive::fun()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="19-深拷贝和浅拷贝的区别-star-5"><a href="#19-深拷贝和浅拷贝的区别-star-5" class="headerlink" title="19 深拷贝和浅拷贝的区别 :star:5"></a>19 深拷贝和浅拷贝的区别 :star:5</h3><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。</p><ul><li><p>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</p></li><li><p>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</p></li></ul><p>当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。</p><p><strong>浅拷贝实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p><p><strong>深拷贝实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;tmp) <span class="hljs-comment">// 定义拷贝构造函数</span><br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*tmp.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">Test(const Test &amp;tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="20-编译时多态和运行时多态的区别-star-3"><a href="#20-编译时多态和运行时多态的区别-star-3" class="headerlink" title="20 编译时多态和运行时多态的区别:star:3"></a>20 编译时多态和运行时多态的区别:star:3</h3><p>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。</p><p>运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。</p><p><strong>编译时多态和运行时多态的区别</strong>：</p><ul><li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li><li>实现方式不同：编译时多态运用<u>泛型编程</u>来实现，运行时多态借助<u>虚函数</u>来实现。</li></ul><h3 id="21-实现一个类成员函数，要求不允许修改类的成员变量？-star-2"><a href="#21-实现一个类成员函数，要求不允许修改类的成员变量？-star-2" class="headerlink" title="21 实现一个类成员函数，要求不允许修改类的成员变量？:star:2"></a>21 实现一个类成员函数，要求不允许修改类的成员变量？:star:2</h3><p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 <code>const</code> 关键字来修饰该函数即可。</p><p>该问题本质是考察 <code>const</code> 关键字修饰成员函数的作用，只不过以实例的方式来考察，面试者应熟练掌握 <code>const</code> 关键字的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>() &#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span><br><span class="hljs-function">    </span>&#123;<br>        var1 = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="22-如何让类不能被继承？-star-3"><a href="#22-如何让类不能被继承？-star-3" class="headerlink" title="22 如何让类不能被继承？:star:3"></a>22 如何让类不能被继承？:star:3</h3><p>解决方法一：借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span>:</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>解决方法二：借助友元、虚继承和私有构造函数来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br>    <span class="hljs-keyword">friend</span> T;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&lt;B&gt;&#123;   <span class="hljs-comment">//一定注意 必须是虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>()&#123;&#125;     <span class="hljs-comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B b;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：在上述代码中 B 类是不能被继承的类。具体原因：</p><ul><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ul><p>注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_4关键字和库函数</title>
    <link href="/2021/09/04/C++%E9%9D%A2%E8%AF%95_4%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2021/09/04/C++%E9%9D%A2%E8%AF%95_4%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>C++ 常用关键字以及库函数介绍。</p><span id="more"></span><h3 id="1-sizeof-和-strlen-的区别-star-3"><a href="#1-sizeof-和-strlen-的区别-star-3" class="headerlink" title="1 sizeof 和 strlen 的区别 :star:3"></a>1 sizeof 和 strlen 的区别 :star:3</h3><ol><li><p><code>strlen</code>  是头文件 <code>&lt;cstring&gt;</code> 中的函数，<code>sizeof</code> 是 C++ 中的运算符。</p></li><li><p><code>strlen</code> 测量的是字符串的实际长度（其源代码如下），以 <code>\0</code>  结束。而 sizeof 测量的是字符数组的分配大小。</p><p><code>strlen</code> 源代码:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str++)<br>        ++length;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">strlen</span>(arr) &lt;&lt; endl; <span class="hljs-comment">// 5</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>若字符数组 arr 作为函数的形参，<code>sizeof(arr)</code> 中 arr 被当作字符指针来处理，<code>strlen(arr)</code> 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">size_of</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arr[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="hljs-comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span><br>    cout &lt;&lt; <span class="hljs-built_in">strlen</span>(arr) &lt;&lt; endl; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">size_of</span>(arr); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">8// 64 位机器，指针大小是8</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>strlen</code> 本身是库函数，因此在程序运行过程中，计算长度；而 <code>sizeof</code> 在编译时，计算长度；</p></li><li><p><code>sizeof</code> 的参数可以是类型，也可以是变量；<code>strlen</code> 的参数必须是 <code>char*</code> 类型的变量。</p></li></ol><h3 id="2-lambda-表达式（匿名函数）的具体应用和使用场景-star-3"><a href="#2-lambda-表达式（匿名函数）的具体应用和使用场景-star-3" class="headerlink" title="2 lambda 表达式（匿名函数）的具体应用和使用场景 :star:3"></a>2 lambda 表达式（匿名函数）的具体应用和使用场景 :star:3</h3><p><code>lambda</code> 表达式的定义形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[capture list] (parameter list) -&gt; reurn type<br>&#123;<br>   function body<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><p>举例：<code>lambda</code> 表达式常搭配排序算法使用。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">76</span>, <span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">90</span>, <span class="hljs-number">34</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;); <span class="hljs-comment">// 降序排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : arr)<br>    &#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：90 76 54 34 12 4 3</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="3-explicit-的作用（如何避免编译器进行隐式类型转换）-star-3"><a href="#3-explicit-的作用（如何避免编译器进行隐式类型转换）-star-3" class="headerlink" title="3 explicit 的作用（如何避免编译器进行隐式类型转换） :star:3"></a>3 explicit 的作用（如何避免编译器进行隐式类型转换） :star:3</h3><p>作用：用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 <code>explicit</code> 关键字也没有什么意义。</p><p>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        var = tmp;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex = <span class="hljs-number">10</span>; <span class="hljs-comment">// 发生了隐式转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中，<code>A ex = 10;</code>  在编译时，进行了隐式转换，将 <code>10</code> 转换成 <code>A</code> 类型的对象，然后将该对象赋值给 <code>ex</code>，等同于如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>为了避免隐式转换，可用 <code>explicit</code> 关键字进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        var = tmp;<br>        cout &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-C-和-C-static-的区别-star-1"><a href="#4-C-和-C-static-的区别-star-1" class="headerlink" title="4 C 和 C++ static 的区别 :star:1"></a>4 C 和 C++ static 的区别 :star:1</h3><ul><li>在 C 语言中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数</li><li>在 C++ 中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</li></ul><h3 id="5-static-的作用-star-4"><a href="#5-static-的作用-star-4" class="headerlink" title="5 static 的作用 :star:4"></a>5 static 的作用 :star:4</h3><p><code>static</code> 定义静态变量，静态函数。</p><ul><li><p><strong>保持变量内容持久</strong>：<code>static</code> 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>; <span class="hljs-comment">// var 只在第一次进入这个函数的时初始化</span><br>    var += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> var;<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">fun</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 2 3 4 5 6 7 8 9 10 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>隐藏</strong>：<code>static</code> 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</p></li><li><p><code>static</code> 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 静态成员变量</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; s_var++ &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s_show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; s_var &lt;&lt; endl;<br><span class="hljs-comment">// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span><br>        <span class="hljs-comment">// show();  // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> A::s_var = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 静态成员变量在类外进行初始化赋值，默认初始化为 0</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// cout &lt;&lt; A::sa &lt;&lt; endl;    // error: &#x27;int A::sa&#x27; is private within this context</span><br>    A ex;<br>    ex.<span class="hljs-built_in">show</span>();<br>    A::<span class="hljs-built_in">s_show</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-static-在类中使用的注意事项（定义、初始化和使用）-star-5"><a href="#6-static-在类中使用的注意事项（定义、初始化和使用）-star-5" class="headerlink" title="6 static 在类中使用的注意事项（定义、初始化和使用）:star: 5"></a>6 static 在类中使用的注意事项（定义、初始化和使用）:star: 5</h3><p><strong>static 静态成员变量：</strong></p><ol><li>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 <code>static</code> 关键字和 <code>private</code>、<code>public</code>、<code>protected</code> 访问规则。</li><li>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</li><li>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = s_var)</span></span>; <span class="hljs-comment">// 正确，静态成员变量可以作为成员函数的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = var)</span></span>;   <span class="hljs-comment">//  error: invalid use of non-static data member &#x27;A::var&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> A s_var; <span class="hljs-comment">// 正确，静态数据成员</span><br>    A var;          <span class="hljs-comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span><br>    A *p;           <span class="hljs-comment">// 正确，指针</span><br>    A &amp;var1;        <span class="hljs-comment">// 正确，引用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>static 静态成员函数：</strong></p><ol><li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 <code>this</code> 指针。静态成员函数做为类作用域的全局函数。</li><li>静态成员函数不能声明成虚函数（<code>virtual</code>）、<code>const</code> 函数和 <code>volatile</code> 函数。</li></ol><p><strong>为何 static 成员函数不能为 virtual：</strong></p><ol><li><code>static</code> 成员不属于任何类对象或类实例，所以即使给此函数加上 <code>virutal</code> 也是没有任何意义的。</li><li>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有 <code>this</code> 指针。<ul><li>虚函数依靠 <code>vptr</code> 和 <code>vtable</code> 来处理。<code>vptr</code> 是一个指针，在类的构造函数中创建生成，并且只能用 <code>this</code> 指针来访问它，因为它是类的一个成员，并且 <code>vptr</code> 指向保存虚函数地址的 <code>vtable</code>；</li><li>对于静态成员函数，它没有 <code>this</code> 指针，所以无法访问 <code>vptr</code>。 这就是为何 <code>static</code> 函数不能为 <code>virtual</code>。</li><li>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</li></ul></li></ol><p><strong>为何 static 成员函数不能为 const 函数：</strong></p><ol><li>当声明一个非静态成员函数为 <code>const</code> 时，对 <code>this</code> 指针会有影响。对于一个 <code>Test</code> 类中的 <code>const</code> 修饰的成员函数，<code>this</code> 指针相当于 <code>Test const *</code>，而对于非 <code>const</code> 成员函数，<code>this</code> 指针相当于 <code>Test *</code>；</li><li>而 <code>static</code> 成员函数没有 <code>this</code> 指针，所以使用 <code>const</code> 来修饰 <code>static</code> 成员函数没有任何意义。</li><li><code>volatile</code> 的道理也是如此。</li></ol><h3 id="7-static-全局变量和普通全局变量的异同-star-3"><a href="#7-static-全局变量和普通全局变量的异同-star-3" class="headerlink" title="7 static 全局变量和普通全局变量的异同 :star:3"></a>7 static 全局变量和普通全局变量的异同 :star:3</h3><p><strong>相同点</strong>：</p><p>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</p><p><strong>不同点</strong>：</p><p>作用域：<u>普通全局变量</u>的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；<u>静态全局变量</u>则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。<br>初始化：静态全局变量只初始化一次，防止在其他文件中使用。全局变量只初始化一次，不管是静态的还是普通的。</p><h3 id="8-const-作用及用法-star-3"><a href="#8-const-作用及用法-star-3" class="headerlink" title="8 const 作用及用法 :star:3"></a>8 const 作用及用法 :star:3</h3><p><strong>作用</strong>：</p><ul><li><code>const</code> 修饰成员变量，定义成 <code>const</code> 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li><li><code>const</code> 修饰函数参数，使得传递过来的函数参数的值不能改变。</li><li><code>const</code> 修饰成员函数，使得成员函数不能修改任何类型的成员变量（<code>mutable</code> 修饰的变量除外），也不能调用非 <code>const</code> 成员函数，因为非 <code>const</code> 成员函数可能会修改成员变量。</li></ul><p><strong>在类中的用法</strong>：</p><p><code>const</code> 成员变量：</p><ul><li><code>const</code> 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li><li><code>const</code> 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 <code>const</code> 成员变量的值是不同的。因此不能在类的声明中初始化 <code>const</code> 成员变量，类的对象还没有创建，编译器不知道他的值。</li></ul><p><code>const</code> 成员函数：</p><ul><li>不能修改成员变量的值，除非有 <code>mutable</code> 修饰；只能访问成员变量。</li><li>不能调用非常量成员函数，以防修改成员变量的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> var;<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c_fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// const 成员函数</span></span><br><span class="hljs-function"></span>&#123;<br>var = tmp; <span class="hljs-comment">// error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。</span><br><span class="hljs-built_in">fun</span>(tmp); <span class="hljs-comment">// error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function"></span>&#123;<br>var = tmp;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-define-和-const-的区别-star-3"><a href="#9-define-和-const-的区别-star-3" class="headerlink" title="9 define 和 const 的区别 :star:3"></a>9 define 和 const 的区别 :star:3</h3><p><strong>区别</strong>：</p><ul><li><p><strong>编译阶段</strong>：<code>define</code> 是在编译预处理阶段进行替换，<code>const</code> 是在编译阶段确定其值。</p></li><li><p><strong>安全性</strong>：<code>define</code> 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；<code>const</code> 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</p></li><li><p><strong>内存占用</strong>：<code>define</code> 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；<code>const</code> 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</p><p><code>const</code> 局部变量存储在栈区，<code>const</code> 全局变量存储在已初始化数据段 ( 只读数据段 )。</p></li><li><p><strong>调试</strong>：<code>define</code> 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；<code>const</code> 定义的常量可以进行调试。</p></li></ul><p><strong>const 的优点</strong>：</p><ul><li>有数据类型，在定义时可进行安全性检查。</li><li>可调试。</li><li>占用较少的空间。</li></ul><h3 id="10-define-和-typedef-的区别-star-2"><a href="#10-define-和-typedef-的区别-star-2" class="headerlink" title="10 define 和 typedef 的区别 :star:2"></a>10 define 和 typedef 的区别 :star:2</h3><ul><li><strong>原理</strong>：<code>#define</code> 作为预处理指令，在编译预处理时进行<u>替换</u>操作，不做正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。<code>typedef</code> 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 <code>typedef</code> 。</li><li><strong>功能</strong>：<code>typedef</code> 用来定义类型的别名，方便使用。<code>#define</code> 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li><strong>作用域</strong>：<code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 <code>typedef</code> 有自己的作用域。</li><li><strong>指针的操作</strong>：<code>typedef</code> 和 <code>#define</code> 在处理指针时不完全一样。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTPTR1 int *</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> * INTPTR2;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    INTPTR1 p1, p2; <span class="hljs-comment">// p1: int *; p2: int</span><br>    <span class="hljs-comment">// 上述表达式的等价写法: int * p1, p2;</span><br>    INTPTR2 p3, p4; <span class="hljs-comment">// p3: int *; p4: int *</span><br><br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> INTPTR1 p5 = &amp;var; <span class="hljs-comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span><br>    <span class="hljs-keyword">const</span> INTPTR2 p6 = &amp;var; <span class="hljs-comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="11-用宏实现比较大小，以及两个数中的最小值-star-1"><a href="#11-用宏实现比较大小，以及两个数中的最小值-star-1" class="headerlink" title="11 用宏实现比较大小，以及两个数中的最小值 :star:1"></a>11 用宏实现比较大小，以及两个数中的最小值 :star:1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var1 = <span class="hljs-number">10</span>, var2 = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">MAX</span>(var1, var2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">MIN</span>(var1, var2) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序运行结果：</span><br><span class="hljs-comment">100</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>如果去掉宏定义中的括号，某些时候就会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(X, Y) (X &gt; Y ? X : Y)</span><br><span class="hljs-built_in">MAX</span>(<span class="hljs-number">5</span>+<span class="hljs-number">6</span>, <span class="hljs-number">6</span>+<span class="hljs-number">7</span>) =&gt; (<span class="hljs-number">5</span> + <span class="hljs-number">6</span> &gt; <span class="hljs-number">6</span> + <span class="hljs-number">7</span> ? <span class="hljs-number">5</span> + <span class="hljs-number">6</span> : <span class="hljs-number">6</span> + <span class="hljs-number">7</span>)<br></code></pre></div></td></tr></table></figure><h3 id="12-inline-作用及使用方法-star-3"><a href="#12-inline-作用及使用方法-star-3" class="headerlink" title="12 inline 作用及使用方法 :star:3"></a>12 inline 作用及使用方法 :star:3</h3><p><strong>关键字 <code>inline</code>  内联函数的作用：</strong></p><p>内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开。这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p><ol><li><p>消除函数调用的开销。</p><p>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能（因为使用 #define 定义的那些“函数”，编译器不会检查其参数的正确性等，而使用 inline 定义的函数，和普通函数一样，可以被编译器检查，这样有利于尽早发现错误）。</p></li><li><p>去除函数只能定义一次的限制。<br>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p></li></ol><p><strong>关于减少函数调用的开销</strong>：</p><ol><li><p>内联函数一定会被编译器在调用点展开吗？</p><p>错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</p></li><li><p>“调用” 普通函数时，一定是调用吗？</p><p>错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。</p></li><li><p>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？</p><p>错。首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内敛函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</p></li></ol><p><strong>关于去除函数只能定义一次的限制</strong>：</p><ul><li><p>下述程序会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;function 1&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 文件2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;function 2&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">myPrint</span>();  <span class="hljs-comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>下述程序不会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;inline function 1&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 文件2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;inline function 2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">myPrint</span>()<span class="hljs-comment">// 正常运行;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>可见，内联函数可以在头文件中定义（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）。</p><p><strong>使用方法</strong>：</p><ol><li><p>类内定义成员函数默认是内联函数。</p><p>在类内定义成员函数，可以不用在函数头部加 <code>inline</code> 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)&#123; <br>      var = tmp;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123; <br>        cout &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>类外定义成员函数，若想定义为内联函数，需用关键字声明.。</p><p>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 <code>inline</code> 关键字，而在类外定义函数时加上 <code>inline</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)&#123; <br>      var = tmp;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 类内声明不加 inline 关键字</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">A::fun</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 类外定义函数时加上 inline 关键字</span><br>    cout &lt;&lt; var &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>另外，可以在声明函数和定义函数的同时加上 <code>inline</code> ；也可以只在函数声明时加 <code>inline</code>，而定义函数时不加 <code>inline</code> 。只要确保在调用该函数之前把 <code>inline</code> 的信息告知编译器即可。</p></li></ol><h3 id="13-inline-函数工作原理-star-2"><a href="#13-inline-函数工作原理-star-2" class="headerlink" title="13 inline 函数工作原理 :star:2"></a>13 inline 函数工作原理 :star:2</h3><ul><li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li><li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li></ul><h3 id="14-宏定义（define）和内联函数（inline）的区别-star-2"><a href="#14-宏定义（define）和内联函数（inline）的区别-star-2" class="headerlink" title="14 宏定义（define）和内联函数（inline）的区别 :star:2"></a>14 宏定义（define）和内联函数（inline）的区别 :star:2</h3><ul><li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li><li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li><li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fun_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">MAX</span>(var, <span class="hljs-number">5</span>) &lt;&lt; endl;     <br>    cout &lt;&lt; <span class="hljs-built_in">fun_max</span>(var, <span class="hljs-number">0</span>) &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序运行结果：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="15-new-的作用？-star-2"><a href="#15-new-的作用？-star-2" class="headerlink" title="15 new 的作用？:star:2"></a>15 new 的作用？:star:2</h3><p><code>new</code> 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <br></code></pre></div></td></tr></table></figure><h3 id="16-new-和-malloc-如何判断是否申请到内存？-star-2"><a href="#16-new-和-malloc-如何判断是否申请到内存？-star-2" class="headerlink" title="16 new 和 malloc 如何判断是否申请到内存？ :star:2"></a>16 new 和 malloc 如何判断是否申请到内存？ :star:2</h3><p><code>malloc</code>：成功申请到内存，返回指向该内存的指针；分配失败，返回 <code>NULL</code> 指针。<br><code>new</code>：内存分配成功，返回该对象类型的指针；分配失败，抛出 <code>bad_alloc</code> 异常。</p><h3 id="17-delete-实现原理？delete-和-delete-的区别？-star-3"><a href="#17-delete-实现原理？delete-和-delete-的区别？-star-3" class="headerlink" title="17 delete 实现原理？delete 和 delete[] 的区别？ :star:3"></a>17 delete 实现原理？delete 和 delete[] 的区别？ :star:3</h3><p><code>delete</code> 的实现原理：</p><ul><li>首先执行该对象所属类的析构函数；</li><li>进而通过调用 <code>operator delete</code> 的标准库函数来释放所占的内存空间。</li></ul><p><code>delete</code> 和 <code>delete []</code> 的区别：</p><ul><li><code>delete</code> 用来释放单个对象所占的空间，只会调用一次析构函数；</li><li><code>delete []</code> 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li></ul><h3 id="18-new-和-malloc-的区别，delete-和-free-的区别-star-4"><a href="#18-new-和-malloc-的区别，delete-和-free-的区别-star-4" class="headerlink" title="18 new 和 malloc 的区别，delete 和 free 的区别 :star:4"></a>18 new 和 malloc 的区别，delete 和 free 的区别 :star:4</h3><p>使用搭配：<code>malloc</code> 和 <code>free</code>  ； <code>new</code> 和 <code>delete</code> 。</p><ul><li><p><code>malloc</code>、<code>free</code> 是库函数，而 <code>new</code> 、<code>delete</code> 是关键字。</p><p><code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</p></li><li><p><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 <code>void*</code> 类型，需要进行强制类型的转换，转换为对象类型的指针。</p></li><li><p><code>new</code> 分配失败时，会抛出 <code>bad_alloc</code> 异常；<code>malloc</code> 分配失败时返回空指针。</p></li><li><p>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 <code>free</code> 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。</p></li><li><p><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</p></li></ul><p><strong>堆区和自由存储区的区别与联系</strong>：</p><ul><li>malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放</li><li>堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</li></ul><p><strong>记住</strong>：</p><ul><li>堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。</li><li>new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。</li><li>堆和自由内存区有相同之处，但并不等价。</li></ul><h3 id="19-malloc-的原理？malloc-的底层实现？-star-2"><a href="#19-malloc-的原理？malloc-的底层实现？-star-2" class="headerlink" title="19 malloc 的原理？malloc 的底层实现？:star:2"></a>19 malloc 的原理？malloc 的底层实现？:star:2</h3><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p><code>malloc</code> 的原理：</p><ul><li>当开辟的空间小于 128K 时，调用 <code>brk()</code> 函数，它将数据段 (.data) 的最高地址指针  <code>_enddata</code> 往高地址推；</li><li>当开辟空间大于 128K 时，调用 <code>mmap()</code> 函数，通过在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li></ul><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p><strong>问题</strong>：为什么在默认的情况下，malloc 函数分配内存时，如果请求内存大于 128 K（可由 M_MMAP_THRESHOLD 选项调节），就不是去推 <code>_edata</code> 指针，而是利用 mmap 系统调用，从堆和栈的中间分配一块虚拟内存？</p><p><strong>答案</strong>：因为 brk 分配的内存需要等到高地址内存释放之后才能释放，而 mmap 分配的内存可以单独释放。</p><p>参考资料：<a href="https://www.cnblogs.com/dongzhiquan/p/5621906.html">linux环境内存分配原理—虚拟内存</a></p><h3 id="20-C-和-C-struct-的区别？-star-2"><a href="#20-C-和-C-struct-的区别？-star-2" class="headerlink" title="20 C 和 C++ struct 的区别？:star:2"></a>20 C 和 C++ struct 的区别？:star:2</h3><ul><li>在 C 语言中 <code>struct</code> 是用户自定义数据类型；在 C++ 中 <code>struct</code> 是抽象数据类型，支持成员函数的定义。</li><li>C 语言中 <code>struct</code> 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 <code>struct</code> 可以和类一样，有访问权限，并可以定义成员函数。</li><li>C 语言中 <code>struct</code> 定义的自定义数据类型，在定义该类型的变量时，需要加上 <code>struct</code> 关键字，例如：<code>struct A var;</code> ，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：<code>A var</code>;</li></ul><h3 id="21-为什么有了-class-还保留-struct？-star-2"><a href="#21-为什么有了-class-还保留-struct？-star-2" class="headerlink" title="21 为什么有了 class 还保留 struct？:star:2"></a>21 为什么有了 class 还保留 struct？:star:2</h3><p>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 <code>struct</code>。</p><h3 id="22-struct-和-union-的区别-star-2"><a href="#22-struct-和-union-的区别-star-2" class="headerlink" title="22 struct 和 union 的区别 :star:2"></a>22 struct 和 union 的区别 :star:2</h3><p>说明：<code>union</code> 是联合体，<code>struct</code> 是结构体。</p><p>区别：</p><ul><li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li><li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li><li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">char</span> cc1; <span class="hljs-comment">// char 1 字节，按该类型的倍数分配大小</span><br>&#125; u11;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// int 4 字节，按该类型的倍数分配大小</span><br>&#125; u22;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// double 8 字节，按该类型的倍数分配大小</span><br>&#125; u33;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s1</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br>&#125; s11;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s2</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">char</span> cc;  <span class="hljs-comment">// 1（char）+ 1（char）= 2 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 2 + 6（内存对齐）+ 8（double）= 16 字节</span><br>&#125; s22;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br>    <span class="hljs-keyword">char</span> cc;  <span class="hljs-comment">// 16 + 1（char）+ 7（内存对齐）= 24 字节</span><br>&#125; s33;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u11) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u22) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u33) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s11) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s22) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s33) &lt;&lt; endl; <span class="hljs-comment">// 24</span><br><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) &lt;&lt; endl;    <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="23-class-和-struct-的异同-star-2"><a href="#23-class-和-struct-的异同-star-2" class="headerlink" title="23 class 和 struct 的异同 :star:2"></a>23 class 和 struct 的异同 :star:2</h3><ul><li><p><code>struct</code> 和 <code>class</code> 都可以自定义数据类型，也支持继承操作。</p></li><li><p><code>struct</code> 中默认的访问级别是 <code>public</code> ，默认的继承级别也是 <code>public</code> ；class 中默认的访问级别是 <code>private</code>，默认的继承级别也是 <code>private</code>。</p></li><li><p>当 <code>class</code> 继承 <code>struct</code> 或者 <code>struct</code> 继承 <code>class</code> 时，默认的继承级别取决于 <code>class</code> 或 <code>struct</code> 本身， <code>class</code>（<code>private</code>继承），<code>struct</code>（<code>public</code> 继承），即取决于派生类的默认继承级别。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span>&#125;；<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> A&#123;&#125;; <span class="hljs-comment">// private 继承 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> :</span> B&#123;&#125;； <span class="hljs-comment">// public 继承</span><br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funA</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>:</span> A &#123; <span class="hljs-comment">// 由于 B 是 struct，A 的默认继承级别为 public</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funB</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> B &#123; <span class="hljs-comment">// 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 funB 函数</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;<br>    ex1.<span class="hljs-built_in">funA</span>(); <span class="hljs-comment">// class A</span><br><br>    B ex2;<br>    ex2.<span class="hljs-built_in">funA</span>(); <span class="hljs-comment">// class A</span><br>    ex2.<span class="hljs-built_in">funB</span>(); <span class="hljs-comment">// class B</span><br><br>    C ex3;<br>    ex3.<span class="hljs-built_in">funB</span>(); <span class="hljs-comment">// error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/luoweifu/article/details/46953343">C++的三种访问权限与三种继承方式</a></p></li></ul><h3 id="24-volatile-的作用？是否具有原子性，对编译器有什么影响？-star-2"><a href="#24-volatile-的作用？是否具有原子性，对编译器有什么影响？-star-2" class="headerlink" title="24 volatile 的作用？是否具有原子性，对编译器有什么影响？ :star:2"></a>24 volatile 的作用？是否具有原子性，对编译器有什么影响？ :star:2</h3><p><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>volatile</code>，告知编译器不应对这样的对象进行优化。</p><p><code>volatile</code> 不具有原子性。</p><p><code>volatile</code> 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p><blockquote><p>《程序员的自我修养》原话：</p></blockquote><p>我们可以使用 <code>volatile</code> 关键字试图阻止过度优化，<code>volatile</code>  基本可以做到两件事情：</p><ol><li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）；</li><li>阻止编译器调整操作 <code>volatile</code> 变量的指令排序。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 即使 `volatile` 能够阻止编译器调整顺序，也无法阻止 CPU 动态调度换序。</span><br><br><span class="hljs-comment">// 要保证线程安全，阻止 CPU 换序是必须的。遗憾的是，现在并不存在可移植的阻止换序的方法。</span><br><span class="hljs-comment">//通常情况下是调用 CPU 提供的一条指令，这条指令常常被称为 barrier。</span><br><span class="hljs-comment">// 一条 barrier 指令会阻止 CPU 将该指令之前的指令交换到 barrier 之后。</span><br></code></pre></div></td></tr></table></figure><p>对 <code>volatile</code> 的三点理解：</p><ol><li>只能保证赋值原子性，复合操作不能保证；</li><li>告诉编译器不进行指令重排（ JMM 中还会追加 CPU 内存屏障），以避免过度优化；</li><li>保证内存可见性。</li></ol><h3 id="25-什么情况下一定要用-volatile，-能否和-const-一起使用？-star-2"><a href="#25-什么情况下一定要用-volatile，-能否和-const-一起使用？-star-2" class="headerlink" title="25 什么情况下一定要用 volatile， 能否和 const 一起使用？:star:2"></a>25 什么情况下一定要用 volatile， 能否和 const 一起使用？:star:2</h3><p>使用  <code>volatile</code> 关键字的场景：</p><ul><li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用  <code>volatile</code> 关键字对该变量进行修饰；</li><li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用  <code>volatile</code> 关键字修饰。</li><li><code>volatile</code> 关键字和 <code>const</code> 关键字可以同时使用，某种类型可以既是 <code>volatile</code> 又是 <code>const</code>，同时具有二者的属性。</li></ul><p>解决多线程中变量同步问题，最好使用 <code>automic</code> 保持吧，<code>volatile</code> 并不一定能够保持。</p><h3 id="26-返回函数中静态变量的地址会发生什么？-star-2"><a href="#26-返回函数中静态变量的地址会发生什么？-star-2" class="headerlink" title="26 返回函数中静态变量的地址会发生什么？:star:2"></a>26 返回函数中静态变量的地址会发生什么？:star:2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">10</span>;<br>    var *= tmp;<br>    <span class="hljs-keyword">return</span> &amp;var;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; *<span class="hljs-built_in">fun</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">50</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述代码中在函数 fun 中定义了静态局部变量 <code>var</code>，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p><h3 id="27-extern-C-的作用？-star-2"><a href="#27-extern-C-的作用？-star-2" class="headerlink" title="27 extern C 的作用？:star:2"></a>27 extern C 的作用？:star:2</h3><p>当 C++ 程序需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>C++ 和 C语言编译函数签名方式不一样， extern关键字可以让两者保持统一，这样才能找到对应的函数。</p><h3 id="28-sizeof-1-1-在-C-和-C-中分别是什么结果？-star-1"><a href="#28-sizeof-1-1-在-C-和-C-中分别是什么结果？-star-1" class="headerlink" title="28 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？:star:1"></a>28 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？:star:1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C 语言</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">1</span>==<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// sizeof（1 == 1） === sizeof（1）</span><br><span class="hljs-comment">// 按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）</span><br><br><br><span class="hljs-comment">// C++</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">1</span>==<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 因为有bool 类型</span><br><span class="hljs-comment">// sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节</span><br><br></code></pre></div></td></tr></table></figure><h3 id="29-memcpy-函数的底层原理？-star-3"><a href="#29-memcpy-函数的底层原理？-star-3" class="headerlink" title="29 memcpy 函数的底层原理？:star:3"></a>29 memcpy 函数的底层原理？:star:3</h3><p>参考资料：<a href="https://blog.csdn.net/yuanrxdu/article/details/23771459">关于C函数memcpy的实现细节思考</a></p><h3 id="30-strcpy-函数有什么缺陷？-star-2"><a href="#30-strcpy-函数有什么缺陷？-star-2" class="headerlink" title="30 strcpy 函数有什么缺陷？:star:2"></a>30 strcpy 函数有什么缺陷？:star:2</h3><p><code>strcpy</code> 函数的缺陷：<code>strcpy</code> 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">0x11112222</span>;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;<br>    <span class="hljs-built_in">strcpy</span>(arr, <span class="hljs-string">&quot;hello world!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="hljs-comment">// 将变量 var 以 16 进制输出</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Address : var 0x23fe4c</span><br><span class="hljs-comment">Address : arr 0x23fe42</span><br><span class="hljs-comment">var:11002164</span><br><span class="hljs-comment">arr:hello world!</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：从上述代码中可以看出，变量 <code>var</code> 的后六位被字符串 <code>&quot;hello world!&quot;</code> 的 <code>&quot;d!\0&quot;</code> 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：<code>\0</code> (0x00)，<code>!</code> (0x21)，<code>d</code> (0x64)。</p><p><strong>原因</strong>：变量 <code>arr</code> 只分配的 10 个内存空间，通过上述程序中的地址可以看出 <code>arr</code> 和 <code>var</code> 在内存中是连续存放的，但是在调用 <code>strcpy</code> 函数进行拷贝时，源字符串 <code>&quot;hello world!&quot;</code> 所占的内存空间为 13，因此在拷贝的过程中会占用 <code>var</code> 的内存空间，导致 <code>var</code> 的后六位被覆盖。</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB8.png" width="550px" /></div><h3 id="31-auto-类型推导的原理-star-2"><a href="#31-auto-类型推导的原理-star-2" class="headerlink" title="31 auto 类型推导的原理:star:2"></a>31 auto 类型推导的原理:star:2</h3><p><code>auto</code> 类型推导的原理：</p><p>编译器根据初始值来推算变量的类型，要求用 <code>auto</code> 定义变量时必须有初始值。编译器推断出来的 <code>auto</code> 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_3面向对象</title>
    <link href="/2021/09/03/C++%E9%9D%A2%E8%AF%95_3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/09/03/C++%E9%9D%A2%E8%AF%95_3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象的理解、三大特性、多态。</p><span id="more"></span><h3 id="1-什么是面向对象？面向对象的三大特性-star-5"><a href="#1-什么是面向对象？面向对象的三大特性-star-5" class="headerlink" title="1 什么是面向对象？面向对象的三大特性 :star:5"></a>1 什么是面向对象？面向对象的三大特性 :star:5</h3><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p><p>面向对象的三大特性：</p><ul><li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为，子类有父类的非 <code>private</code> 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 <code>final</code> 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li></ul><h3 id="2-重载、重写、隐藏的区别-star-5"><a href="#2-重载、重写、隐藏的区别-star-5" class="headerlink" title="2 重载、重写、隐藏的区别 :star:5"></a>2 重载、重写、隐藏的区别 :star:5</h3><ul><li><strong>重载</strong>：同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">float</span> tmp)</span></span>;        <span class="hljs-comment">// 重载 参数类型不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp, <span class="hljs-keyword">float</span> tmp1)</span></span>; <span class="hljs-comment">// 重载 参数个数不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">float</span> tmp, <span class="hljs-keyword">int</span> tmp1)</span></span>; <span class="hljs-comment">// 重载 参数顺序不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>;            <span class="hljs-comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>隐藏</strong>：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp, <span class="hljs-keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 隐藏基类中的同名函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive ex;<br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// Derive::fun(int tmp)</span><br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.01</span>); <span class="hljs-comment">// error: candidate expects 1 argument, 2 provided</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：上述代码中 <code>ex.fun(1, 0.01);</code> 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 <code>ex.Base::fun(1, 0.01);</code>，这样就可以调用基类中的同名函数。</p></li></ul><ul><li><p><strong>重写</strong>(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 <code>virtual</code> 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="hljs-comment">// 重写基类中的 fun 函数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    p-&gt;<span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// Derived::fun(int) : 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>重写和重载的区别</strong>：</p><ul><li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li><li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 <code>virtual</code> 修饰。</li><li><code>virtual</code> 关键字：重写的函数基类中必须有 <code>virtua</code> 关键字的修饰，重载的函数可以有 <code>virtual</code> 关键字的修饰也可以没有。</li></ul><p><strong>隐藏和重写，重载的区别</strong>：</p><ul><li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li><li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 <code>virtual</code> 修饰，基类函数都是被隐藏，而不是重写。</li></ul><h3 id="3-如何理解-C-是面向对象编程-star-3"><a href="#3-如何理解-C-是面向对象编程-star-3" class="headerlink" title="3 如何理解 C++ 是面向对象编程 :star:3"></a>3 如何理解 C++ 是面向对象编程 :star:3</h3><ul><li>面向过程编程：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li></ul><ul><li>面向对象编程（Object-Oriented Programming, OOP）：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</li></ul><p><strong>面向对象编程进一步说明</strong>：</p><p>面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（<code>public、private、protected</code>），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</p><h3 id="4-什么是多态？多态如何实现？-star-5"><a href="#4-什么是多态？多态如何实现？-star-5" class="headerlink" title="4 什么是多态？多态如何实现？ :star:5"></a>4 什么是多态？多态如何实现？ :star:5</h3><p><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 <code>virtual</code> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p><p><strong>实现方法</strong>：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><p><strong>实现过程</strong>：</p><ol><li>在类中用 <code>virtual</code> 关键字声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（<u>虚函数表和类对应的，虚表指针是和对象对应</u>）；</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// Derive::fun() 调用派生类中的虚函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>基类的虚函数表如下</strong>：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB6.png" width="500px" /></div><p><strong>派生类的对象虚函数表如下</strong>：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB7.png" width="700px" /></div><p>解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 <code>Derive::f()</code> 进行调用。</p><p>补充：</p><ol><li>如果使用虚函数，父类指针指向子类对象并调用对象方法时，使用的是子类的方法;</li><li>如果未使用虚函数，则是普通的重写，则父类指针指向子类对象时，使用的是父类的方法（与指针类型看齐）</li><li>父类指针能指向子类对象，但是子类指针不能指向父类对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_2语言对比</title>
    <link href="/2021/09/02/C++%E9%9D%A2%E8%AF%95_2%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/"/>
    <url>/2021/09/02/C++%E9%9D%A2%E8%AF%95_2%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>C++11, C 和 Python 以及 Java 的区别与联系。</p><span id="more"></span><h3 id="1-C-11-新特性-star-4"><a href="#1-C-11-新特性-star-4" class="headerlink" title="1 C++ 11 新特性 :star:4"></a>1 C++ 11 新特性 :star:4</h3><p>说明：C++11 的新特性有很多，从面试的角度来讲，如果面试官问到该问题，常以该问题作为引子，对面试者提到的知识点进行深入展开提问。面试者尽可能的列举常用的并且熟悉的特性，尽可能的掌握相关原理，下文只是对相关知识点进行了简单的阐述，有关细节还需要结合相关知识点的相关问题。</p><p>下面对常用的做一下总结：</p><ol><li><p><code>auto</code> 类型推导</p><p><code>auto</code> 关键字：自动类型推导，编译器会在 <strong>编译期间</strong> 通过初始值推导出变量的类型，通过 <code>auto</code> 定义的变量<strong>必须有初始值</strong>。</p><p><code>auto</code> 关键字基本的使用语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> var = val1 + val2; <span class="hljs-comment">// 根据 val1 和 val2 相加的结果推断出 var 的类型，</span><br></code></pre></div></td></tr></table></figure><p>注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p></li><li><p><code>decltype</code> 类型推导<br><code>decltype</code> 关键字：<code>decltype</code> 是“declare type”的缩写，译为“声明类型”。和 <code>auto</code> 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 <code>auto</code> 。<code>decltype</code> 作用是选择并返回操作数的数据类型。</p><p>区别：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> var = val1 + val2; <br><span class="hljs-keyword">decltype</span>(val1 + val2) var1 = <span class="hljs-number">0</span>; <br></code></pre></div></td></tr></table></figure><ul><li><code>auto</code> 根据 = 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；<code>decltype</code> 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</li><li><code>auto</code> 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 <code>decltype</code> 不要求，定义变量的时候可初始化也可以不初始化。</li></ul></li><li><p><code>lambda</code> 表达式</p><p><code>lambda</code> 表达式，又被称为 <code>lambda</code> 函数或者 <code>lambda</code> 匿名函数。</p><p><code>lambda</code>匿名函数的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[capture list] (parameter list) -&gt; <span class="hljs-keyword">return</span> type<br>&#123;<br>   function body;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">//对 a 数组中的元素进行升序排序</span><br>    <span class="hljs-built_in">sort</span>(arr, arr+<span class="hljs-number">4</span>, [=](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; <span class="hljs-keyword">bool</span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; );<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : arr)&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>范围 <code>for</code> 语句</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression)&#123;<br>    statement<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数的含义：</p><ul><li>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、<code>vector</code> ，<code>string</code> 等，这些类型的共同特点是拥有能返回迭代器的 <code>beign</code>、<code>end</code> 成员。</li><li>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 <code>auto</code> 类型说明符。</li></ul></li><li><p>右值引用</p><p>右值引用：绑定到右值的引用，用 <code>&amp;&amp;</code> 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">int</span> &amp;l_var = var;<br>    <span class="hljs-keyword">int</span> &amp;&amp;r_var = var; <span class="hljs-comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上</span><br><br>    <span class="hljs-keyword">int</span> &amp;&amp;r_var2 = var + <span class="hljs-number">40</span>; <span class="hljs-comment">// 正确：将 r_var2 绑定到求和结果上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>标准库 <code>move()</code> 函数</p><p><code>move()</code> 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。</p></li><li><p>智能指针</p></li><li><p><code>delete</code> 函数和 <code>default</code> 函数</p><ul><li><code>delete</code> 函数：<code>= delete</code> 表示该函数不能被调用。</li><li><code>default</code> 函数：<code>= default</code> 表示编译器生成默认的函数，例如：生成默认的构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 表示使用默认的构造函数</span><br>~<span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">// 表示使用默认的析构函数</span><br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 表示类的对象禁止拷贝构造</span><br>A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 表示类的对象禁止拷贝赋值</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A ex1;<br>A ex2 = ex1; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(const A&amp;)&#x27;</span><br>A ex3;<br>ex3 = ex1; <span class="hljs-comment">// error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="2-C-和-C-的区别-star-2"><a href="#2-C-和-C-的区别-star-2" class="headerlink" title="2 C 和 C++ 的区别 :star:2"></a>2 C 和 C++ 的区别 :star:2</h3><p><strong>面向对象和面向过程</strong>：</p><ul><li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li><li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li></ul><p><strong>区别和联系</strong>：</p><ul><li><p>语言自身：</p><p>C 语言是面向过程的编程，它最重要的特点是函数，通过 <code>main</code> 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。</p><p>C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 <code>main</code> 函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</p></li><li><p>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域。C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</p></li></ul><ul><li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 <code>const</code> 关键字，等等。</li></ul><ul><li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li></ul><h3 id="3-Java-和-C-的区别-star-3"><a href="#3-Java-和-C-的区别-star-3" class="headerlink" title="3 Java 和 C++ 的区别 :star:3"></a>3 Java 和 C++ 的区别 :star:3</h3><p><strong>语言特性上区别较大</strong>：</p><ul><li>指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li><li>多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li><li>数据类型和类：Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li></ul><p><strong>垃圾回收</strong>：</p><ul><li>Java 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。</li><li>Java 所有的对象都是用 <code>new</code> 操作符建立在内存堆栈上，类似于 C++ 中的 <code>new</code> 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 Java 中的内存回收是以<strong>线程</strong>的方式在<strong>后台运行</strong>的，利用空闲时间。</li></ul><p><strong>应用场景</strong>：</p><ul><li>Java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持。</li><li>C++ 可以直接编译成可执行文件，运行效率比 Java 高。</li><li>Java 主要用来开发 Web 应用。</li><li>C++ 主要用在嵌入式开发、网络、并发编程的方面。</li></ul><h3 id="4-Python-和-C-的区别-star-3"><a href="#4-Python-和-C-的区别-star-3" class="headerlink" title="4 Python 和 C++ 的区别 :star:3"></a>4 Python 和 C++ 的区别 :star:3</h3><p><strong>区别</strong>：</p><ul><li>语言自身：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li><li>运行效率：C++ 运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机 CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li><li>开发效率：Python 开发效率高。原因：Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li><li>书写格式和语法不同：Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_1编译内存相关</title>
    <link href="/2021/09/01/C++%E9%9D%A2%E8%AF%95_1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/01/C++%E9%9D%A2%E8%AF%95_1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>:star: <strong>编译内存相关的主要内容</strong>：C++ 程序的编译过程、内存以及头文件的一些知识点，重点在内存方面进行展开，包括内存的分区、内存对齐、内存泄漏、内存泄漏的防止方法、现有的检测内存泄漏的工具等等。</p><span id="more"></span><h3 id="1-C-程序编译过程-star-4"><a href="#1-C-程序编译过程-star-4" class="headerlink" title="1 C++ 程序编译过程 :star:4"></a>1 C++ 程序编译过程 :star:4</h3><p>编译过程分为四步：编译（编译预处理、编译、优化），汇编，链接。</p><ul><li><strong>编译预处理</strong>：处理以 <code>#</code> 开头的指令；</li><li><strong>编译、优化</strong>：将源码 <code>.cpp</code> 文件翻译成 <code>.s</code> 汇编代码；</li><li><strong>汇编</strong>：将汇编代码 <code>.s</code> 翻译成机器指令 <code>.o</code> 文件；</li><li><strong>链接</strong>：汇编程序生成的目标文件，即 <code>.o</code> 文件不会立即执行。<u>因为可能会出现</u>：<code>.cpp</code> 文件中的函数引用了另一个 <code>.cpp</code> 文件中定义的符号或者调用了某个库文件中的函数。<strong>链接的目的是</strong>：将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 <code>.exe</code> 文件。</li></ul><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB1.png" width="550px" /></div><p>两种链接：</p><ol><li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ol><p>优缺点：</p><ol><li><strong>静态链接</strong>：<strong>优点</strong>：执行时的运行<u>速度快</u>。因为它会将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库（可执行程序具备了程序运行的所有内容）。<strong>缺点</strong>：<u>浪费空间</u>，链接的时候可能会对同一个目标文件进行多次链接（库或者目标代码）；而且如果目标文件进行了更新，则整个程序需要重新进行编译链接生成可执行程序（<u>更新困难</u>）；</li><li><strong>动态链接</strong>：<strong>优点</strong>：节省内存、更新方便。<strong>缺点</strong>：每次运行程序都需要执行链接，相比于静态链接有一定的性能损失。</li></ol><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB2.png" width="800px" /></div><h3 id="2-C-内存管理-star-5"><a href="#2-C-内存管理-star-5" class="headerlink" title="2 C++ 内存管理 :star:5"></a>2 C++ 内存管理 :star:5</h3><p><strong>C++ 内存分区</strong>：栈、堆、全局/静态存储区、常量存储区、代码区。</p><ul><li><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li><li><strong>堆</strong>：动态申请的内存空间，就是由 <code>malloc</code> 分配的内存块，由程序员控制它的分配和释放。如果程序执行结束还没有释放，操作系统会自动回收。</li><li><strong>全局区/静态存储区</strong>（<code>.bss</code> 段和 <code>.data</code> 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放。在 C 语言中，未初始化的放在 <code>.bss</code> 段中，初始化的放在 <code>.data</code> 段中，而 C++ 中不再区分。</li><li><strong>常量存储区</strong>（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</li><li><strong>代码区</strong>（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li></ul><p>说明：</p><ul><li>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 —&gt; .data 段 —&gt; .bss 段 —&gt; 堆 —&gt; unused —&gt; 栈 —&gt; env</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> g_var = <span class="hljs-number">0</span>; <span class="hljs-comment">// g_var 在全局区（.data 段）</span><br><span class="hljs-keyword">char</span> *gp_var;  <span class="hljs-comment">// gp_var 在全局区（.bss 段）</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var;                    <span class="hljs-comment">// var 在栈区</span><br>    <span class="hljs-keyword">char</span> *p_var;                <span class="hljs-comment">// p_var 在栈区</span><br>    <span class="hljs-keyword">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;         <span class="hljs-comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">char</span> *p_var1 = <span class="hljs-string">&quot;123456&quot;</span>;    <span class="hljs-comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var = <span class="hljs-number">0</span>;       <span class="hljs-comment">// s_var 为静态变量，存在静态存储区（.data 段）</span><br>    p_var = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配得来的 10 个字节的区域在堆区</span><br>    <span class="hljs-built_in">free</span>(p_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB3.png" width="550px" /></div><center>csapp,Linux虚拟内存系统地址空间分配</center><h3 id="3-栈和堆的区别-star-5"><a href="#3-栈和堆的区别-star-5" class="headerlink" title="3 栈和堆的区别 :star:5"></a>3 栈和堆的区别 :star:5</h3><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB4.png" width="750px" /></div><p>C++ 堆内存为什么不连续？</p><ol><li>堆的内存是分配是我们 malloc 空间时，申请的空间大小不一样造成了碎片。使用 malloc 的时候系统内部有一个空闲内存映射表，系统会自动查找空闲内存中第一个合适大小的空间分配；</li></ol><h3 id="4-变量的区别-star-3"><a href="#4-变量的区别-star-3" class="headerlink" title="4 变量的区别 :star:3"></a>4 变量的区别 :star:3</h3><p><strong>全局变量、局部变量、静态全局变量、静态局部变量的区别？</strong></p><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p><p><u>从作用域看：</u></p><ul><li><strong>全局变量</strong>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</li><li><strong>静态全局变量</strong>：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li><li><strong>局部变量</strong>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li><li><strong>静态局部变量</strong>：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li></ul><p><u>从分配内存空间看：</u></p><ul><li>静态存储区：全局变量，静态局部变量，静态全局变量。</li><li>栈：局部变量。</li></ul><p>说明：</p><ul><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li><li>静态变量和全局变量的区别：静态变量用 <code>static</code> 告知编译器，自己仅仅在变量的作用范围内可见。</li></ul><h3 id="5-全局变量定义在头文件中有什么问题？-star-1"><a href="#5-全局变量定义在头文件中有什么问题？-star-1" class="headerlink" title="5 全局变量定义在头文件中有什么问题？:star:1"></a>5 全局变量定义在头文件中有什么问题？:star:1</h3><p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p><blockquote><p>参考<a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">详细介绍</a></p></blockquote><h3 id="6-对象创建限制在堆或栈-star-3"><a href="#6-对象创建限制在堆或栈-star-3" class="headerlink" title="6 对象创建限制在堆或栈 :star:3"></a>6 对象创建限制在堆或栈 :star:3</h3><p><strong>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</strong></p><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p><ul><li><strong>静态建立</strong>：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：<code>A a</code>;</li><li><strong>动态建立</strong>：使用 <code>new</code> 关键字在堆空间上创建对象，底层首先调用 <code>operator new()</code> 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li></ul><p><u>限制对象只能建立在堆上：</u></p><ul><li>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 <code>new</code> 来建立对象。但是由于 <code>new</code> 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 <code>new</code> 创建对象了。因此，这种方法不可行。</li></ul><ul><li><p>解决方法 1：</p><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>() &#123; &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>该方法存在的问题：</p><ul><li>用 <code>new</code> 创建的对象，通常会使用 <code>delete</code> 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 <code>destory()</code> 函数，用来释放 new 创建的对象。</li><li>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 <code>virtual</code>，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</li></ul></li><li><p>解决方法2：</p><p>构造函数设置为 <code>protected</code>，并提供一个 <code>public</code> 的静态函数来完成构造，而不是在类的外部使用 <code>new</code> 构造；将析构函数设置为 <code>protected</code>。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 <code>create()</code> 函数在堆上创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A *<span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><p><u>限制对象只能建立在栈上：</u></p><ul><li><p>解决方法：将 <code>operator new()</code> 设置为私有。原因：当对象建立在堆上时，是采用 <code>new</code> 的方式进行建立，其底层会调用 <code>operator new()</code> 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="7-内存对齐-star-2"><a href="#7-内存对齐-star-2" class="headerlink" title="7 内存对齐 :star:2"></a>7 内存对齐 :star:2</h3><p><strong>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</strong></p><p><strong>内存对齐</strong>：编译器将程序中的每个“数据单元” 安排在字的整数倍的地址指向的内存之中</p><p><strong>内存对齐的原则</strong>：</p><ol><li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的，对齐基数默认是 8</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">short</span> var; <span class="hljs-comment">// 2 字节</span><br>    <span class="hljs-keyword">int</span> var1;  <span class="hljs-comment">// 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8</span><br>    <span class="hljs-keyword">long</span> var2; <span class="hljs-comment">// 12 字节 8 + 4 (long) = 12</span><br>    <span class="hljs-keyword">char</span> var3; <span class="hljs-comment">// 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16</span><br>    string s;  <span class="hljs-comment">// 48 字节 16 + 32 (string) = 48</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">short</span> var;<br>    <span class="hljs-keyword">int</span> var1;<br>    <span class="hljs-keyword">long</span> var2;<br>    <span class="hljs-keyword">char</span> var3;<br>    string s;<br>    A ex1;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var) &lt;&lt; endl;  <span class="hljs-comment">// 2 short</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var1) &lt;&lt; endl; <span class="hljs-comment">// 4 int</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var2) &lt;&lt; endl; <span class="hljs-comment">// 4 long</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var3) &lt;&lt; endl; <span class="hljs-comment">// 1 char</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s) &lt;&lt; endl;    <span class="hljs-comment">// 32 string</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl;  <span class="hljs-comment">// 48 struct</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>进行内存对齐的原因</strong>：（主要是硬件设备方面的问题）</p><ol><li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p><strong>内存对齐的优点</strong>：</p><ol><li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><h3 id="8-类的大小-star-2"><a href="#8-类的大小-star-2" class="headerlink" title="8 类的大小 :star:2"></a>8 类的大小 :star:2</h3><p><strong>类大小的计算</strong></p><p>说明：类的大小是指类的实例化对象的大小，用 <code>sizeof</code> 对类型名操作时，结果是该类型的对象的大小。</p><p><strong>计算原则</strong>：</p><ul><li>遵循结构体的对齐原则。</li><li>与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li>虚函数对类的大小有影响，是因为虚函数表指针的影响。</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响。</li><li>空类的大小是一个特殊情况，空类的大小为 1，当用 <code>new</code> 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li></ul><p><strong>实例1</strong>：简单情况和空类情况</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                    <span class="hljs-comment">// 不影响类的大小</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    B ex2;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 12 字节</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex2) &lt;&lt; endl; <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>实例：</strong>带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                      <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::f&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::g&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::h&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    A *p;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl;   <span class="hljs-comment">// 8 字节 注意：指针所占的空间和指针指向的数据类型无关</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 24 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-什么是内存泄露-star-4"><a href="#9-什么是内存泄露-star-4" class="headerlink" title="9 什么是内存泄露 :star:4"></a>9 什么是内存泄露 :star:4</h3><p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p><p>进一步解释：</p><ul><li><p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p></li><li><p>常指<u>堆内存泄漏</u>，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p></li><li><p>使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>new</code>  等分配内存时，使用完后要调用相应的 <code>free</code> 或 <code>delete</code> 释放内存，否则这块内存就会造成内存泄漏。</p></li><li><p>指针重新赋值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">char</span> *p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>p = np;<br></code></pre></div></td></tr></table></figure><p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p></li></ul><p>大概分为这么3类内存泄漏：</p><ul><li>堆内存泄漏：new/mallc分配内存，未使用对应的delete/free回收；</li><li>系统资源泄漏， Bitmap, handle, socket 等资源未释放；</li><li>没有将基类析构函数定义称为虚函数，（使用基类指针或者引用指向派生类对象时）派生类对象释放时将不能正确释放派生对象部分。</li></ul><h3 id="10-怎么防止内存泄漏？内存泄漏检测工具的原理？-star-3"><a href="#10-怎么防止内存泄漏？内存泄漏检测工具的原理？-star-3" class="headerlink" title="10 怎么防止内存泄漏？内存泄漏检测工具的原理？:star:3"></a>10 怎么防止内存泄漏？内存泄漏检测工具的原理？:star:3</h3><p><strong>防止内存泄漏的方法：</strong></p><ol><li><p><strong>内部封装</strong>：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造函数中分配内存空间</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>    &#125;;<br>    ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 析构函数中释放内存空间</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>            p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况，请看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = ex; <br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单解释：对于 <code>fun1</code> 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间，但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过<strong>增加计数机制</strong>来避免这种情况，看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br>    <span class="hljs-keyword">int</span> *p_count; <span class="hljs-comment">// 计数变量</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 在构造函数中申请内存</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>        p_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>        *p_count = <span class="hljs-number">1</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;temp)<br>    &#123;<br>        p = temp.p;<br>        p_size = temp.p_size;<br>        p_count = temp.p_count;<br>        (*p_count)++; <span class="hljs-comment">// 复制时，计数变量 +1</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        (*p_count)--; <span class="hljs-comment">// 析构时，计数变量 -1</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl; <br><br>        <span class="hljs-keyword">if</span> (*p_count == <span class="hljs-number">0</span>) <span class="hljs-comment">// 只有当计数变量为 0 的时候才会释放该块内存空间</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;buf is deleted&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <br>            &#123;<br>                <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>                p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>                <span class="hljs-keyword">if</span> (p_count != <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    <span class="hljs-keyword">delete</span> p_count;<br>                    p_count = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br><br>    A ex1 = ex; <span class="hljs-comment">// 此时计数变量会 +1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;ex1.p = &quot;</span> &lt;&lt; ex1.<span class="hljs-built_in">GetPointer</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出结果：<br><span class="hljs-comment">// count is : 1</span><br><span class="hljs-comment">// Test</span><br><span class="hljs-comment">// count is : 2</span><br><span class="hljs-comment">// ex1.p = Test</span><br><span class="hljs-comment">// count is : 1</span><br><span class="hljs-comment">// count is : 0</span><br><span class="hljs-comment">// buf is deleted</span><br></code></pre></div></td></tr></table></figure><p>解释下：程序运行结果的倒数 2、3 行是调用两次析构函数时进行的操作，在第二次调用析构函数时，进行内存空间的释放，从而会有倒数第 1 行的输出结果。</p></li><li><p><strong>智能指针</strong><br>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</p></li></ol><p><strong>内存泄漏检测工具的实现原理：</strong></p><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB5.png" width="700px" /></div><p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li><p>Massif：检查程序中堆栈使用中出现的问题。</p></li><li><p>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</p></li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li></ul><p>检测原理：</p><ul><li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li><li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li></ul><h3 id="11-智能指针有哪几种？智能指针的实现原理？-star-5"><a href="#11-智能指针有哪几种？智能指针的实现原理？-star-5" class="headerlink" title="11 智能指针有哪几种？智能指针的实现原理？ :star:5"></a>11 智能指针有哪几种？智能指针的实现原理？ :star:5</h3><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p><p>C++11 中智能指针包括以下三种：</p><ul><li>共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li><li>独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</li><li>弱指针（weak_ptr）：指向 <code>share_ptr</code> 指向的对象，能够解决由 <code>shared_ptr</code> 带来的循环引用问题。</li></ul><p><strong>智能指针的实现原理</strong>： 计数原理。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 代码有问题</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br><span class="hljs-keyword">private</span> : <br>T *_ptr;<br><span class="hljs-keyword">size_t</span> *_count;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) : _ptr(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (_ptr)<br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">SmartPtr</span>()<br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">SmartPtr</span>(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 拷贝构造：计数 +1</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>&#125;<br>&#125;<br><br>SmartPtr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 赋值运算符重载 </span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) <span class="hljs-comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span><br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++; <span class="hljs-comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>T &amp;<span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>&#125;<br><br>T *<span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;count;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="12-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？-star-2"><a href="#12-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？-star-2" class="headerlink" title="12 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？:star:2"></a>12 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？:star:2</h3><p>借助 <code>std::move()</code> 可以实现将一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，其目的是实现所有权的转移。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// A 作为一个类 </span><br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::unique_ptr&lt;A&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br></code></pre></div></td></tr></table></figure><p>可以看成ptr1变成了一个野指针。unique_ptr采用的是所有权的概念，一个指针对象赋值给另一个后，原来的智能指针不再指向之前它指向的内存。不过由于原指针会变成野指针，所以一般直接用一个智能指针对象赋值给另一个是不被允许的，编译阶段就会报错。不过由于使用了move，所以对编译器作出了不再使用ptr1的值的承诺，可以避免解引用野指针带来的错误，因此可以通过编译。</p><h3 id="13-使用智能指针会出现什么问题？怎么解决？-star-5"><a href="#13-使用智能指针会出现什么问题？怎么解决？-star-5" class="headerlink" title="13 使用智能指针会出现什么问题？怎么解决？:star:5"></a>13 使用智能指针会出现什么问题？怎么解决？:star:5</h3><p><strong>智能指针可能出现的问题</strong>：循环引用</p><p>在如下例子中定义了两个类 <code>Parent</code>、<code>Child</code>，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>循环引用的解决方法</strong>： <code>weak_ptr</code></p><p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p><ul><li><code>weak_ptr</code> 对被 <code>shared_ptr</code> 管理的对象存在 <strong>非拥有性（弱）引用</strong>，在访问所引用的对象前必须先转化为 <code>shared_ptr</code>；</li><li><code>weak_ptr</code>用来打断 <code>shared_ptr</code> 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），<code>shared_ptr</code> 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li><li><code>weak_ptr</code> 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 <code>weak_ptr</code> 跟踪该对象；需要获得所有权时将其转化为 <code>shared_ptr</code>，此时如果原来的 <code>shared_ptr</code> 被销毁，则该对象的生命期被延长至这个临时的 <code>shared_ptr</code> 同样被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//shared_ptr&lt;Child&gt; ChildPtr;</span><br>    weak_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//new shared_ptr</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">lock</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>weak_ptr</code> 的实现：</p><ol><li>说的高大上就是 <code>weak_ptr</code> 只能拥有 <code>shared_ptr</code> 的观测权，没有使用权，想要使用的时候，就将 <code>weak_ptr</code> 转为 <code>shared_ptr</code> ，这个时候新产生的 <code>shared_ptr</code> 对象是不会引起循环引用的问题，因为它在它的作用域结束后肯定要释放的，和 <code>weak_ptr</code> 所在的类对象没有任何关系了。</li><li>有这样的想法也很正常，既然都使用 <code>shared_ptr</code> 会出现循环引用的问题，所以只要将其中某一条引用链断了就可以了，自然而然可以想到使用一个中间产品（<code>weak_ptr</code>），并且提供 <code>weak_ptr</code> 像 <code>shared_ptr</code> 转换的方法即可。</li><li>查看MSVC的memory文件，可以看到 <code>shared_ptr</code> 和 <code>weak_ptr</code> 都是继承于 <code>ptr_base</code> 的，在 <code>ptr_base</code> 中存放了资源指针 <code>_Ptr</code> 以及引用计数指针 <code>_Rep</code>，而 <code>shared_ptr</code> 类中定义了一些对资源 <code>_Ptr</code> 操作的方法，但是在 <code>weak_ptr</code> 中，只有“资源观测权”的方法：</li></ol><p><strong>expired（查看资源是否还存在）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD <span class="hljs-keyword">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return true if resource no longer exists</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">use_count</span>() == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>lock(将weak_ptr构造为shared_ptr)：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// convert to shared_ptr</span><br>        shared_ptr&lt;_Ty&gt; _Ret;<br>        (<span class="hljs-keyword">void</span>) _Ret._Construct_from_weak(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> (_Ret);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
