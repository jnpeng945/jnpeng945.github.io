<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux下vim与tmux的使用</title>
    <link href="/2021/09/10/vim%E4%B8%8Etmux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/10/vim%E4%B8%8Etmux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><code>vim</code> 编辑器是在终端运行的文本代码编辑器。</p><p><code>tmux</code> 是 linux 中一种管理窗口的程序，支持多标签、分割窗口以及窗口组随时存储和恢复的功能。</p><span id="more"></span><h2 id="Vim-使用指南"><a href="#Vim-使用指南" class="headerlink" title="Vim 使用指南"></a>Vim 使用指南</h2><p><code>vim</code> 编辑器是在终端运行的文本代码编辑器。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sequence">Title: 标题：Vim 编辑器三种模式切换<br>命令模式-&gt;插入模式: 输入 i<br>Note left of 命令模式: 进入 vim 的初始状态<br>Note right of 底线命令模式: 保存退出:wq，退出:q，强制退出:q!<br>插入模式-&gt;命令模式: ESC<br>命令模式-&gt;底线命令模式: 输入:<br>底线命令模式-&gt;命令模式: 命令以回车结束运行<br># participant C<br># Note right of C: 没人陪我玩<br></code></pre></div></td></tr></table></figure><pre><code class=" mermaid">graph LRA[修改vim配置文件]--&gt; B[配置相应命令]</code></pre><p>一般我们可以在 <code>github</code> 上找别人配置好的 <code>.vimrc</code>  文件。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim ~/.vimrc<span class="hljs-comment">#在当前用户的根目录下新建 .vimrc 文件</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 底线命令模式输入以下命令</span><br><span class="hljs-meta">$</span><span class="bash"> syntax on<span class="hljs-comment"># 语法高亮</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span> number<span class="hljs-comment"># 设置行号</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span> nonumber<span class="hljs-comment"># 取消行号设置</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置好 vim 配置文件之后，保存退出之后，下次再进入就自动设置了语法高亮并且设置了行号</span><br></code></pre></div></td></tr></table></figure><p>常用的 <code>vim</code> 快捷键</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">h（左） j（下） k（上） l （右）<br>w# 每次跳一个单词<br>b# 往回跳<br>ctrl + f# forword 往下翻页<br>ctrl + b# 往上翻页<br>88gg# 跳到 88 行<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 往下，往上跳指定行</span> <br>10j# 往下跳 10 行<br>10k# 往上跳 10 行<br><br>/[内容]# 查找内容 <br>按下 n 键可以跳到下一个查找的目标结果，shift + n 跳到上一个目标结果<br><br>cc# 剪贴当前行<br>c2c# 剪贴底下两行<br>u# 撤销删除操作<br>pp# 粘贴刚刚剪贴的内容<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 批量选择</span><br><span class="hljs-meta">#</span><span class="bash"> 1. 命令模式中，按下 v 进入 visual 模式，然后搭配 hjkl（左下上右）键位使用，进行批量选择。</span><br><span class="hljs-meta">#</span><span class="bash"> 2. 搭配 c（剪贴） p（粘贴） u（撤销）键位使用</span><br>yy# 复制当前行内容<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 自动补全</span><br>ctrl + n# 出现选项之后，按下 enter<br></code></pre></div></td></tr></table></figure><p>:star: <code>vim</code> 插件管理器 + <strong>vim 自动补全插件</strong></p><ul><li>预先安装 <code>git</code> 和 <code>curl</code></li><li>安装 vim plug 插件（vim 插件管理软件），在 github 上下载；<a href="https://github.com/junegunn/vim-plug">链接</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br></code></pre></div></td></tr></table></figure><ul><li>修改 <code>~/.vimrc</code> 文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 末尾添加</span><br>call plug#begin()<br>Plug &#x27;scrooloose/nerdtree&#x27;# 添加的插件名字<br>call plug#end()<br></code></pre></div></td></tr></table></figure><ul><li>任意打开一个文件，假设我们 <code>vim code.cpp</code>，然后在 <code>code.cpp</code> 的底线命令模式下输入 <code>:PlugInstall</code></li></ul><blockquote><p><a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a></p><p><a href="https://vimawesome.com/plugin/nerdtree-red">https://vimawesome.com/plugin/nerdtree-red</a></p></blockquote><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E4%B8%8Bvim%E4%BD%BF%E7%94%A8_1.png" width = "600px" /></div><p>:star: 上面所示我们已经安装了一个插件 <code>NERDTree</code> ，使用方式：</p><ol><li><p>首先随意打开一个文件，假设打开 <code>vim code.c</code> </p></li><li><p>输入 <code>:NERDTree</code>，实现像目录一样浏览系统中的文件</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换左右两边窗口</span><br>按两次 ctrl + w<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 打开该文件</span><br>Enter<br></code></pre></div></td></tr></table></figure><p>:star: 每次使用 <code>vim</code> 都打开 <code>NERDTree</code> 插件的解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Just write this line to your .vimrc :</span><br>autocmd VimEnter * NERDTree<br></code></pre></div></td></tr></table></figure><blockquote><p><a href="https://stackoverflow.com/questions/3788903/how-to-start-vim-with-nerd-tree-opened-automatically#">execute nerdtree automatically</a></p></blockquote><p>:star: 删除插件的方法</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">PlugClean<br></code></pre></div></td></tr></table></figure><h2 id="Tmux-使用指南"><a href="#Tmux-使用指南" class="headerlink" title="Tmux 使用指南"></a>Tmux 使用指南</h2><p><code>tmux</code> 是 linux 中一种管理窗口的程序，支持多标签、分割窗口以及窗口组随时存储和恢复的功能。<code>tmux</code> 的主要元素分为三层：</p><ul><li><em>Session</em> 一组窗口的集合， 通常用来概括同一个任务。<em>session</em> 可以有自己的名字便于任务之间的切换。</li><li><em>Window</em> 单个可见窗口。<em>Windows</em> 有自己的编号，也可以认为和 ITerm2 中的 <em>Tab</em> 类似。</li><li><em>Pane</em> 窗格，被划分成小块的窗口，类似于 <em>Vim</em> 中 C-w +v 后的效果。</li></ul><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E4%B8%8Btmux%E4%BD%BF%E7%94%A8_1.png" width = "500px"/></div><p><code>tmux</code>：即使关闭 tmux，下次重新 attch 时，之前的东西还在服务器后台运行。为便于表述我们定义 <code>pre = ctrl + b</code> ，实际上我们使用时一般会修改 <code>tmux</code> 配置文件 <code>vim ~/.tmux.conf</code>，将快捷键 <code>ctrl+b</code> 改为 <code>ctrl+a</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">### panes</span><br>pre + %<span class="hljs-comment"># 水平分割 pane</span><br>pre + <span class="hljs-string">&quot;# 垂直分割 pane</span><br><span class="hljs-string">exit# 退出pane</span><br><span class="hljs-string">pre + z# 放大当前的 pane</span><br><span class="hljs-string">pre + z# 复原之前的 pane 状态(缩小)</span><br><span class="hljs-string">pre + 上下左右# 切换 pane</span><br><span class="hljs-string">alt + 上下左右# 切换 pane（这个需要修改配置文件）</span><br><span class="hljs-string"></span><br><span class="hljs-string">### windows</span><br><span class="hljs-string">pre + c# 创建一个新的 window</span><br><span class="hljs-string">pre + 数字1，2# 在不同window 之间移动</span><br><span class="hljs-string">pre + &amp;# 关闭当前 window</span><br><span class="hljs-string"># 重命名window，创建一个新的 window 之后，除了数字编号不同外，window 名称都是一样的</span><br><span class="hljs-string">pre + ,# 更改 window 名称</span><br><span class="hljs-string"></span><br><span class="hljs-string">### session</span><br><span class="hljs-string">tmux ls# 查看所有的 session(正常运行显示 attach)</span><br><span class="hljs-string">pre + $# 每个 session 一般对应于一个 project</span><br><span class="hljs-string">tmux new -s [名字]# 创建 session 时直接命名</span><br><span class="hljs-string">pre + d# 退出session（挂起）</span><br><span class="hljs-string">tmux a -t [名字]# 重新连接某个session</span><br><span class="hljs-string">tmux a# 仅有一个session 时这是最快的连接方式</span><br><span class="hljs-string">tmux kill-session -a -t [名字] # 删除[名字]以外的session</span><br></code></pre></div></td></tr></table></figure><p>从 <code>tmux</code> 中往外复制东西的方法：</p><p>先按住 <code>shift</code> 不放，用鼠标选中复制的内容，松开 <code>shift</code> ，再按 <code>ctrl+insert</code> 复制；然后在电脑上按 <code>shift+insert</code> 粘贴。 </p><p>常用的 <code>tmux</code> 配置，<code>vim ~/.tmux.conf</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Send prefix: ctr + b 改为 ctr + a</span><br>set-option -g prefix C-a<br>unbind-key C-a<br>bind-key C-a send-prefix<br><br><span class="hljs-comment"># Use Alt-arrow keys to switch panes</span><br><span class="hljs-comment"># 不用 prefix，直接 alt + 箭头在 pane 之间 switch</span><br><span class="hljs-built_in">bind</span> -n M-Left select-pane -L<br><span class="hljs-built_in">bind</span> -n M-Right select-pane -R<br><span class="hljs-built_in">bind</span> -n M-Up select-pane -U<br><span class="hljs-built_in">bind</span> -n M-Down select-pane -D<br><br><span class="hljs-comment"># Shift arrow to switch windows</span><br><span class="hljs-comment"># 不用按prefix，直接用shift+箭头在window之间switch</span><br><span class="hljs-built_in">bind</span> -n S-Left previous-window<br><span class="hljs-built_in">bind</span> -n S-Right next-window<br><br><span class="hljs-comment"># Mouse mode</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Set easier window split keys</span><br>bind-key v split-window -h<br>bind-key h split-window -v<br><br><span class="hljs-comment"># Easy config reload</span><br>bind-key r source-file ~/.tmux.conf \; display-message <span class="hljs-string">&quot;tmux.conf reloaded&quot;</span><br></code></pre></div></td></tr></table></figure><p>更改了 <code>.tmux.conf</code> 后，在 <code>tmux</code> 里的快捷键没有变化。<code>tmux</code> 只有在新建 <em>session</em> 的时候，才会去找 <code>tmux.conf</code> 文件。</p><p>所以，之前创建的 <em>session</em> 都没有参考 <code>tmux.conf</code>， 所以可以用<code>tmux lstmux kill-session -a</code> 仅仅保留当前 <em>session</em>。再删除当前 <code>session</code>  <code>tmux kill-session -t py27</code>。这下删除了所有创建好的 <em>session</em>。</p><blockquote><p><a href="https://www.jianshu.com/p/fd3bbdba9dc9">tmux简洁教程及config关键配置</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p><p><a href="http://cenalulu.github.io/linux/tmux/">http://cenalulu.github.io/linux/tmux/</a></p><p><a href="https://harttle.land/2015/11/06/tmux-startup.html">https://harttle.land/2015/11/06/tmux-startup.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Vim tmux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的基本使用</title>
    <link href="/2021/09/09/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/09/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Git ：开源的分布式版本控制系统，可以有效、高速地处理项目的版本管理。</p><div class="table-container"><table><thead><tr><th style="text-align:center">集中式版本控制</th><th style="text-align:center">分布式版本控制</th></tr></thead><tbody><tr><td style="text-align:center">仅中心服务器拥有一份代码</td><td style="text-align:center">每个人的电脑上都有一份代码</td></tr><tr><td style="text-align:center">需要联网才能工作</td><td style="text-align:center">不需要联网也能工作</td></tr><tr><td style="text-align:center">新建分支相当于复制一份完整代码</td><td style="text-align:center">新建/合并分支速度很快</td></tr></tbody></table></div><span id="more"></span><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/image-20211129194208864.png" width = 700px></div><center>git 工作流</center><p>新建一个仓库 <code>workspace</code> 之后，当前目录就成了一个工作区，工作区下有一个隐藏目录 <code>.git</code> ，其属于 <code>Git</code> 的版本库。</p><p>版本库有一个 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p><div align = center><img src = "https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208195941661.png" width = 550px></div><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>创建本地仓库的克隆版本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> /path/to/repository<br></code></pre></div></td></tr></table></figure><p>克隆远端服务器上的仓库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> username@host:/path/to/repository<br></code></pre></div></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。</p><p>第一个是你的 <code>工作目录</code>，它持有实际文件；</p><p>第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；</p><p>最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>提出更改（把它们添加到暂存区）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add &lt;filename&gt;<br>$ git add *<br></code></pre></div></td></tr></table></figure><p>实际提交改动：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;代码提交信息&quot;</span><br></code></pre></div></td></tr></table></figure><p>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。将这些改动提交到远端仓库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push origin master<br></code></pre></div></td></tr></table></figure><p>可以把 <em>master</em> 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git remote add origin &lt;server&gt;<br></code></pre></div></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/image-20211129213001037.png" width = 550px></div><br><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -b feature_x<span class="hljs-comment"># 创建一个叫做“feature_x”的分支，并切换过去</span><br>$ git checkout master<span class="hljs-comment"># 切换回主分支</span><br>$ git branch -d feature_x<span class="hljs-comment"># 把新建的分支删掉</span><br><span class="hljs-comment"># 除非你将分支推送到远端仓库，不然该分支就是仅自己可见的</span><br>$ git push origin &lt;branch&gt;<br></code></pre></div></td></tr></table></figure></p><h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git pull<span class="hljs-comment"># 更新本地仓库获取（fetch） 并 合并（merge） 远端的改动</span><br>$ git merge &lt;branch&gt;<span class="hljs-comment"># 要合并其他分支到你的当前分支（例如 master）</span><br><span class="hljs-comment"># 此时可能出现冲突（conflicts），需要手动合并这些冲突（conflicts）</span><br>$ git add &lt;filename&gt;<span class="hljs-comment"># 改动后，将它们标记为合并成功</span><br>$ git diff &lt;source_branch&gt; &lt;target_branch&gt;<span class="hljs-comment"># 合并改动前，预览差异</span><br></code></pre></div></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git tag 1.0.0 1b2e1d63ff<span class="hljs-comment"># 创建一个叫做 1.0.0 的标签</span><br><span class="hljs-comment"># 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符</span><br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 获取提交 ID</span><br></code></pre></div></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><span class="hljs-comment"># 了解本地仓库的历史记录</span><br>$ git <span class="hljs-built_in">log</span> --author=bob<span class="hljs-comment"># 只看某一个人的提交记录</span><br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<span class="hljs-comment"># 一个压缩后的每一条提交记录只占一行的输出</span><br>$ git <span class="hljs-built_in">log</span> --graph --oneline --decorate --all<span class="hljs-comment"># ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span><br>$ git <span class="hljs-built_in">log</span> --name-status<span class="hljs-comment"># 看看哪些文件改变了</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">help</span><br></code></pre></div></td></tr></table></figure><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -- &lt;filename&gt;<br></code></pre></div></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><hr><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git fetch origin<br>$ git reset --hard origin/master<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简明指南</a></p><p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#git-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88">CSNotes-Git</a></p><p><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git(opens new window)</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 : Git 教程(opens new window)</a></p><p><a href="https://learngitbranching.js.org/">Learn Git Branching</a></p><p>Git 中文教程<a href="https://git-scm.com/book/zh/v2">文档地址</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2021/09/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/09/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本文将对 Linux 系统进行简要介绍，并总结概括 Linux 系统下常用命令。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><span id="more"></span><div class="table-container"><table><thead><tr><th></th><th>区别</th><th>联系</th></tr></thead><tbody><tr><td>Linux</td><td>开源；可移植性强；使用简单；个人或企业用户；</td><td>网络为核心的设计思想源于Unix</td></tr><tr><td>Unix</td><td>商业软件银行（IBM 的 AIX）；高端定制化应用；</td></tr></tbody></table></div><h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><p><strong>Linux 启动流程：</strong></p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211114165855.png" width = 700px></p><p><strong>内核引导</strong>：<code>BOIS</code> 自检并按照 <code>BIOS</code> 中设置的启动设备（硬盘）启动。</p><p><strong>运行</strong> <code>init</code> ：<code>init</code> 进程是系统所有进程的起点；</p><p><strong>运行级别</strong>：许多程序需要开机启动，Windows 系统中称为服务 <code>service</code>，Linux 系统中是守护进程 <code>daemon</code> 。<code>init</code> 进程任务之一就是去运行这些开机启动的程序。（Linux 系统服务器用作服务器时，需要启动 <code>Apache</code>）。运行级别就是针对不同场合设置不同的程序启动时机，Linux 系统中有 7 级。</p><p><strong>系统初始化</strong>：激活交换分区，检查磁盘，加载硬件模块等。</p><p><strong>用户登录系统</strong>：命令行、<code>ssh</code> 登录、图形界面；</p><p><strong>Linux 关机流程</strong>：</p><p><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211114170537.png" width = 500px></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ man<span class="hljs-comment"># 查看帮助文档</span><br>$ sync<span class="hljs-comment"># 将数据由内存同步到硬盘中。</span><br>$ shutdown<span class="hljs-comment">#关机指令</span><br>$ reboot<span class="hljs-comment">#重启 == shutdown –r now和init 6</span><br>$ halt<span class="hljs-comment">#关闭系统 == shutdown –h now 和 poweroff和 init 0</span><br></code></pre></div></td></tr></table></figure><hr><figure class="highlight bash"><figcaption><span>/</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">├── bin -&gt; usr/bin<span class="hljs-comment"># 常用的程序和指令</span><br>├── boot<span class="hljs-comment"># 启动 Linux 的内核文件，包括连接文件和镜像文件</span><br>├── dev<span class="hljs-comment"># Linux 外部设备</span><br>├── etc<span class="hljs-comment"># 系统的配置文件和子目录列表。更改将可能导致系统不能启动</span><br>├── home<span class="hljs-comment"># 普通用户的主目录</span><br>├── lib -&gt; usr/lib<span class="hljs-comment"># lib 基本代码库（C++库），基本动态连接共享库</span><br>├── lib32 -&gt; usr/lib32<br>├── lib64 -&gt; usr/lib64<br>├── libx32 -&gt; usr/libx32<br>├── lost+found<span class="hljs-comment"># 一般情况下是空的，当系统非法关机后，这里会存放一些文件</span><br>├── media<span class="hljs-comment"># 类似 Windows 的其他设备</span><br>├── mnt<span class="hljs-comment"># 共享文件夹（实现Windows和Linux虚拟机文件共享）</span><br>├── opt<span class="hljs-comment"># 默认为空，我们安装额外软件可以放在这个里面</span><br>├── proc<span class="hljs-comment"># 管理内存空间</span><br>├── root<span class="hljs-comment"># 系统管理员用户主目录</span><br>├── run<span class="hljs-comment"># 临时文件系统，存放系统启动以来的信息</span><br>├── sbin -&gt; usr/sbin<span class="hljs-comment"># 系统管理员才能用的程序和指令</span><br>├── srv<span class="hljs-comment"># 存放服务启动后需要提取的数据</span><br>├── swapfile<br>├── sys<span class="hljs-comment"># 内核源代码默认的放置目录</span><br>├── tmp<span class="hljs-comment"># 存放临时文件</span><br>├── usr<span class="hljs-comment"># unix shared resources，存放很多应用软件和文件</span><br>└── var<span class="hljs-comment"># 不断更改的文件，各种日志文件</span><br></code></pre></div></td></tr></table></figure><hr><p><strong>命令解析器</strong>：Linux 系统中提供了 <code>shell</code> （/bin/sh）、<code>bash</code>（/bin/bash）等，一般默认使用 <code>bash</code> 作为解析器。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tab<span class="hljs-comment"># 补齐命令，补齐路径，显示当前目录下的所有目录</span><br>$ clear<span class="hljs-comment"># 清屏</span><br>$ ctrl + l<span class="hljs-comment"># 清屏</span><br>$ ctrl + c<span class="hljs-comment"># 中断进程</span><br>$ ctrl + u<span class="hljs-comment"># 删除光标前所有内容</span><br>$ ctrl + k<span class="hljs-comment"># 删除光标后的所有内容</span><br></code></pre></div></td></tr></table></figure><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="ls-命令-–-显示指定目录下的内容及属性信息"><a href="#ls-命令-–-显示指定目录下的内容及属性信息" class="headerlink" title="ls 命令 – 显示指定目录下的内容及属性信息"></a>ls 命令 – 显示指定目录下的内容及属性信息</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ls [参数] 目录路径<br>$ ls -l<span class="hljs-comment"># 查看当前目录下的详细信息，功能等价于 ll 命令</span><br>$ ls -a<span class="hljs-comment"># 查看当前目录下的所有文件（包含隐藏文件）</span><br>$ ls -la <span class="hljs-comment"># 查看当前目录下的所有文件（包含隐藏文件）的详细信息</span><br>$ ls -lh<span class="hljs-comment"># 查看当前目录下的文件的详细信息（增加可读性，带单位）</span><br>$ ls --<span class="hljs-built_in">help</span><span class="hljs-comment"># 查看命令帮助文档</span><br></code></pre></div></td></tr></table></figure><h3 id="cd-命令-切换目录"><a href="#cd-命令-切换目录" class="headerlink" title="cd 命令 - 切换目录"></a>cd 命令 - 切换目录</h3><p>相对路径：不是以 <code>/</code> 开头的路径。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">.<span class="hljs-comment"># 表示当前目录</span><br>..<span class="hljs-comment"># 表示当前目录的上一级目录</span><br>~<span class="hljs-comment"># 表示当前用户的根目录，切记是当前用户</span><br><br>$ <span class="hljs-built_in">cd</span> ./bin<span class="hljs-comment"># 进入当前目录下的 bin 目录，功能等价于 cd bin/</span><br>$ <span class="hljs-built_in">cd</span> ../etc<span class="hljs-comment"># 进入和当前目录同级的 etc 目录</span><br></code></pre></div></td></tr></table></figure><h3 id="mkdir-命令-–-创建目录"><a href="#mkdir-命令-–-创建目录" class="headerlink" title="mkdir 命令 – 创建目录"></a>mkdir 命令 – 创建目录</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mkdir dir<span class="hljs-comment"># 在当前目录下创建一个 dir 目录，功能等价于 mkdir ./dir</span><br>$ mkdir/root/tmp<span class="hljs-comment"># 在 /root 目录下创建一个 tmp 目录</span><br>$ mkdir -p a/b/c<span class="hljs-comment"># 在当前目录下创建 3 级目录</span><br></code></pre></div></td></tr></table></figure><h3 id="rmdir-命令-–-删除空目录"><a href="#rmdir-命令-–-删除空目录" class="headerlink" title="rmdir 命令 – 删除空目录"></a>rmdir 命令 – 删除空目录</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rmdir [参数] 目录路径<span class="hljs-comment"># 默认仅删除空目录</span><br>$ rmdir./dir<span class="hljs-comment"># 删除当前目录下的 dir 目录</span><br>$ rmdir -p a/b/c<span class="hljs-comment"># 删除当前目录下的 a/b/c 目录</span><br></code></pre></div></td></tr></table></figure><h3 id="touch-命令-创建文件"><a href="#touch-命令-创建文件" class="headerlink" title="touch 命令 - 创建文件"></a>touch 命令 - 创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ touch 1.txt<span class="hljs-comment"># 当前目录下创建一个 1.txt 文件</span><br>$ touch ~/1.txt<span class="hljs-comment"># 当前用户的根目录下创建一个 1.txt 文件</span><br></code></pre></div></td></tr></table></figure><h3 id="rm-命令-删除文件"><a href="#rm-命令-删除文件" class="headerlink" title="rm 命令 - 删除文件"></a>rm 命令 - 删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rm [参数] 路径<br>$ rm -r a<span class="hljs-comment"># 递归删除当前目录下 a 以及 a 目录 下的所有内容</span><br>$ rm -f 1.txt<span class="hljs-comment"># 强制删除该文件，不会提示</span><br>$ rm -rf a/<span class="hljs-comment"># 强制删除当前目录下的 a 目录以及 a 目录下的所有内容</span><br>$ rm -rf *<span class="hljs-comment"># 强制删除当前目录下的所有内容</span><br>$ rm -rf *.txt<span class="hljs-comment"># 强制删除当前目录下的所有 txt 文件</span><br>$ rm -rf *s*<span class="hljs-comment"># 删除当前目录下所有名字中包含 s 的文件或文件夹</span><br></code></pre></div></td></tr></table></figure><h3 id="pwd-命令-—-查看当前路径"><a href="#pwd-命令-—-查看当前路径" class="headerlink" title="pwd 命令 — 查看当前路径"></a>pwd 命令 — 查看当前路径</h3><p>Linux 下所有的绝对路径都是从根目录 <code>/</code> 开始，<code>/root</code> 是 root 用户的根目录，<code>/home</code> 是其他用户的默认根目录。</p><h3 id="cp-命令-–-拷贝文件"><a href="#cp-命令-–-拷贝文件" class="headerlink" title="cp 命令 – 拷贝文件"></a>cp 命令 – 拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cp 1.txt a/<span class="hljs-comment"># 将 1.txt 文件拷贝到 a 目录下</span><br>$ cp 1.txt 2.txt<span class="hljs-comment"># 将 1.txt 文件内容拷贝到 2.txt 文件中</span><br>$ cp -r a data<span class="hljs-comment"># 将 a 目录递归地拷贝 data 目录中</span><br></code></pre></div></td></tr></table></figure><h3 id="scp-命令-远程拷贝文件"><a href="#scp-命令-远程拷贝文件" class="headerlink" title="scp 命令 - 远程拷贝文件"></a>scp 命令 - 远程拷贝文件</h3><p>该命令可以将本地文件拷贝到远程服务器，也可以将远程服务器的文件拷贝到本地，也可将一台服务器文件拷贝到另一台服务器。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将本地文件拷贝到远程服务器</span><br>$ scp -r 本地文件路径 用户名@ip[:port]:远程路径<br><span class="hljs-comment"># 将本地的 2.txt 文件拷贝到 172.18.7.111 的 /root/data/ 目录下</span><br>$ scp -r 2.txt root@172.18.7.111:/root/data/<br><br><span class="hljs-comment"># 远程文件拷贝到本地</span><br>$ scp -r 用户名@ip[:port]:远程文件路径 本地路径<br><span class="hljs-comment"># 将远程的/root/2.txt 文件拷贝到本地的 /root/data 目录</span><br>$ scp -r root@172.18.7.111:/root/2.txt /root/data<br><br><span class="hljs-comment"># 服务器与服务器之间</span><br>$ scp -r 用户名@ip[:port]:远程文件路径 用户名@ip[:port]:远程文件路径<br><span class="hljs-comment"># 将 /root/tmp 拷贝到远程的 /root/data 目录下</span><br>scp -r root@192.168.5.105:/root/tmp root@192.168.5.105:/root/data/<br></code></pre></div></td></tr></table></figure><h3 id="mv命令-–-移动或改名文件"><a href="#mv命令-–-移动或改名文件" class="headerlink" title="mv命令 – 移动或改名文件"></a>mv命令 – 移动或改名文件</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mv 1.txt 2.txt<span class="hljs-comment"># 文件 1.txt 改名为 2.txt 文件</span><br>$ mv a b<span class="hljs-comment"># 目录 a 改名为 b</span><br>$ mv 1.txt b<span class="hljs-comment"># 文件 1.txt 移动到 b 目录下</span><br></code></pre></div></td></tr></table></figure><h3 id="tar-命令-文件打包以及解打包"><a href="#tar-命令-文件打包以及解打包" class="headerlink" title="tar 命令 - 文件打包以及解打包"></a>tar 命令 - 文件打包以及解打包</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar [选项] 打包文件名 文件<span class="hljs-comment"># 文件打包以及解打包</span><br>$ tar -cvf<span class="hljs-comment"># 创建归档文件</span><br>$ tar -xvf<span class="hljs-comment"># 解除归档文件</span><br>$ tar -tvf<span class="hljs-comment"># 查看归档文件内容</span><br><br>$ tar cvf 2.tar 2.txt<span class="hljs-comment"># 将 2.txt 压缩为 2.tar 包</span><br>$ tar cvf a.tar a<span class="hljs-comment"># 将 a 目录下打包到 a.tar 文件中</span><br><br>$ tar xvf 2.tar<span class="hljs-comment"># 将 2.tar 解压到当前目录</span><br>$ tar xvf 2.tar -C a/<span class="hljs-comment"># 将 2.tar 解压到 a 目录</span><br>$ tar xvf data.tar<span class="hljs-comment"># 解压 data.tar 到当前目录</span><br><br>$ tar zcvftm.tar.gz tm<span class="hljs-comment"># 将当前目录下的 tm 目录压缩为 tm.tar.gz</span><br>$ tar zxvf tm.tar.gz<span class="hljs-comment"># 将 tm.tar.gz 解压到当前目录</span><br></code></pre></div></td></tr></table></figure><h3 id="gzip-命令-文件压缩和解压缩"><a href="#gzip-命令-文件压缩和解压缩" class="headerlink" title="gzip 命令 - 文件压缩和解压缩"></a>gzip 命令 - 文件压缩和解压缩</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gzip [选项] 被压缩文件<span class="hljs-comment"># tar 和 gzip 命令结合使用实现文件打包、压缩</span><br><span class="hljs-comment">#-d解压</span><br><span class="hljs-comment">#-r压缩所有文件</span><br><br>$ gzip 2.txt<span class="hljs-comment"># 将 2.txt 压缩为 2.txt.gz</span><br>$ gzip data.tar <span class="hljs-comment"># 将 data.tar 压缩为 data.tar.gz</span><br></code></pre></div></td></tr></table></figure><h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><h3 id="echo-命令-–-输出字符串或提取-Shell-变量的值"><a href="#echo-命令-–-输出字符串或提取-Shell-变量的值" class="headerlink" title="echo 命令 – 输出字符串或提取 Shell 变量的值"></a>echo 命令 – 输出字符串或提取 Shell 变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello<span class="hljs-comment"># 打印 Hello</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-comment"># 打印环境变量 PATH 的值，$ 是取变量值的符号，用法：$变量名 或者 $&#123;变量名&#125;</span><br>$ <span class="hljs-built_in">echo</span> -n Hello<span class="hljs-comment"># 打印内容但不换行</span><br></code></pre></div></td></tr></table></figure><h3 id="gt-和-gt-gt-命令-输出符号"><a href="#gt-和-gt-gt-命令-输出符号" class="headerlink" title="&gt; 和 &gt;&gt; 命令 - 输出符号"></a>&gt; 和 &gt;&gt; 命令 - 输出符号</h3><p><code>&gt;</code> 表示覆盖（删除原文件的内容），<code>&gt;&gt;</code> 表示追加。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello &gt; 1.txt<span class="hljs-comment"># 将 Hello 输出到当前目录下的 1.txt 文件</span><br><span class="hljs-comment"># 如果当前目录下没有 1.txt 文件，就会创建一个新文件</span><br><span class="hljs-comment"># 如果当前目录下有 1.txt 文件，就会删除原文件的内容</span><br>$ <span class="hljs-built_in">echo</span> 123 &gt;&gt; 1.txt<span class="hljs-comment"># 将 123 追加到当前目录下的 1.txt 文件中，如果不存在该文件需要创建一个新的文件</span><br></code></pre></div></td></tr></table></figure><h3 id="cat命令-–-在终端上显示文件内容"><a href="#cat命令-–-在终端上显示文件内容" class="headerlink" title="cat命令 – 在终端上显示文件内容"></a>cat命令 – 在终端上显示文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cat 1.txt<span class="hljs-comment"># 查看当前目录下 1.txt 文件中的内容</span><br></code></pre></div></td></tr></table></figure><h3 id="more-less-命令-分页查看文件内容"><a href="#more-less-命令-分页查看文件内容" class="headerlink" title="more, less 命令 - 分页查看文件内容"></a>more, less 命令 - 分页查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ more 文件所在路径<span class="hljs-comment"># 按空格或回车会继续加载文件内容，按 q 退出查看，加载到文件末尾时会自动退出</span><br><br>$ less 文件所在路径<span class="hljs-comment"># 按空格继续加载文件，按 q 退出查看，不会自动退出查看</span><br></code></pre></div></td></tr></table></figure><h3 id="head-tail-命令-从头，从尾查看文件内容"><a href="#head-tail-命令-从头，从尾查看文件内容" class="headerlink" title="head, tail 命令 - 从头，从尾查看文件内容"></a>head, tail 命令 - 从头，从尾查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ head -n 文件路径<span class="hljs-comment"># 查看文件的前 n 行数据</span><br>$ tail -n 文件路径<span class="hljs-comment"># 查看文件的后 n 行数据</span><br>$ tail -f 文件路径<span class="hljs-comment"># 动态的查看文件的最后几行内容</span><br></code></pre></div></td></tr></table></figure><p>注意：<code>tail -f</code> 一般用来查看日志文件，按下 <code>ctrl + c</code> （暂停进程）或者 <code>ctrl + z</code> （停止进程）才会退出查看。</p><h3 id="wc-命令-查看文件的单词个数"><a href="#wc-命令-查看文件的单词个数" class="headerlink" title="wc 命令 - 查看文件的单词个数"></a>wc 命令 - 查看文件的单词个数</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ wc -l 1.txt<span class="hljs-comment"># -l 表示 line 行数，统计文件 1.txt 的行数</span><br>$ wc -w 1.txt<span class="hljs-comment"># -w 表示 word 单词个数，统计文件 1.txt 的单词个数</span><br></code></pre></div></td></tr></table></figure><h3 id="find-命令-特定目录下查找文件"><a href="#find-命令-特定目录下查找文件" class="headerlink" title="find 命令 - 特定目录下查找文件"></a>find 命令 - 特定目录下查找文件</h3><p>使用参数 <code>-name</code> 按文件名查询，使用参数 <code>-size</code> 按照文件大小查询，使用参数 <code>-type</code> 按照文件类型查询。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ find 路径 -name <span class="hljs-string">&quot;文件名&quot;</span><br>$ find /home -name <span class="hljs-string">&quot;a.txt&quot;</span><br>$ find *.txt<span class="hljs-comment"># 查找 txt 文件</span><br><br>$ find 路径 -size 范围<br><span class="hljs-comment"># +100k# 大小大于 100k</span><br><span class="hljs-comment"># -100k# 大小小于 100k</span><br><br>$ find 路径 -<span class="hljs-built_in">type</span> 类型<br><span class="hljs-comment"># d 目录, l 符号链接, b 块设备文件, c 字符设备文件, s socket 文件, p 管道</span><br></code></pre></div></td></tr></table></figure><h3 id="grep-命令-查找内容"><a href="#grep-命令-查找内容" class="headerlink" title="grep 命令 - 查找内容"></a>grep 命令 - 查找内容</h3><p>:star: <code>grep</code> 对文本文件进行模式匹配，如果找到匹配模式，<code>grep</code> 打印包含模式的所有行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ grep [-选项] <span class="hljs-string">&#x27;搜索内容串&#x27;</span> 文件名<br><span class="hljs-comment"># -v 显示不包含匹配文本的所有行</span><br><span class="hljs-comment"># -n 显示匹配行以及行号</span><br><span class="hljs-comment"># -i 忽略大小写</span><br><br>grep cat 1.txt<span class="hljs-comment"># 在 1.txt 文件中查找包含 cat 的行</span><br><br>| 管道符号<span class="hljs-comment"># 连接两个命令，将前一个命令的查询结果传给后一个命令</span><br>$ ps -ef | grep sshd<span class="hljs-comment"># 查看系统中 sshd 的进程</span><br><br>$ grep -v cat 1.txt<span class="hljs-comment"># 查找 1.txt 文件中不包含 1.txt 的行</span><br>$ ps -ef | grep sshd | grep -v grep<span class="hljs-comment"># 查询 sshd 进程，不包含 grep 的行</span><br></code></pre></div></td></tr></table></figure><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="free-命令-查看系统内存"><a href="#free-命令-查看系统内存" class="headerlink" title="free 命令 - 查看系统内存"></a>free 命令 - 查看系统内存</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ free<span class="hljs-comment"># 查看系统内存的使用情况</span><br>$ free -h<span class="hljs-comment"># 查看内存使用情况，以合适度量单位进行显示</span><br></code></pre></div></td></tr></table></figure><h3 id="df-命令-列出文件系统的整体磁盘使用量"><a href="#df-命令-列出文件系统的整体磁盘使用量" class="headerlink" title="df 命令 - 列出文件系统的整体磁盘使用量"></a>df 命令 - 列出文件系统的整体磁盘使用量</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ df<span class="hljs-comment"># 查看系统磁盘的使用情况</span><br>$ df -h<span class="hljs-comment"># 查看系统硬盘使用，以合适度量单位进行显示</span><br></code></pre></div></td></tr></table></figure><h3 id="du-命令-检查磁盘空间使用量"><a href="#du-命令-检查磁盘空间使用量" class="headerlink" title="du 命令 - 检查磁盘空间使用量"></a>du 命令 - 检查磁盘空间使用量</h3><h3 id="ps-命令-查看系统进程的命令"><a href="#ps-命令-查看系统进程的命令" class="headerlink" title="ps 命令 - 查看系统进程的命令"></a>ps 命令 - 查看系统进程的命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ps -aux<br>$ ps -ef<br></code></pre></div></td></tr></table></figure><h3 id="kill-命令-结束进程"><a href="#kill-命令-结束进程" class="headerlink" title="kill 命令 - 结束进程"></a>kill 命令 - 结束进程</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 88742<span class="hljs-comment"># 结束 PID 为 88742 的进程</span><br><span class="hljs-built_in">kill</span> -9 PID_id<span class="hljs-comment"># 强制结束进程</span><br></code></pre></div></td></tr></table></figure><h2 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h2><h3 id="groupadd-groupdel-命令-创建-删除一个用户组"><a href="#groupadd-groupdel-命令-创建-删除一个用户组" class="headerlink" title="groupadd / groupdel 命令 - 创建/删除一个用户组"></a>groupadd / groupdel 命令 - 创建/删除一个用户组</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ groupadd bows<span class="hljs-comment"># 创建一个叫 bows 的用户组</span><br>$ groupdel bows<span class="hljs-comment"># 当 bows 用户组下没有用户时，删除 bows 用户组</span><br></code></pre></div></td></tr></table></figure><h3 id="useradd-userdel-命令-创建-删除用户，用户管理"><a href="#useradd-userdel-命令-创建-删除用户，用户管理" class="headerlink" title="useradd / userdel 命令 - 创建/删除用户，用户管理"></a>useradd / userdel 命令 - 创建/删除用户，用户管理</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个用户，-g 指定用户的主用户组，-G 指定用户的其他用户组</span><br>$ useradd username [-g 用户组名 -G 用户组名]<br>$ id username<span class="hljs-comment"># 查看用户的 id</span><br><br>$ userdel username<span class="hljs-comment"># 删除用户</span><br><br>$ su username<span class="hljs-comment"># 切换用户，但不加载用户的环境变量</span><br>$ su - username<span class="hljs-comment"># 切换用户，并加载用户的环境变量（建议方式）</span><br><span class="hljs-comment"># 加载用户根目录下的 .bash_profile 环境变量配置文件</span><br><br>$ <span class="hljs-built_in">exit</span><span class="hljs-comment"># 退出当前用户的登录</span><br><br>$ passwd username<span class="hljs-comment"># 修改用户密码</span><br><br>$ r: 读权限，对应数字表示 4<br>$ w: 写权限，对应数字表示 2<br>$ x: 可执行权限，对应数字表示 1<br>$ +: 加上权限，-: 去掉权限<br><br><span class="hljs-comment"># Linux 常用两个命令来修改文件或目录的所属用户和权限</span><br>$ chmod 权限 文件路径<br>$ chmod u+x2.txt/Bob<span class="hljs-comment"># 给文件/用户加上执行权限</span><br></code></pre></div></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="source-命令-让配置文件修改结果立即生效"><a href="#source-命令-让配置文件修改结果立即生效" class="headerlink" title="source 命令 - 让配置文件修改结果立即生效"></a>source 命令 - 让配置文件修改结果立即生效</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> /etc/profile<span class="hljs-comment"># 让配置文件 /etc/profile 生效</span><br></code></pre></div></td></tr></table></figure><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> 导入全局变量（环境变量）<br></code></pre></div></td></tr></table></figure><h3 id="lt-lt-EOF-将-lt-lt-EOF-和-EOF-之间的多行内容传给前面的命令"><a href="#lt-lt-EOF-将-lt-lt-EOF-和-EOF-之间的多行内容传给前面的命令" class="headerlink" title="&lt;&lt; EOF - 将 &lt;&lt; EOF 和 EOF 之间的多行内容传给前面的命令"></a>&lt;&lt; EOF - 将 &lt;&lt; EOF 和 EOF 之间的多行内容传给前面的命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">jnpeng@aliyun:~$ cat &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&gt; A</span><br><span class="hljs-string">&gt; B</span><br><span class="hljs-string">&gt; C</span><br><span class="hljs-string">&gt; EOF</span><br>A<br>B<br>C<br></code></pre></div></td></tr></table></figure><h3 id="cut-命令-截取命令"><a href="#cut-命令-截取命令" class="headerlink" title="cut 命令 - 截取命令"></a>cut 命令 - 截取命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">-f 参数，指定列<br>-d 参数，参数指定列和列之间的分隔符，默认的分隔符是 \t （行向制表符）<br>cut -f 1 1.txt<span class="hljs-comment"># 取 1.txt 文件中的第 1 列内容（列分隔符默认为\t）</span><br>cut -f 1 -d <span class="hljs-string">&#x27;,&#x27;</span> 2.txt<span class="hljs-comment"># 取 2.txt 文件中的第 1 列内容，列分隔符为，</span><br></code></pre></div></td></tr></table></figure><h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ %ns<span class="hljs-comment"># 输出字符串，n 是数字，指代输出几个字符</span><br>$ %ni<span class="hljs-comment"># 输出整数，n 是数字，指代输出几个数字</span><br>$ %m.nf<span class="hljs-comment"># 位数和小数位数。例如：%8.2f 代表输出 8 位数，其中2位是小数，6位是整数</span><br></code></pre></div></td></tr></table></figure><h3 id="service-命令"><a href="#service-命令" class="headerlink" title="service 命令"></a>service 命令</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">enable</span> | <span class="hljs-built_in">disable</span> | start | stop | restart | status<br>start: 启动服务<br>stop: 关闭服务<br>restart: 重启服务<br>status: 查看服务状态<br></code></pre></div></td></tr></table></figure><h3 id="tree-树形显示指定目录内容"><a href="#tree-树形显示指定目录内容" class="headerlink" title="tree - 树形显示指定目录内容"></a>tree - 树形显示指定目录内容</h3><h3 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install &lt;package_name&gt;<span class="hljs-comment"># 安装指定的软件</span><br>$ sudo apt update &lt;package_name&gt;<span class="hljs-comment"># 更新指定的软件</span><br>$ sudo apt update<span class="hljs-comment"># 列出所有可以更新的软件清单命令</span><br>$ sudo apt show &lt;package_name&gt;<span class="hljs-comment"># 显示软件包具体信息</span><br>$ sudo apt remove &lt;package_name&gt;<span class="hljs-comment"># 删除软件包命令</span><br>$ sudo apt upgrade<span class="hljs-comment"># 升级软件包</span><br>$ apt list --upgradeable<span class="hljs-comment"># 列出可更新的软件包及版本信息</span><br></code></pre></div></td></tr></table></figure><h3 id="Linux-文件链接"><a href="#Linux-文件链接" class="headerlink" title="Linux 文件链接"></a>Linux 文件链接</h3><p>Linux 文件链接分为两种：硬链接（Hard Link），符号链接（Symbolic Link）。</p><p><strong>硬链接</strong>：通过索引节点进行链接。Linux 文件系统中每个文件分配了一个索引节点号，Linux 中多个文件名指向同一个索引节点。一个索引节点对应两个不同的文件名，两个文件名指向同一个文件，删除其中一个不会影响另外一个的访问。</p><p><strong>软链接</strong>：类似快捷方式，假设 B 是 A 的软链接，B 的目录项中的 inode 节点号与 A 中的目录项中的 inode 节点号不同，B 和 A 指向的是两个不同的 inode ，继而指向两块不同的数据块。但是 B 的数据块中存放的是 A 的路径名，A 和 B 之间是主从关系，如果 B 删除了，A 仍然存在，但指向一个无效的链接。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> touch f1<span class="hljs-comment">#创建一个测试文件 f1</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln f1 f2<span class="hljs-comment">#创建f1的一个硬连接文件f2</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln -s f1 f3<span class="hljs-comment">#创建f1的一个符号连接文件f3</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -li<span class="hljs-comment"># -i 参数显示文件的inode节点信息</span></span><br></code></pre></div></td></tr></table></figure><div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/Linux%E5%9F%BA%E7%A1%804.png" width = "500px"/></div><p>测试结果：删除原始文件 <code>f1</code> 之后，硬连接 <code>f2</code> 不受影响，但是符号连接 <code>f3</code> 文件失效。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://linux.cn/article-3159-1.html">详解Linux与Unix系统的区别与联系</a></p><p>华为云开发者社区：<a href="https://blog.csdn.net/devcloud/article/details/112648614?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163680083016780357265345%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163680083016780357265345&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-19-112648614.pc_v2_rank_blog_default&amp;utm_term=Linux&amp;spm=1018.2226.3001.4450">Linux 命令大全</a></p><p><a href="https://www.linuxcool.com/">Linux 命令大全</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_7设计模式</title>
    <link href="/2021/09/07/C++%E9%9D%A2%E8%AF%95_7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/07/C++%E9%9D%A2%E8%AF%95_7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式，工厂模式，观察者模式。</p><span id="more"></span><h3 id="1-了解哪些设计模式？-star-4"><a href="#1-了解哪些设计模式？-star-4" class="headerlink" title="1 了解哪些设计模式？:star:4"></a>1 了解哪些设计模式？:star:4</h3><p><strong>设计模式 6 大设计原则</strong>：</p><ul><li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。</li><li>开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li><li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li><li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。</li><li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li><li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li></ul><p><strong>设计模式分为三类</strong>：</p><ul><li>创造型模式：单例模式、工厂模式、建造者模式、原型模式</li><li>结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式</li><li>行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</li></ul><p><strong>下面介绍常见的几种设计模式</strong>：</p><ul><li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式<ul><li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li><li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li><li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li></ul></li><li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。</li><li>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成派生类更为灵活。</li></ul><h3 id="2-什么是单例模式？如何实现？应用场景？-star-5"><a href="#2-什么是单例模式？如何实现？应用场景？-star-5" class="headerlink" title="2 什么是单例模式？如何实现？应用场景？:star:5"></a>2 什么是单例模式？如何实现？应用场景？:star:5</h3><p><strong>单例模式</strong>：保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。</p><p><strong>应用场景</strong>：</p><ul><li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li><li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li></ul><p><strong>实现方式</strong>：</p><p>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响<u>封装性</u>，难以保证别的代码不会对全局变量造成影响。</p><ul><li><strong>默认的构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>赋值构造函数声明为私有的</strong>，这样禁止在类的外部创建该对象；</li><li>全局访问点也要定义成 <strong>静态类型的成员函数</strong>，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li></ul><p>不安全的实现方式：<br>原因：考虑当两个线程同时调用 <code>getInstance</code> 方法，并且同时检测到 <code>instance</code> 是 <code>NULL</code>，两个线程会同时实例化对象，不符合单例模式的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Singleton * instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">NULL</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br></code></pre></div></td></tr></table></figure><p><strong>分类</strong>：</p><ul><li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li><li>饿汉模式：类定义的时候就实例化。</li></ul><p><strong>线程安全的懒汉模式实现：</strong></p><p><strong>方法1：加锁</strong>。存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-keyword">static</span> Singleton * instance;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>); <br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; tmp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">NULL</span>)&#123;            <br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();            <br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">pthread_mutex_t</span> Singleton::mutex;<br></code></pre></div></td></tr></table></figure><p><strong>方法2：内部静态变量</strong>。在全局访问点 <code>getInstance</code> 中定义静态实例。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;<br>    <span class="hljs-built_in">Singleton</span>()&#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-keyword">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> &amp;instance;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">pthread_mutex_t</span> Singleton::mutex; <br></code></pre></div></td></tr></table></figure><p>饿汉模式的实现：饿汉模式本身就是线程安全的不用加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Singleton* instance;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp; temp)&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br> <span class="hljs-built_in">Singleton</span>()&#123;&#125; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> Singleton* <span class="hljs-built_in">getInstance</span>()&#123; <br>        <span class="hljs-keyword">return</span> instance;    <br>    &#125;<br>&#125;;<br>Singleton* Singleton::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br></code></pre></div></td></tr></table></figure><h3 id="3-什么是工厂模式？如何实现？应用场景？-star-3"><a href="#3-什么是工厂模式？如何实现？应用场景？-star-3" class="headerlink" title="3 什么是工厂模式？如何实现？应用场景？:star:3"></a>3 什么是工厂模式？如何实现？应用场景？:star:3</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/83535678">C++ 深入浅出工厂模式（初识篇）</a></p></blockquote><h3 id="4-什么是观察者模式？如何实现？应用场景？-star-3"><a href="#4-什么是观察者模式？如何实现？应用场景？-star-3" class="headerlink" title="4 什么是观察者模式？如何实现？应用场景？:star:3"></a>4 什么是观察者模式？如何实现？应用场景？:star:3</h3><p><strong>观察者模式</strong>：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p><p><strong>观察者模式中存在两种角色</strong>：</p><ul><li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li><li>被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li></ul><p><strong>应用场景</strong>：</p><ul><li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li><li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>;</span><br><span class="hljs-comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    string name;<br>    Subject *sub;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Observer</span>(string name, Subject *sub)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = name;<br>        <span class="hljs-keyword">this</span>-&gt;sub = sub;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockObserver</span> :</span> <span class="hljs-keyword">public</span> Observer<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StockObserver</span>(string name, Subject *sub) : <span class="hljs-built_in">Observer</span>(name, sub)<br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBAObserver</span> :</span> <span class="hljs-keyword">public</span> Observer<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NBAObserver</span>(string name, Subject *sub) : <span class="hljs-built_in">Observer</span>(name, sub)<br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-comment">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    list&lt;Observer *&gt; observers;<br><br><span class="hljs-keyword">public</span>:<br>    string action; <span class="hljs-comment">//被观察者对象的状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer *)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer *)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Secretary</span> :</span> <span class="hljs-keyword">public</span> Subject<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer *observer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        observers.<span class="hljs-built_in">push_back</span>(observer);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer *observer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        list&lt;Observer *&gt;::iterator iter = observers.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (iter != observers.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((*iter) == observer)<br>            &#123;<br>                observers.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            ++iter;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        list&lt;Observer *&gt;::iterator iter = observers.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (iter != observers.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            (*iter)-&gt;<span class="hljs-built_in">update</span>();<br>            ++iter;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StockObserver::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (sub-&gt;action == <span class="hljs-string">&quot;梁所长来了!&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NBAObserver::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (sub-&gt;action == <span class="hljs-string">&quot;梁所长来了!&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Subject *dwq = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Secretary</span>();<br>    Observer *xs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NBAObserver</span>(<span class="hljs-string">&quot;xiaoshuai&quot;</span>, dwq);<br>    Observer *zy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NBAObserver</span>(<span class="hljs-string">&quot;zouyue&quot;</span>, dwq);<br>    Observer *lm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StockObserver</span>(<span class="hljs-string">&quot;limin&quot;</span>, dwq);<br><br>    dwq-&gt;<span class="hljs-built_in">attach</span>(xs);<br>    dwq-&gt;<span class="hljs-built_in">attach</span>(zy);<br>    dwq-&gt;<span class="hljs-built_in">attach</span>(lm);<br><br>    dwq-&gt;action = <span class="hljs-string">&quot;去吃饭了！&quot;</span>;<br>    dwq-&gt;<span class="hljs-built_in">notify</span>();<br>    cout &lt;&lt; endl;<br>    dwq-&gt;action = <span class="hljs-string">&quot;梁所长来了!&quot;</span>;<br>    dwq-&gt;<span class="hljs-built_in">notify</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_6语言特性相关</title>
    <link href="/2021/09/06/C++%E9%9D%A2%E8%AF%95_6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/06/C++%E9%9D%A2%E8%AF%95_6%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>指针，参数，模板。</p><span id="more"></span><h3 id="1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？-star-4"><a href="#1-左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？-star-4" class="headerlink" title="1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？:star:4"></a>1 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？:star:4</h3><blockquote><p><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a><br><a href="https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/">https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/</a></p></blockquote><h3 id="2-std-move-函数的实现原理-star-3"><a href="#2-std-move-函数的实现原理-star-3" class="headerlink" title="2 std::move() 函数的实现原理 :star:3"></a>2 std::move() 函数的实现原理 :star:3</h3><p><code>std::move()</code> 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：引用折叠原理</p><ul><li>右值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是右值，即 <code>T&amp;&amp; &amp;&amp;</code> 相当于 <code>T&amp;&amp;</code>。</li><li>左值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是左值，即 <code>T&amp;&amp; &amp;</code> 相当于 <code>T&amp;</code>。</li></ul><p>小结：通过引用折叠原理可以知道，<code>move()</code> 函数的形参既可以是左值也可以是右值。</p><p><code>remove_reference</code> 具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//原始的，最通用的版本</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> T type;  <span class="hljs-comment">//定义 T 的类型别名为 type</span><br>&#125;;<br> <br><span class="hljs-comment">//部分版本特例化，将用于左值引用和右值引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&gt; <span class="hljs-comment">//左值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&amp;&gt; <span class="hljs-comment">//右值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;   <br>  <br><span class="hljs-comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span><br><span class="hljs-keyword">int</span> i;<br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::type a;             <span class="hljs-comment">//使用原版本，</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(i)&gt;::type  b;             <span class="hljs-comment">//左值引用特例版本</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">move</span>(i))&gt;::type  b;  <span class="hljs-comment">//右值引用特例版本 </span><br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> var = <span class="hljs-number">10</span>; <br><br>转化过程：<br><span class="hljs-number">1.</span> std::<span class="hljs-built_in">move</span>(var) =&gt; std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp;&amp; &amp;) =&gt; 折叠后 std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp;)<br><br><span class="hljs-number">2.</span> 此时：T 的类型为 <span class="hljs-keyword">int</span>&amp;，<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type 为 <span class="hljs-keyword">int</span>，这里使用 remove_reference 的左值引用的特例化版本<br><br><span class="hljs-number">3.</span> 通过 <span class="hljs-keyword">static_cast</span> 将 <span class="hljs-keyword">int</span>&amp; 强制转换为 <span class="hljs-keyword">int</span>&amp;&amp;<br><br>整个std::move被实例化如下<br>string&amp;&amp; <span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span>&amp; t) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结：<br><code>std::move()</code> 实现原理：</p><ol><li>利用引用折叠原理将右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li><li>然后通过 <code>remove_refrence</code> 移除引用，得到具体的类型 <code>T</code>；</li><li>最后通过 <code>static_cast&lt;&gt;</code> 进行强制类型转换，返回 <code>T&amp;&amp;</code> 右值引用。</li></ol><h3 id="3-什么是指针？指针的大小及用法？-star-2"><a href="#3-什么是指针？指针的大小及用法？-star-2" class="headerlink" title="3 什么是指针？指针的大小及用法？:star:2"></a>3 什么是指针？指针的大小及用法？:star:2</h3><p><strong>指针：</strong> 指向另外一种类型的复合类型。</p><p><strong>指针的大小：</strong> 在 64 位计算机中，指针占 8 个字节空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br><br>    <span class="hljs-keyword">char</span> *p1 = <span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p1) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>指针的用法：</strong></p><ol><li><p>指向普通对象的指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向常量对象的指针：常量指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p = &amp;c_var;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向函数的指针：函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun_p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<br>    fun_p = add;<br>    cout &lt;&lt; <span class="hljs-built_in">fun_p</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。特别注意：定义指向成员函数的指针时，要标明指针所属的类。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2; <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> var1 + var2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex;<br>    ex.var1 = <span class="hljs-number">3</span>;<br>    ex.var2 = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">int</span> *p = &amp;ex.var1; <span class="hljs-comment">// 指向对象成员变量的指针</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (A::*fun_p)();<br>    fun_p = A::add; <span class="hljs-comment">// 指向对象成员函数的指针 fun_p</span><br>    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>this 指针：指向类的当前对象的指针常量。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_name</span><span class="hljs-params">(string tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_age</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_sex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;sex = tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Sex: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;sex &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    p-&gt;<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>    p-&gt;<span class="hljs-built_in">set_age</span>(<span class="hljs-number">16</span>);<br>    p-&gt;<span class="hljs-built_in">set_sex</span>(<span class="hljs-number">1</span>);<br>    p-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="4-什么是野指针和悬空指针？-star-3"><a href="#4-什么是野指针和悬空指针？-star-3" class="headerlink" title="4 什么是野指针和悬空指针？:star:3"></a>4 什么是野指针和悬空指针？:star:3</h3><p>悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> *p = <span class="hljs-built_in">malloc</span>(size);<br><span class="hljs-built_in">free</span>(p); <span class="hljs-comment">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span><br></code></pre></div></td></tr></table></figure><p>野指针：不确定其指向的指针，未初始化的指针为“野指针”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> *p; <span class="hljs-comment">// 此时 p 是“野指针”。</span><br></code></pre></div></td></tr></table></figure><h3 id="5-C-11-nullptr-比-NULL-优势-star-1"><a href="#5-C-11-nullptr-比-NULL-优势-star-1" class="headerlink" title="5 C++ 11 nullptr 比 NULL 优势 :star:1"></a>5 C++ 11 nullptr 比 NULL 优势 :star:1</h3><ul><li><code>NULL</code>：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 <code>#define NULL 0</code>。</li><li><code>nullptr</code>：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他指针类型。</li></ul><p><code>nullptr</code> 的优势：</p><ol><li>有类型，类型是 <code>typdef decltype(nullptr) nullptr_t;</code>，使用 <code>nullptr</code> 提高代码的健壮性。</li><li>函数重载：因为 <code>NULL</code> 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 <code>NULL</code>，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 <code>nullptr</code> 就不会出现这种情况。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *p)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;fun(char const *p)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;fun(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// fun(char const *p)</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    fun(NULL); // error: call of overloaded &#x27;fun(NULL)&#x27; is ambiguous</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-指针和引用的区别？-star-4"><a href="#6-指针和引用的区别？-star-4" class="headerlink" title="6 指针和引用的区别？:star:4"></a>6 指针和引用的区别？:star:4</h3><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</li><li>指针可以为空，但是引用必须绑定对象。（是否可为空）</li><li>指针可以有多级，但是引用只能一级。（是否能为多级）</li></ul><p>C+11 Standard: § 8.3.2.4</p><blockquote><p>It is unspecified whether or not a reference requires storage (3.7).</p></blockquote><p><strong>引用是否占内存，取决于编译器的实现。</strong></p><ul><li>如果编译器用指针实现引用，那么它占内存。</li><li>如果编译器直接将引用替换为其所指的对象，则其不占内存（毕竟，替换掉之后，该引用实际就不存在了）。</li></ul><p>顺便一提，你无法用 sizeof 得到引用的大小，sizeof 作用于引用时，你得到的是它对应的对象的大小。</p><h3 id="7-常量指针和指针常量的区别-star-4"><a href="#7-常量指针和指针常量的区别-star-4" class="headerlink" title="7 常量指针和指针常量的区别 :star:4"></a>7 常量指针和指针常量的区别 :star:4</h3><p><strong>常量指针</strong>：常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>特点：<code>const</code> 的位置在指针声明运算符 <code>*</code> 的左侧。只要 <code>const</code> 位于 <code>*</code> 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，<code>*</code> 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> * p;<br></code></pre></div></td></tr></table></figure><p>注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;c_var; <br>    *p = <span class="hljs-number">6</span>;            <span class="hljs-comment">// error: assignment of read-only location &#x27;* p&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var1 = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var2 = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;c_var1; <br>    p = &amp;c_var2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>指针常量</strong>：指针常量的本质上是个常量，只不过这个常量的值是一个指针。</p><p>特点：<code>const</code> 位于指针声明操作符右侧，表明该对象本身是一个常量，<code>*</code> 左侧表示该指针指向的类型，即以 <code>*</code> 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> var;<br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var; <br></code></pre></div></td></tr></table></figure><p>注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var, var1;<br>    <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var;<br>    c_p = &amp;var1; <span class="hljs-comment">// error: assignment of read-only variable &#x27;c_p&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意 2：指针的内容可以改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> c_p = &amp;var;<br>    *c_p = <span class="hljs-number">12</span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>常量指针（const int * p）</strong>：指向常量（const int）的指针，可以切换到指向别的常量（const int）；<br><strong>指针常量（int * const p）</strong>：指针的指向不可修改。<br><strong>指向常量的指针常量（const int * const p）</strong>: p的指向不可修改，p所指的内存区域中的值也不可修改（是常量）。</p><p><strong>从右往左读，遇到 <code>p</code> 就替换成  <code>p is a</code> ，遇到 <code>*</code> 就替换成 <code>point to</code>。</strong></p><p>①const int p;</p><p>p is a int const.    ——&gt; p 是一个整型常量。</p><p>②const int* p;</p><p>p is a point to int const.        ——-&gt; p 是一个指向整型常量的指针。</p><p>③int const* p;</p><p>p is a point to const int.        ——-&gt; 同上</p><p>④int * const p;</p><p>p is a const point to int.        ——-&gt;    p 是一个常量指针，指向整型。</p><p>⑤const int * const p;</p><p>p is a const point to int const.        ——-&gt; p 是常量指针，指向整型常量。</p><p>⑥int const * const p;</p><p>p is a const point to const int.        ———&gt; p 是常量指针，指向整型常量。</p><blockquote><p>记忆方法源自《c primer plus》</p></blockquote><h3 id="8-函数指针和指针函数的区别-star-4"><a href="#8-函数指针和指针函数的区别-star-4" class="headerlink" title="8 函数指针和指针函数的区别 :star:4"></a>8 函数指针和指针函数的区别 :star:4</h3><p><strong>指针函数：</strong>指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是<u>返回值是指针</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type</span> &#123;</span><br>  <span class="hljs-keyword">int</span> var1;<br>  <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><span class="hljs-function">Type * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>    Type * t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Type</span>();<br>    t-&gt;var1 = tmp1;<br>    t-&gt;var2 = tmp2;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Type *p = <span class="hljs-built_in">fun</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>函数指针：</strong>函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即<u>指向函数的指针</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> tmp1 * tmp2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> tmp1 / tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun)(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y); <br>  fun = fun1;<br>  cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <br>  fun = fun2;<br>  cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">75</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>函数指针和指针函数的区别</strong>：</p><ul><li>本质不同<ul><li>指针函数本质是一个函数，其返回值为指针。</li><li>函数指针本质是一个指针变量，其指向一个函数。</li></ul></li><li>定义形式不同<ul><li>指针函数：<code>int* fun(int tmp1, int tmp2);</code>，这里 <code>*</code> 表示函数的返回值类型是指针类型。</li><li>函数指针：<code>int (*fun)(int tmp1, int tmp2);</code>，这里* 表示变量本身是指针类型。</li></ul></li><li>用法不同</li></ul><h3 id="9-强制类型转换有哪几种？-star-4"><a href="#9-强制类型转换有哪几种？-star-4" class="headerlink" title="9 强制类型转换有哪几种？:star:4"></a>9 强制类型转换有哪几种？:star:4</h3><ul><li><p><code>static_cast</code>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p><ol><li>用于基本数据类型的转换。</li><li>用于类层次之间的基类和派生类之间 <strong>指针或者引用</strong> 的转换（<strong>不要求必须包含虚函数，但必须是有相互联系的类</strong>），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 <code>dynamic_cast</code> 进行下行转换。</li><li>可以将空指针转化成目标类型的空指针。</li><li>可以将任何类型的表达式转化成 <code>void</code> 类型。</li></ol></li><li><p><code>const_cast</code>：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p></li><li><p><code>reinterpret_cast</code>：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</p></li><li><p><code>dynamic_cast</code>：</p><ol><li><p>其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。</p></li><li><p>只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 <code>NULL</code>；不能用于基本数据类型的转换。</p></li><li><p>在向上进行转换时，即派生类类的指针转换成基类类的指针和 <code>static_cast</code> 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span> &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Derive *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br><br>    <span class="hljs-comment">//向上类型转换</span><br>    p1 = <span class="hljs-keyword">dynamic_cast</span>&lt;Base *&gt;(p2);<br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//输出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>    Derive *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br><br>    <span class="hljs-comment">//转换成功</span><br>    p3 = <span class="hljs-keyword">dynamic_cast</span>&lt;Derive *&gt;(p1);<br>    <span class="hljs-keyword">if</span> (p3 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    &#125;<br><br>    <span class="hljs-comment">//转换失败</span><br>    p3 = <span class="hljs-keyword">dynamic_cast</span>&lt;Derive *&gt;(p2);<br>    <span class="hljs-keyword">if</span> (p3 == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NOT NULL&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol></li></ul><h3 id="10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？-star-2"><a href="#10-如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？-star-2" class="headerlink" title="10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？:star:2"></a>10 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？:star:2</h3><p>需要重载操作符 <code>==</code> 判断两个结构体是否相等，不能用函数 <code>memcmp</code> 来判断两个结构体是否相等，因为 <code>memcmp</code> 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</p><p><strong>利用运算符重载来实现结构体对象的比较</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">char</span> c_tmp, <span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">c</span>(c_tmp), <span class="hljs-built_in">val</span>(tmp) &#123;&#125;<br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> A &amp;tmp1, <span class="hljs-keyword">const</span> A &amp;tmp2); <span class="hljs-comment">//  友元运算符重载函数</span><br>&#125;;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> A &amp;tmp1, <span class="hljs-keyword">const</span> A &amp;tmp2) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">90</span>)</span>, <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">80</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (ex1 == ex2)<br>        cout &lt;&lt; <span class="hljs-string">&quot;ex1 == ex2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;ex1 != ex2&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="11-参数传递时，值传递、引用传递、指针传递的区别？-star-2"><a href="#11-参数传递时，值传递、引用传递、指针传递的区别？-star-2" class="headerlink" title="11 参数传递时，值传递、引用传递、指针传递的区别？:star:2"></a>11 参数传递时，值传递、引用传递、指针传递的区别？:star:2</h3><p><strong>参数传递的三种方式</strong>：</p><ul><li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li><li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li><li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; <span class="hljs-comment">// 值传递</span><br>    cout &lt;&lt; &amp;tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * tmp)</span></span>&#123; <span class="hljs-comment">// 指针传递</span><br>    cout &lt;&lt; tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;tmp)</span></span>&#123; <span class="hljs-comment">// 引用传递</span><br>    cout &lt;&lt; &amp;tmp &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;var 在主函数中的地址：&quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 值传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun1</span>(var);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 指针传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun2</span>(&amp;var);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;var 引用传递时的地址：&quot;</span>;<br>    <span class="hljs-built_in">fun3</span>(var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">var 在主函数中的地址：0x23fe4c</span><br><span class="hljs-comment">var 值传递时的地址：0x23fe20</span><br><span class="hljs-comment">var 指针传递时的地址：0x23fe4c</span><br><span class="hljs-comment">var 引用传递时的地址：0x23fe4c</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。</p><blockquote><p><a href="https://www.cnblogs.com/huolong-blog/p/7588335.html">c++值传递，指针传递，引用传递以及指针与引用的区别</a></p></blockquote><h3 id="12-什么是模板？如何实现？-star-3"><a href="#12-什么是模板？如何实现？-star-3" class="headerlink" title="12 什么是模板？如何实现？:star:3"></a>12 什么是模板？如何实现？:star:3</h3><p>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>实现方式：模板定义以关键字 <code>template</code> 开始，后跟一个模板参数列表。</p><ul><li>模板参数列表不能为空；</li><li>模板类型参数前必须使用关键字 <code>class</code> 或者 <code>typename</code> ，在模板参数列表中这两个关键字含义相同，可互换使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, ...&gt;<br></code></pre></div></td></tr></table></figure><p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p><ul><li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li><li>函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; tmp1, <span class="hljs-keyword">const</span> T &amp; tmp2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> tmp1 + tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    cin &gt;&gt; var1 &gt;&gt; var2;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var1, var2);<br><br>    <span class="hljs-keyword">double</span> var3, var4;<br>    cin &gt;&gt; var3 &gt;&gt; var4;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var3, var4);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类模板：类似函数模板，类模板以关键字 <code>template</code> 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Complex</span>(T a, T b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br><br>    <span class="hljs-comment">//运算符重载</span><br>    Complex&lt;T&gt; <span class="hljs-keyword">operator</span>+(Complex &amp;c)<br>    &#123;<br>        <span class="hljs-function">Complex&lt;T&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;a + c.a, <span class="hljs-keyword">this</span>-&gt;b + c.b)</span></span>;<br>        cout &lt;&lt; tmp.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; tmp.b &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T a;<br>    T b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span></span>;<br>    Complex&lt;<span class="hljs-keyword">int</span>&gt; c = a + b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="13-函数模板和类模板的区别？-star-2"><a href="#13-函数模板和类模板的区别？-star-2" class="headerlink" title="13 函数模板和类模板的区别？:star:2"></a>13 函数模板和类模板的区别？:star:2</h3><ul><li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li><li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li><li>默认参数：类模板在模板参数列表中可以有默认参数。</li><li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li><li>调用方式不同：<u>函数模板</u>可以隐式调用，也可以显式调用；<u>类模板</u>只能显式调用。</li></ul><p>函数模板调用方式举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">add_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; tmp1, <span class="hljs-keyword">const</span> T &amp; tmp2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> tmp1 + tmp2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    cin &gt;&gt; var1 &gt;&gt; var2;<br>    cout &lt;&lt; add_fun&lt;<span class="hljs-keyword">int</span>&gt;(var1, var2); <span class="hljs-comment">// 显式调用</span><br><br>    <span class="hljs-keyword">double</span> var3, var4;<br>    cin &gt;&gt; var3 &gt;&gt; var4;<br>    cout &lt;&lt; <span class="hljs-built_in">add_fun</span>(var3, var4); <span class="hljs-comment">// 隐式调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="14-什么是可变参数模板？-star-1"><a href="#14-什么是可变参数模板？-star-1" class="headerlink" title="14 什么是可变参数模板？:star:1"></a>14 什么是可变参数模板？:star:1</h3><p>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p><ul><li>模板参数包：表示零个或多个模板参数；</li><li>函数参数包：表示零个或多个函数参数。</li></ul><p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 <code>sizeof...</code> 运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-comment">// Args 是模板参数包</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span></span>; <span class="hljs-comment">// 可变参数模板，rest 是函数参数包</span><br></code></pre></div></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t)</span> </span>&#123;<br>    cout &lt;&lt; t &lt;&lt; endl; <span class="hljs-comment">// 最后一个元素</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args &amp;...args)</span> </span>&#123;<br>    cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">print_fun</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print_fun</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*运行结果：</span><br><span class="hljs-comment">Hello wolrd !</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：可变参数函数通常是递归的，第一个版本的 <code>print_fun</code> 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 <code>print_fun</code> 是可变参数版本，打印绑定到 <code>t</code> 的实参，并用来调用自身来打印函数参数包中的剩余值。</p><h3 id="15-什么是模板特化？为什么特化？-star-3"><a href="#15-什么是模板特化？为什么特化？-star-3" class="headerlink" title="15 什么是模板特化？为什么特化？:star:3"></a>15 什么是模板特化？为什么特化？:star:3</h3><p><strong>模板特化的原因</strong>：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</p><p><strong>模板特化</strong>：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p><ul><li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li><li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li></ul><p><strong>特化分为全特化和偏特化</strong>：</p><ul><li>全特化：模板中的模板参数全部特例化。</li><li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li></ul><p>函数重载与函数模板特化的区分：定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T t1, T t2)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通用版本：&quot;</span>;<br>    <span class="hljs-keyword">return</span> t1 == t2;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-comment">//函数模板特化</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *t1, <span class="hljs-keyword">char</span> *t2)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;特化版本：&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> arr1[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">char</span> arr2[] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">123</span>, <span class="hljs-number">123</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">compare</span>(arr1, arr2) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">通用版本：1</span><br><span class="hljs-comment">特化版本：0</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="16-include-“-“-和-lt-gt-的区别-star-1"><a href="#16-include-“-“-和-lt-gt-的区别-star-1" class="headerlink" title="16 include “ “ 和 &lt;&gt; 的区别 :star:1"></a>16 include “ “ 和 &lt;&gt; 的区别 :star:1</h3><p><code>include&lt;文件名&gt;</code> 和 <code>#include&quot;文件名&quot;</code> 的区别:</p><ul><li>查找文件的位置：<code>include&lt;文件名&gt;</code> 在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；<code>#include&quot;文件名&quot;</code> 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li><li>使用习惯：对于标准库中的头文件常用 <code>include&lt;文件名&gt;</code>，对于自己定义的头文件，常用 <code>#include&quot;文件名&quot;</code></li></ul><h3 id="17-switch-的-case-里为何不能定义变量-star-1"><a href="#17-switch-的-case-里为何不能定义变量-star-1" class="headerlink" title="17 switch 的 case 里为何不能定义变量 :star:1"></a>17 switch 的 case 里为何不能定义变量 :star:1</h3><p><code>switch</code> 下面的这个花括号表示一块作用域，而不是每一个 <code>case</code> 表示一块作用域。如果在某一 <code>case</code> 中定义了变量，其作用域在这块花括号内，按理说在另一个 <code>case</code> 内可以使用该变量，但是在实际使用时，每一个 <code>case</code> 之间互不影响，是相对封闭的，参考如下实例。</p><p>实例：下述代码中，在 <code>switch</code> 的 <code>case</code> 中定义的变量，没有实际意义，仅为了解释上述原因。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量声明</span><br>    <span class="hljs-keyword">char</span> var = <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (var)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义变量</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Excellent.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>        ++cnt;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Good.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Not bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;F&#x27;</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bad.&quot;</span> &lt;&lt; endl<br>             &lt;&lt; cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单解释：上述代码中在符合 <code>A</code> 的条件下定义了变量，当符合 <code>B</code> 或者 <code>C</code> 的条件时，对该变量进行自增操作，但是因为不符合条件 <code>A</code> 未对变量进行定义，该变量无法使用。</p><h3 id="18-迭代器的作用？-star-1"><a href="#18-迭代器的作用？-star-1" class="headerlink" title="18 迭代器的作用？:star:1"></a>18 迭代器的作用？:star:1</h3><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式。</p><p>作用：在无需知道容器底层原理的情况下，遍历容器中的元素。</p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = arr.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 定义迭代器</span><br>    <span class="hljs-keyword">for</span> (; iter != arr.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">1 2 3 4 5 6 7 8 9 0</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="19-泛型编程如何实现？-star-2"><a href="#19-泛型编程如何实现？-star-2" class="headerlink" title="19 泛型编程如何实现？:star:2"></a>19 泛型编程如何实现？:star:2</h3><p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 <code>vector</code> 这样的泛型，或者 <code>find</code> 这样的泛型函数时，编译时会转化为特定的类或者函数。</p><p>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p><ul><li>容器：涉及到 STL 中的容器，例如：<code>vector</code>、<code>list</code>、<code>map</code> 等，可选其中熟悉底层原理的容器进行展开讲解。</li><li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li><li>模板：可参考本章节中的模板相关问题。</li></ul><h3 id="20-什么是类型萃取？-star-1"><a href="#20-什么是类型萃取？-star-1" class="headerlink" title="20 什么是类型萃取？:star:1"></a>20 什么是类型萃取？:star:1</h3><p>类型萃取使用模板技术来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。</p><p>C++ 类型萃取一般用于模板中，当我们定义一个模板函数后，需要知道模板类型形参并加以运用时就可以用类型萃取。</p><p>比如我们需要在函数中进行拷贝，通常我们可以用内置函数 <code>memcpy</code> 或者自己写一个 <code>for</code> 循环来进行拷贝。</p><blockquote><p><a href="https://blog.csdn.net/xuzhangze/article/details/78374890">C++之类型萃取</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_5类相关</title>
    <link href="/2021/09/05/C++%E9%9D%A2%E8%AF%95_5%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/05/C++%E9%9D%A2%E8%AF%95_5%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>虚函数，继承，构造函数，对象实例化，拷贝，多态。</p><span id="more"></span><h3 id="1-什么是虚函数？什么是纯虚函数？-star-5"><a href="#1-什么是虚函数？什么是纯虚函数？-star-5" class="headerlink" title="1 什么是虚函数？什么是纯虚函数？:star:5"></a>1 什么是虚函数？什么是纯虚函数？:star:5</h3><p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">v_fun</span>(); <span class="hljs-comment">// B::v_fun()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>纯虚函数</strong>：</p><ul><li>纯虚函数在类中声明时，加上 <code>=0</code>；</li><li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li></ul><p><strong>说明</strong>：</p><ul><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li><li>可以声明抽象类指针，可以声明抽象类的引用；</li><li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li></ul><h3 id="2-虚函数和纯虚函数的区别？-star-3"><a href="#2-虚函数和纯虚函数的区别？-star-3" class="headerlink" title="2 虚函数和纯虚函数的区别？:star:3"></a>2 虚函数和纯虚函数的区别？:star:3</h3><ul><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）；</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 <code>virtual</code> 关键字，纯虚函数定义时除了加上 <code>virtual</code> 关键字还需要加上 <code>=0</code> ；</li><li>虚函数必须实现，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li><strong>析构函数最好定义为虚函数，特别是对于含有继承关系的类</strong>；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li></ul><h3 id="3-虚函数的实现机制-star-5"><a href="#3-虚函数的实现机制-star-5" class="headerlink" title="3 虚函数的实现机制:star:5"></a>3 虚函数的实现机制:star:5</h3><p><strong>实现机制</strong>：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p><p><strong>虚函数表相关知识点</strong>：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul><p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p><p><strong>实例</strong>：无虚函数覆盖的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB9.png" width="100px" /></div><p>基类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB10.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB11.png" width="750px" /></div><p>主函数中基类的指针 <code>p</code> 指向了派生类的对象，当调用函数 <code>B_fun1()</code> 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p><h3 id="4-单继承和多继承的虚函数表结构-star-4"><a href="#4-单继承和多继承的虚函数表结构-star-4" class="headerlink" title="4 单继承和多继承的虚函数表结构 :star:4"></a>4 单继承和多继承的虚函数表结构 :star:4</h3><p><strong>编译器处理虚函数表</strong>：</p><ul><li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li><li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li><li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li><li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li></ul><ol><li><p>单继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB12.png" width="100px" /></div><p>基类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB13.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB14.png" width="800px" /></div></li><li><p>单继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB15.png" width="800px" /></div></li><li><p>多继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B1_fun1</span>(); <span class="hljs-comment">// Base1::B1_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB16.png" width="550px" /></div><p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB17.png" width="800px" /></div></li><li><p>多继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base2 *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base3 *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p1-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p2-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p3-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基类和派生类的关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB18.png" width="550px" /></div><p>派生类的虚函数表：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB19.png" width="700px" /></div></li></ol><h3 id="5-如何禁止构造函数的使用？-star-2"><a href="#5-如何禁止构造函数的使用？-star-2" class="headerlink" title="5 如何禁止构造函数的使用？:star:2"></a>5 如何禁止构造函数的使用？:star:2</h3><p>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;    <br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>)</span></span>; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-什么是类的默认构造函数？-star-3"><a href="#6-什么是类的默认构造函数？-star-3" class="headerlink" title="6 什么是类的默认构造函数？:star:3"></a>6 什么是类的默认构造函数？:star:3</h3><p>默认构造函数：未提供任何实参，来控制默认初始化过程的构造函数称为默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123; <span class="hljs-comment">// 类的默认构造函数</span><br>        var = <span class="hljs-number">10</span>;<br>        c = <span class="hljs-string">&#x27;q&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">char</span> c;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex;<br>    cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">q</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述程序中定义变量 <code>ex</code> 时，未提供任何实参，程序运行时会调用默认的构造函数。</p><h3 id="7-构造函数、析构函数是否需要定义成虚函数？为什么？-star-4"><a href="#7-构造函数、析构函数是否需要定义成虚函数？为什么？-star-4" class="headerlink" title="7 构造函数、析构函数是否需要定义成虚函数？为什么？:star:4"></a>7 构造函数、析构函数是否需要定义成虚函数？为什么？:star:4</h3><p>构造函数一般不定义为虚函数，原因：</p><ul><li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ul><p><strong>析构函数一般定义成虚函数</strong>，原因：析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</p><h3 id="8-如何避免拷贝？-star-2"><a href="#8-如何避免拷贝？-star-2" class="headerlink" title="8 如何避免拷贝？:star:2"></a>8 如何避免拷贝？:star:2</h3><p>最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 <code>private</code>，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p><p>解决方法：C++ 11 中使用弃置函数 <code>delete</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">noncopyable</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">noncopyable</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">noncopyable</span>(<span class="hljs-keyword">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    noncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> noncopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span> :</span> <span class="hljs-keyword">private</span> noncopyable &#123; <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>关于继承应该用 <code>private</code> 还是 <code>public</code> 的争论<br>虽然 <code>public</code> 继承也可以达到要求，但最好还是用<code>private</code>继承</p><p>原因见《Effective C++》书中以下条款：<br>条款06：若不想使用编译器自动生成的函数，就该明确拒绝<br>条款32：确定你的 <code>public</code> 继承塑造出 is-a 关系<br>条款39：明智而审慎地使用 <code>private</code> 继承</p><h3 id="9-如何减少构造函数开销？-star-2"><a href="#9-如何减少构造函数开销？-star-2" class="headerlink" title="9 如何减少构造函数开销？:star:2"></a>9 如何减少构造函数开销？:star:2</h3><p>在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销，具体原因可以参考本章“为什么用成员初始化列表会快些？”这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>成员初始化列表：在类构造函数中，不在函数体内对变量赋值，而在参数列表后，跟一个冒号和初始化列表。为什么成员初始化列表效率更高？</p><p>答：因为对于非内置类型，少了一次调用默认构造函数的过程。</p><h3 id="10-多重继承时会出现什么状况？如何解决？-star-4"><a href="#10-多重继承时会出现什么状况？如何解决？-star-4" class="headerlink" title="10 多重继承时会出现什么状况？如何解决？:star:4"></a>10 多重继承时会出现什么状况？如何解决？:star:4</h3><p>多重继承（多继承）：是指从多个直接基类中产生派生类。</p><p>多重继承容易出现的问题：命名冲突和数据冗余问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <span class="hljs-comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述程序的继承关系如下：（菱形继承）</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB20.png" width="350px" /></div><p><strong>上述代码中存的问题</strong>：</p><p>对于派生类 <code>Derive</code> 上述代码中存在直接继承关系和间接继承关系。</p><p>直接继承：<code>Base2</code>、<code>Base3</code><br>间接继承：<code>Base1</code><br>对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突。</p><p><strong>解决方法</strong> 1： 声明出现冲突的成员变量来源于哪个类</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="hljs-comment">// 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>解决方法</strong> 2： 虚继承</p><p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p><p>实现方式：在继承方式前面加上 <code>virtual</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 间接基类，即虚基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类之间的继承关系：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB21.png" width="350px" /></div><h3 id="11-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？-star-3"><a href="#11-空类占多少字节？C-编译器会给一个空类自动生成哪些函数？-star-3" class="headerlink" title="11 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？:star:3"></a>11 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？:star:3</h3><p><strong>空类声明时编译器不会生成任何成员函数：</strong></p><p>对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>空类定义时编译器会生成 6 个成员函数：</p><p>当空类 A 定义对象时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class A</span><br><span class="hljs-comment">&#123;&#125;; 该空类的等价写法如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-keyword">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">delete</span> p;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="12-为什么拷贝构造函数必须为引用？-star-2"><a href="#12-为什么拷贝构造函数必须为引用？-star-2" class="headerlink" title="12 为什么拷贝构造函数必须为引用？:star:2"></a>12 为什么拷贝构造函数必须为引用？:star:2</h3><p>原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。</p><p>举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">val</span>(tmp) <span class="hljs-comment">// 带参数构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 拷贝构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>    &#125;<br><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 赋值函数（赋值运算符重载）</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    A ex3 = ex1;<br>    ex2 = ex1;<br>    ex2.<span class="hljs-built_in">fun</span>(ex1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">A &amp;operator=(const A &amp;tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><ul><li><p>说明 1：<code>ex2 = ex1;</code> 和 <code>A ex3 = ex1;</code> 为什么调用的函数不一样？<br>对象 <code>ex2</code> 已经实例化了，不需要构造，此时只是将 <code>ex1</code> 赋值给 <code>ex2</code>，只会调用赋值函数；但是 <code>ex3</code> 还没有实例化，因此调用的是拷贝构造函数，构造出 <code>ex3</code>，而不是赋值函数，这里涉及到构造函数的隐式调用。</p></li><li><p>说明 2：如果拷贝构造函数中形参不是引用类型，<code>A ex3 = ex1;</code> 会出现什么问题？<br>构造 <code>ex3</code>，实质上是 <code>ex3.A(ex1);</code>，假如拷贝构造函数参数不是引用类型，那么将使得 <code>ex3.A(ex1);</code> 相当于 <code>ex1</code> 作为函数 <code>A(const A tmp)</code> 的形参，在参数传递时相当于 <code>A tmp = ex1</code>，因为 <code>tmp</code> 没有被初始化，所以在 <code>A tmp = ex1</code> 中继续调用拷贝构造函数，接下来的是构造 <code>tmp</code>，也就是 <code>tmp.A(ex1)</code> ，必然又会有 <code>ex1</code> 作为函数 <code>A(const A tmp);</code> 的形参，在参数传递时相当于即 <code>A tmp = ex1</code>，那么又会触发拷贝构造函数，就这下永远的递归下去。</p></li><li><p>说明 3：为什么 <code>ex2.fun(ex1);</code> 会调用拷贝构造函数？<br><code>ex1</code> 作为参数传递给 fun 函数， 即 <code>A tmp = ex1;</code>，这个过程会调用拷贝构造函数进行初始化。</p></li></ul><h3 id="13-C-类对象的初始化顺序-star-3"><a href="#13-C-类对象的初始化顺序-star-3" class="headerlink" title="13 C++ 类对象的初始化顺序:star:3"></a>13 C++ 类对象的初始化顺序:star:3</h3><p><strong>构造函数调用顺序</strong>：</p><ul><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；</li></ul><ul><li>按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；</li></ul><ul><li>执行派生类自身的构造函数。</li></ul><p>综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数。</p><p>注：</p><ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关；</li><li>成员变量的初始化顺序与声明顺序有关；</li><li>析构顺序和构造顺序相反。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> :</span> <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B <span class="hljs-comment">// 派生列表</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    B ex1;<br>    A ex2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>程序运行结果分析：</p><ul><li>首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；</li><li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li><li>最后调用派生类的构造函数；</li><li>接下来调用析构函数，和构造函数调用的顺序相反。</li></ul><h3 id="14-如何禁止一个类被实例化？-star-2"><a href="#14-如何禁止一个类被实例化？-star-2" class="headerlink" title="14 如何禁止一个类被实例化？:star:2"></a>14 如何禁止一个类被实例化？:star:2</h3><p>方法一：在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1; <span class="hljs-comment">// error: cannot declare variable &#x27;ex1&#x27; to be of abstract type &#x27;A&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二：将类的构造函数声明为私有 <code>private</code></p><h3 id="15-为什么用成员初始化列表会快一些？-star-3"><a href="#15-为什么用成员初始化列表会快一些？-star-3" class="headerlink" title="15 为什么用成员初始化列表会快一些？:star:3"></a>15 为什么用成员初始化列表会快一些？:star:3</h3><p><strong>说明</strong>：数据类型可分为<u>内置类型</u>和<u>用户自定义类型</u>（类类型），对于用户自定义类型，利用<u>成员初始化列表效率高</u>。</p><p><strong>原因</strong>：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test2</span>() <span class="hljs-comment">// 函数体中赋值的方式</span><br>    &#123;<br>        ex = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test1 ex1;<br>    cout &lt;&lt; endl;<br>    Test2 ex2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">A(int 2)</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。</p><h3 id="16-实例化一个对象需要哪几个阶段-star-3"><a href="#16-实例化一个对象需要哪几个阶段-star-3" class="headerlink" title="16 实例化一个对象需要哪几个阶段:star:3"></a>16 实例化一个对象需要哪几个阶段:star:3</h3><ol><li>分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</li><li>初始化：首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</li><li>赋值：对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</li></ol><p>注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li><li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li></ul><h3 id="17-友元函数的作用及使用场景-star-2"><a href="#17-友元函数的作用及使用场景-star-2" class="headerlink" title="17 友元函数的作用及使用场景:star:2"></a>17 友元函数的作用及使用场景:star:2</h3><p><strong>作用</strong>：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p><p><strong>使用场景</strong>：</p><ol><li><p>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp); <span class="hljs-comment">// 声明为类的友元函数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp)<br>&#123;<br>    _cout &lt;&lt; tmp.var;<br>    <span class="hljs-keyword">return</span> _cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; ex &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>友元类：类之间共享数据。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">var</span>(<span class="hljs-number">10</span>)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl; <span class="hljs-comment">// 访问类 A 中的私有成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    A ex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B ex;<br>    ex.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun():10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="18-静态绑定和动态绑定是怎么实现的？-star-3"><a href="#18-静态绑定和动态绑定是怎么实现的？-star-3" class="headerlink" title="18 静态绑定和动态绑定是怎么实现的？:star:3"></a>18 静态绑定和动态绑定是怎么实现的？:star:3</h3><p><strong>静态类型和动态类型</strong>：</p><ul><li>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</li><li>动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。</li></ul><p><strong>静态绑定和动态绑定</strong>：</p><ul><li>静态绑定是指程序在 编译阶段 确定对象的类型（静态类型）。</li><li>动态绑定是指程序在 运行阶段 确定对象的类型（动态类型）。</li></ul><p><strong>静态绑定和动态绑定的区别</strong>：</p><ul><li><p>发生的时期不同：如上。</p></li><li><p>对象的静态类型不能更改，动态类型可以更改。</p></li></ul><p>注：<u>对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>     &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span>; <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(); <span class="hljs-comment">// p 的静态类型是 Base*，动态类型是 Derive*</span><br>    p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun 是虚函数，运行阶段进行动态绑定</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Derive::fun()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="19-深拷贝和浅拷贝的区别-star-5"><a href="#19-深拷贝和浅拷贝的区别-star-5" class="headerlink" title="19 深拷贝和浅拷贝的区别 :star:5"></a>19 深拷贝和浅拷贝的区别 :star:5</h3><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。</p><ul><li><p>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</p></li><li><p>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</p></li></ul><p>当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。</p><p><strong>浅拷贝实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p><p><strong>深拷贝实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;tmp) <span class="hljs-comment">// 定义拷贝构造函数</span><br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*tmp.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">Test(const Test &amp;tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="20-编译时多态和运行时多态的区别-star-3"><a href="#20-编译时多态和运行时多态的区别-star-3" class="headerlink" title="20 编译时多态和运行时多态的区别:star:3"></a>20 编译时多态和运行时多态的区别:star:3</h3><p>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。</p><p>运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。</p><p><strong>编译时多态和运行时多态的区别</strong>：</p><ul><li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li><li>实现方式不同：编译时多态运用<u>泛型编程</u>来实现，运行时多态借助<u>虚函数</u>来实现。</li></ul><h3 id="21-实现一个类成员函数，要求不允许修改类的成员变量？-star-2"><a href="#21-实现一个类成员函数，要求不允许修改类的成员变量？-star-2" class="headerlink" title="21 实现一个类成员函数，要求不允许修改类的成员变量？:star:2"></a>21 实现一个类成员函数，要求不允许修改类的成员变量？:star:2</h3><p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 <code>const</code> 关键字来修饰该函数即可。</p><p>该问题本质是考察 <code>const</code> 关键字修饰成员函数的作用，只不过以实例的方式来考察，面试者应熟练掌握 <code>const</code> 关键字的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>() &#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span><br><span class="hljs-function">    </span>&#123;<br>        var1 = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="22-如何让类不能被继承？-star-3"><a href="#22-如何让类不能被继承？-star-3" class="headerlink" title="22 如何让类不能被继承？:star:3"></a>22 如何让类不能被继承？:star:3</h3><p>解决方法一：借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span>:</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>解决方法二：借助友元、虚继承和私有构造函数来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br>    <span class="hljs-keyword">friend</span> T;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&lt;B&gt;&#123;   <span class="hljs-comment">//一定注意 必须是虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>()&#123;&#125;     <span class="hljs-comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B b;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：在上述代码中 B 类是不能被继承的类。具体原因：</p><ul><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ul><p>注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_4关键字和库函数</title>
    <link href="/2021/09/04/C++%E9%9D%A2%E8%AF%95_4%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2021/09/04/C++%E9%9D%A2%E8%AF%95_4%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>C++ 常用关键字以及库函数介绍。</p><span id="more"></span><h3 id="1-sizeof-和-strlen-的区别-star-3"><a href="#1-sizeof-和-strlen-的区别-star-3" class="headerlink" title="1 sizeof 和 strlen 的区别 :star:3"></a>1 sizeof 和 strlen 的区别 :star:3</h3><ol><li><p><code>strlen</code>  是头文件 <code>&lt;cstring&gt;</code> 中的函数，<code>sizeof</code> 是 C++ 中的运算符。</p></li><li><p><code>strlen</code> 测量的是字符串的实际长度（其源代码如下），以 <code>\0</code>  结束。而 sizeof 测量的是字符数组的分配大小。</p><p><code>strlen</code> 源代码:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str++)<br>        ++length;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">strlen</span>(arr) &lt;&lt; endl; <span class="hljs-comment">// 5</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>若字符数组 arr 作为函数的形参，<code>sizeof(arr)</code> 中 arr 被当作字符指针来处理，<code>strlen(arr)</code> 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">size_of</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arr[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="hljs-comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span><br>    cout &lt;&lt; <span class="hljs-built_in">strlen</span>(arr) &lt;&lt; endl; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">size_of</span>(arr); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">8// 64 位机器，指针大小是8</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>strlen</code> 本身是库函数，因此在程序运行过程中，计算长度；而 <code>sizeof</code> 在编译时，计算长度；</p></li><li><p><code>sizeof</code> 的参数可以是类型，也可以是变量；<code>strlen</code> 的参数必须是 <code>char*</code> 类型的变量。</p></li></ol><h3 id="2-lambda-表达式（匿名函数）的具体应用和使用场景-star-3"><a href="#2-lambda-表达式（匿名函数）的具体应用和使用场景-star-3" class="headerlink" title="2 lambda 表达式（匿名函数）的具体应用和使用场景 :star:3"></a>2 lambda 表达式（匿名函数）的具体应用和使用场景 :star:3</h3><p><code>lambda</code> 表达式的定义形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[capture list] (parameter list) -&gt; reurn type<br>&#123;<br>   function body<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><p>举例：<code>lambda</code> 表达式常搭配排序算法使用。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">76</span>, <span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">90</span>, <span class="hljs-number">34</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;); <span class="hljs-comment">// 降序排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : arr)<br>    &#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：90 76 54 34 12 4 3</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="3-explicit-的作用（如何避免编译器进行隐式类型转换）-star-3"><a href="#3-explicit-的作用（如何避免编译器进行隐式类型转换）-star-3" class="headerlink" title="3 explicit 的作用（如何避免编译器进行隐式类型转换） :star:3"></a>3 explicit 的作用（如何避免编译器进行隐式类型转换） :star:3</h3><p>作用：用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 <code>explicit</code> 关键字也没有什么意义。</p><p>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        var = tmp;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex = <span class="hljs-number">10</span>; <span class="hljs-comment">// 发生了隐式转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中，<code>A ex = 10;</code>  在编译时，进行了隐式转换，将 <code>10</code> 转换成 <code>A</code> 类型的对象，然后将该对象赋值给 <code>ex</code>，等同于如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>为了避免隐式转换，可用 <code>explicit</code> 关键字进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        var = tmp;<br>        cout &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-C-和-C-static-的区别-star-1"><a href="#4-C-和-C-static-的区别-star-1" class="headerlink" title="4 C 和 C++ static 的区别 :star:1"></a>4 C 和 C++ static 的区别 :star:1</h3><ul><li>在 C 语言中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数</li><li>在 C++ 中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</li></ul><h3 id="5-static-的作用-star-4"><a href="#5-static-的作用-star-4" class="headerlink" title="5 static 的作用 :star:4"></a>5 static 的作用 :star:4</h3><p><code>static</code> 定义静态变量，静态函数。</p><ul><li><p><strong>保持变量内容持久</strong>：<code>static</code> 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>; <span class="hljs-comment">// var 只在第一次进入这个函数的时初始化</span><br>    var += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> var;<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">fun</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 2 3 4 5 6 7 8 9 10 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>隐藏</strong>：<code>static</code> 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</p></li><li><p><code>static</code> 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 静态成员变量</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; s_var++ &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s_show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; s_var &lt;&lt; endl;<br><span class="hljs-comment">// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span><br>        <span class="hljs-comment">// show();  // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> A::s_var = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 静态成员变量在类外进行初始化赋值，默认初始化为 0</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// cout &lt;&lt; A::sa &lt;&lt; endl;    // error: &#x27;int A::sa&#x27; is private within this context</span><br>    A ex;<br>    ex.<span class="hljs-built_in">show</span>();<br>    A::<span class="hljs-built_in">s_show</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-static-在类中使用的注意事项（定义、初始化和使用）-star-5"><a href="#6-static-在类中使用的注意事项（定义、初始化和使用）-star-5" class="headerlink" title="6 static 在类中使用的注意事项（定义、初始化和使用）:star: 5"></a>6 static 在类中使用的注意事项（定义、初始化和使用）:star: 5</h3><p><strong>static 静态成员变量：</strong></p><ol><li>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 <code>static</code> 关键字和 <code>private</code>、<code>public</code>、<code>protected</code> 访问规则。</li><li>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</li><li>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = s_var)</span></span>; <span class="hljs-comment">// 正确，静态成员变量可以作为成员函数的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = var)</span></span>;   <span class="hljs-comment">//  error: invalid use of non-static data member &#x27;A::var&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> A s_var; <span class="hljs-comment">// 正确，静态数据成员</span><br>    A var;          <span class="hljs-comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span><br>    A *p;           <span class="hljs-comment">// 正确，指针</span><br>    A &amp;var1;        <span class="hljs-comment">// 正确，引用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>static 静态成员函数：</strong></p><ol><li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 <code>this</code> 指针。静态成员函数做为类作用域的全局函数。</li><li>静态成员函数不能声明成虚函数（<code>virtual</code>）、<code>const</code> 函数和 <code>volatile</code> 函数。</li></ol><p><strong>为何 static 成员函数不能为 virtual：</strong></p><ol><li><code>static</code> 成员不属于任何类对象或类实例，所以即使给此函数加上 <code>virutal</code> 也是没有任何意义的。</li><li>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有 <code>this</code> 指针。<ul><li>虚函数依靠 <code>vptr</code> 和 <code>vtable</code> 来处理。<code>vptr</code> 是一个指针，在类的构造函数中创建生成，并且只能用 <code>this</code> 指针来访问它，因为它是类的一个成员，并且 <code>vptr</code> 指向保存虚函数地址的 <code>vtable</code>；</li><li>对于静态成员函数，它没有 <code>this</code> 指针，所以无法访问 <code>vptr</code>。 这就是为何 <code>static</code> 函数不能为 <code>virtual</code>。</li><li>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</li></ul></li></ol><p><strong>为何 static 成员函数不能为 const 函数：</strong></p><ol><li>当声明一个非静态成员函数为 <code>const</code> 时，对 <code>this</code> 指针会有影响。对于一个 <code>Test</code> 类中的 <code>const</code> 修饰的成员函数，<code>this</code> 指针相当于 <code>Test const *</code>，而对于非 <code>const</code> 成员函数，<code>this</code> 指针相当于 <code>Test *</code>；</li><li>而 <code>static</code> 成员函数没有 <code>this</code> 指针，所以使用 <code>const</code> 来修饰 <code>static</code> 成员函数没有任何意义。</li><li><code>volatile</code> 的道理也是如此。</li></ol><h3 id="7-static-全局变量和普通全局变量的异同-star-3"><a href="#7-static-全局变量和普通全局变量的异同-star-3" class="headerlink" title="7 static 全局变量和普通全局变量的异同 :star:3"></a>7 static 全局变量和普通全局变量的异同 :star:3</h3><p><strong>相同点</strong>：</p><p>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</p><p><strong>不同点</strong>：</p><p>作用域：<u>普通全局变量</u>的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；<u>静态全局变量</u>则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。<br>初始化：静态全局变量只初始化一次，防止在其他文件中使用。全局变量只初始化一次，不管是静态的还是普通的。</p><h3 id="8-const-作用及用法-star-3"><a href="#8-const-作用及用法-star-3" class="headerlink" title="8 const 作用及用法 :star:3"></a>8 const 作用及用法 :star:3</h3><p><strong>作用</strong>：</p><ul><li><code>const</code> 修饰成员变量，定义成 <code>const</code> 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li><li><code>const</code> 修饰函数参数，使得传递过来的函数参数的值不能改变。</li><li><code>const</code> 修饰成员函数，使得成员函数不能修改任何类型的成员变量（<code>mutable</code> 修饰的变量除外），也不能调用非 <code>const</code> 成员函数，因为非 <code>const</code> 成员函数可能会修改成员变量。</li></ul><p><strong>在类中的用法</strong>：</p><p><code>const</code> 成员变量：</p><ul><li><code>const</code> 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li><li><code>const</code> 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 <code>const</code> 成员变量的值是不同的。因此不能在类的声明中初始化 <code>const</code> 成员变量，类的对象还没有创建，编译器不知道他的值。</li></ul><p><code>const</code> 成员函数：</p><ul><li>不能修改成员变量的值，除非有 <code>mutable</code> 修饰；只能访问成员变量。</li><li>不能调用非常量成员函数，以防修改成员变量的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> var;<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c_fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// const 成员函数</span></span><br><span class="hljs-function"></span>&#123;<br>var = tmp; <span class="hljs-comment">// error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。</span><br><span class="hljs-built_in">fun</span>(tmp); <span class="hljs-comment">// error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span><br><span class="hljs-function"></span>&#123;<br>var = tmp;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-define-和-const-的区别-star-3"><a href="#9-define-和-const-的区别-star-3" class="headerlink" title="9 define 和 const 的区别 :star:3"></a>9 define 和 const 的区别 :star:3</h3><p><strong>区别</strong>：</p><ul><li><p><strong>编译阶段</strong>：<code>define</code> 是在编译预处理阶段进行替换，<code>const</code> 是在编译阶段确定其值。</p></li><li><p><strong>安全性</strong>：<code>define</code> 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；<code>const</code> 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</p></li><li><p><strong>内存占用</strong>：<code>define</code> 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；<code>const</code> 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</p><p><code>const</code> 局部变量存储在栈区，<code>const</code> 全局变量存储在已初始化数据段 ( 只读数据段 )。</p></li><li><p><strong>调试</strong>：<code>define</code> 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；<code>const</code> 定义的常量可以进行调试。</p></li></ul><p><strong>const 的优点</strong>：</p><ul><li>有数据类型，在定义时可进行安全性检查。</li><li>可调试。</li><li>占用较少的空间。</li></ul><h3 id="10-define-和-typedef-的区别-star-2"><a href="#10-define-和-typedef-的区别-star-2" class="headerlink" title="10 define 和 typedef 的区别 :star:2"></a>10 define 和 typedef 的区别 :star:2</h3><ul><li><strong>原理</strong>：<code>#define</code> 作为预处理指令，在编译预处理时进行<u>替换</u>操作，不做正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。<code>typedef</code> 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 <code>typedef</code> 。</li><li><strong>功能</strong>：<code>typedef</code> 用来定义类型的别名，方便使用。<code>#define</code> 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li><strong>作用域</strong>：<code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 <code>typedef</code> 有自己的作用域。</li><li><strong>指针的操作</strong>：<code>typedef</code> 和 <code>#define</code> 在处理指针时不完全一样。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTPTR1 int *</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> * INTPTR2;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    INTPTR1 p1, p2; <span class="hljs-comment">// p1: int *; p2: int</span><br>    <span class="hljs-comment">// 上述表达式的等价写法: int * p1, p2;</span><br>    INTPTR2 p3, p4; <span class="hljs-comment">// p3: int *; p4: int *</span><br><br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> INTPTR1 p5 = &amp;var; <span class="hljs-comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span><br>    <span class="hljs-keyword">const</span> INTPTR2 p6 = &amp;var; <span class="hljs-comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="11-用宏实现比较大小，以及两个数中的最小值-star-1"><a href="#11-用宏实现比较大小，以及两个数中的最小值-star-1" class="headerlink" title="11 用宏实现比较大小，以及两个数中的最小值 :star:1"></a>11 用宏实现比较大小，以及两个数中的最小值 :star:1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var1 = <span class="hljs-number">10</span>, var2 = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">MAX</span>(var1, var2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">MIN</span>(var1, var2) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序运行结果：</span><br><span class="hljs-comment">100</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>如果去掉宏定义中的括号，某些时候就会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(X, Y) (X &gt; Y ? X : Y)</span><br><span class="hljs-built_in">MAX</span>(<span class="hljs-number">5</span>+<span class="hljs-number">6</span>, <span class="hljs-number">6</span>+<span class="hljs-number">7</span>) =&gt; (<span class="hljs-number">5</span> + <span class="hljs-number">6</span> &gt; <span class="hljs-number">6</span> + <span class="hljs-number">7</span> ? <span class="hljs-number">5</span> + <span class="hljs-number">6</span> : <span class="hljs-number">6</span> + <span class="hljs-number">7</span>)<br></code></pre></div></td></tr></table></figure><h3 id="12-inline-作用及使用方法-star-3"><a href="#12-inline-作用及使用方法-star-3" class="headerlink" title="12 inline 作用及使用方法 :star:3"></a>12 inline 作用及使用方法 :star:3</h3><p><strong>关键字 <code>inline</code>  内联函数的作用：</strong></p><p>内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开。这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p><ol><li><p>消除函数调用的开销。</p><p>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能（因为使用 #define 定义的那些“函数”，编译器不会检查其参数的正确性等，而使用 inline 定义的函数，和普通函数一样，可以被编译器检查，这样有利于尽早发现错误）。</p></li><li><p>去除函数只能定义一次的限制。<br>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p></li></ol><p><strong>关于减少函数调用的开销</strong>：</p><ol><li><p>内联函数一定会被编译器在调用点展开吗？</p><p>错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</p></li><li><p>“调用” 普通函数时，一定是调用吗？</p><p>错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。</p></li><li><p>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？</p><p>错。首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内敛函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</p></li></ol><p><strong>关于去除函数只能定义一次的限制</strong>：</p><ul><li><p>下述程序会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;function 1&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 文件2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;function 2&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">myPrint</span>();  <span class="hljs-comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>下述程序不会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;inline function 1&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 文件2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;inline function 2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">myPrint</span>()<span class="hljs-comment">// 正常运行;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>可见，内联函数可以在头文件中定义（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）。</p><p><strong>使用方法</strong>：</p><ol><li><p>类内定义成员函数默认是内联函数。</p><p>在类内定义成员函数，可以不用在函数头部加 <code>inline</code> 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)&#123; <br>      var = tmp;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123; <br>        cout &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>类外定义成员函数，若想定义为内联函数，需用关键字声明.。</p><p>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 <code>inline</code> 关键字，而在类外定义函数时加上 <code>inline</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)&#123; <br>      var = tmp;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 类内声明不加 inline 关键字</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">A::fun</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 类外定义函数时加上 inline 关键字</span><br>    cout &lt;&lt; var &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>另外，可以在声明函数和定义函数的同时加上 <code>inline</code> ；也可以只在函数声明时加 <code>inline</code>，而定义函数时不加 <code>inline</code> 。只要确保在调用该函数之前把 <code>inline</code> 的信息告知编译器即可。</p></li></ol><h3 id="13-inline-函数工作原理-star-2"><a href="#13-inline-函数工作原理-star-2" class="headerlink" title="13 inline 函数工作原理 :star:2"></a>13 inline 函数工作原理 :star:2</h3><ul><li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li><li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li></ul><h3 id="14-宏定义（define）和内联函数（inline）的区别-star-2"><a href="#14-宏定义（define）和内联函数（inline）的区别-star-2" class="headerlink" title="14 宏定义（define）和内联函数（inline）的区别 :star:2"></a>14 宏定义（define）和内联函数（inline）的区别 :star:2</h3><ul><li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li><li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li><li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fun_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">MAX</span>(var, <span class="hljs-number">5</span>) &lt;&lt; endl;     <br>    cout &lt;&lt; <span class="hljs-built_in">fun_max</span>(var, <span class="hljs-number">0</span>) &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序运行结果：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="15-new-的作用？-star-2"><a href="#15-new-的作用？-star-2" class="headerlink" title="15 new 的作用？:star:2"></a>15 new 的作用？:star:2</h3><p><code>new</code> 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <br></code></pre></div></td></tr></table></figure><h3 id="16-new-和-malloc-如何判断是否申请到内存？-star-2"><a href="#16-new-和-malloc-如何判断是否申请到内存？-star-2" class="headerlink" title="16 new 和 malloc 如何判断是否申请到内存？ :star:2"></a>16 new 和 malloc 如何判断是否申请到内存？ :star:2</h3><p><code>malloc</code>：成功申请到内存，返回指向该内存的指针；分配失败，返回 <code>NULL</code> 指针。<br><code>new</code>：内存分配成功，返回该对象类型的指针；分配失败，抛出 <code>bad_alloc</code> 异常。</p><h3 id="17-delete-实现原理？delete-和-delete-的区别？-star-3"><a href="#17-delete-实现原理？delete-和-delete-的区别？-star-3" class="headerlink" title="17 delete 实现原理？delete 和 delete[] 的区别？ :star:3"></a>17 delete 实现原理？delete 和 delete[] 的区别？ :star:3</h3><p><code>delete</code> 的实现原理：</p><ul><li>首先执行该对象所属类的析构函数；</li><li>进而通过调用 <code>operator delete</code> 的标准库函数来释放所占的内存空间。</li></ul><p><code>delete</code> 和 <code>delete []</code> 的区别：</p><ul><li><code>delete</code> 用来释放单个对象所占的空间，只会调用一次析构函数；</li><li><code>delete []</code> 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li></ul><h3 id="18-new-和-malloc-的区别，delete-和-free-的区别-star-4"><a href="#18-new-和-malloc-的区别，delete-和-free-的区别-star-4" class="headerlink" title="18 new 和 malloc 的区别，delete 和 free 的区别 :star:4"></a>18 new 和 malloc 的区别，delete 和 free 的区别 :star:4</h3><p>使用搭配：<code>malloc</code> 和 <code>free</code>  ； <code>new</code> 和 <code>delete</code> 。</p><ul><li><p><code>malloc</code>、<code>free</code> 是库函数，而 <code>new</code> 、<code>delete</code> 是关键字。</p><p><code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</p></li><li><p><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 <code>void*</code> 类型，需要进行强制类型的转换，转换为对象类型的指针。</p></li><li><p><code>new</code> 分配失败时，会抛出 <code>bad_alloc</code> 异常；<code>malloc</code> 分配失败时返回空指针。</p></li><li><p>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 <code>free</code> 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。</p></li><li><p><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</p></li></ul><p><strong>堆区和自由存储区的区别与联系</strong>：</p><ul><li>malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放</li><li>堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</li></ul><p><strong>记住</strong>：</p><ul><li>堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。</li><li>new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。</li><li>堆和自由内存区有相同之处，但并不等价。</li></ul><h3 id="19-malloc-的原理？malloc-的底层实现？-star-2"><a href="#19-malloc-的原理？malloc-的底层实现？-star-2" class="headerlink" title="19 malloc 的原理？malloc 的底层实现？:star:2"></a>19 malloc 的原理？malloc 的底层实现？:star:2</h3><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p><code>malloc</code> 的原理：</p><ul><li>当开辟的空间小于 128K 时，调用 <code>brk()</code> 函数，它将数据段 (.data) 的最高地址指针  <code>_enddata</code> 往高地址推；</li><li>当开辟空间大于 128K 时，调用 <code>mmap()</code> 函数，通过在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li></ul><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p><strong>问题</strong>：为什么在默认的情况下，malloc 函数分配内存时，如果请求内存大于 128 K（可由 M_MMAP_THRESHOLD 选项调节），就不是去推 <code>_edata</code> 指针，而是利用 mmap 系统调用，从堆和栈的中间分配一块虚拟内存？</p><p><strong>答案</strong>：因为 brk 分配的内存需要等到高地址内存释放之后才能释放，而 mmap 分配的内存可以单独释放。</p><p>参考资料：<a href="https://www.cnblogs.com/dongzhiquan/p/5621906.html">linux环境内存分配原理—虚拟内存</a></p><h3 id="20-C-和-C-struct-的区别？-star-2"><a href="#20-C-和-C-struct-的区别？-star-2" class="headerlink" title="20 C 和 C++ struct 的区别？:star:2"></a>20 C 和 C++ struct 的区别？:star:2</h3><ul><li>在 C 语言中 <code>struct</code> 是用户自定义数据类型；在 C++ 中 <code>struct</code> 是抽象数据类型，支持成员函数的定义。</li><li>C 语言中 <code>struct</code> 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 <code>struct</code> 可以和类一样，有访问权限，并可以定义成员函数。</li><li>C 语言中 <code>struct</code> 定义的自定义数据类型，在定义该类型的变量时，需要加上 <code>struct</code> 关键字，例如：<code>struct A var;</code> ，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：<code>A var</code>;</li></ul><h3 id="21-为什么有了-class-还保留-struct？-star-2"><a href="#21-为什么有了-class-还保留-struct？-star-2" class="headerlink" title="21 为什么有了 class 还保留 struct？:star:2"></a>21 为什么有了 class 还保留 struct？:star:2</h3><p>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 <code>struct</code>。</p><h3 id="22-struct-和-union-的区别-star-2"><a href="#22-struct-和-union-的区别-star-2" class="headerlink" title="22 struct 和 union 的区别 :star:2"></a>22 struct 和 union 的区别 :star:2</h3><p>说明：<code>union</code> 是联合体，<code>struct</code> 是结构体。</p><p>区别：</p><ul><li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li><li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li><li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">char</span> cc1; <span class="hljs-comment">// char 1 字节，按该类型的倍数分配大小</span><br>&#125; u11;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// int 4 字节，按该类型的倍数分配大小</span><br>&#125; u22;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// double 8 字节，按该类型的倍数分配大小</span><br>&#125; u33;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s1</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br>&#125; s11;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s2</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">char</span> cc;  <span class="hljs-comment">// 1（char）+ 1（char）= 2 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 2 + 6（内存对齐）+ 8（double）= 16 字节</span><br>&#125; s22;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;   <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">double</span> d; <span class="hljs-comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span><br>    <span class="hljs-keyword">char</span> cc;  <span class="hljs-comment">// 16 + 1（char）+ 7（内存对齐）= 24 字节</span><br>&#125; s33;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u11) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u22) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(u33) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s11) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s22) &lt;&lt; endl; <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s33) &lt;&lt; endl; <span class="hljs-comment">// 24</span><br><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) &lt;&lt; endl;    <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="23-class-和-struct-的异同-star-2"><a href="#23-class-和-struct-的异同-star-2" class="headerlink" title="23 class 和 struct 的异同 :star:2"></a>23 class 和 struct 的异同 :star:2</h3><ul><li><p><code>struct</code> 和 <code>class</code> 都可以自定义数据类型，也支持继承操作。</p></li><li><p><code>struct</code> 中默认的访问级别是 <code>public</code> ，默认的继承级别也是 <code>public</code> ；class 中默认的访问级别是 <code>private</code>，默认的继承级别也是 <code>private</code>。</p></li><li><p>当 <code>class</code> 继承 <code>struct</code> 或者 <code>struct</code> 继承 <code>class</code> 时，默认的继承级别取决于 <code>class</code> 或 <code>struct</code> 本身， <code>class</code>（<code>private</code>继承），<code>struct</code>（<code>public</code> 继承），即取决于派生类的默认继承级别。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span>&#125;；<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> A&#123;&#125;; <span class="hljs-comment">// private 继承 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> :</span> B&#123;&#125;； <span class="hljs-comment">// public 继承</span><br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funA</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>:</span> A &#123; <span class="hljs-comment">// 由于 B 是 struct，A 的默认继承级别为 public</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funB</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> B &#123; <span class="hljs-comment">// 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 funB 函数</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A ex1;<br>    ex1.<span class="hljs-built_in">funA</span>(); <span class="hljs-comment">// class A</span><br><br>    B ex2;<br>    ex2.<span class="hljs-built_in">funA</span>(); <span class="hljs-comment">// class A</span><br>    ex2.<span class="hljs-built_in">funB</span>(); <span class="hljs-comment">// class B</span><br><br>    C ex3;<br>    ex3.<span class="hljs-built_in">funB</span>(); <span class="hljs-comment">// error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/luoweifu/article/details/46953343">C++的三种访问权限与三种继承方式</a></p></li></ul><h3 id="24-volatile-的作用？是否具有原子性，对编译器有什么影响？-star-2"><a href="#24-volatile-的作用？是否具有原子性，对编译器有什么影响？-star-2" class="headerlink" title="24 volatile 的作用？是否具有原子性，对编译器有什么影响？ :star:2"></a>24 volatile 的作用？是否具有原子性，对编译器有什么影响？ :star:2</h3><p><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>volatile</code>，告知编译器不应对这样的对象进行优化。</p><p><code>volatile</code> 不具有原子性。</p><p><code>volatile</code> 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p><blockquote><p>《程序员的自我修养》原话：</p></blockquote><p>我们可以使用 <code>volatile</code> 关键字试图阻止过度优化，<code>volatile</code>  基本可以做到两件事情：</p><ol><li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）；</li><li>阻止编译器调整操作 <code>volatile</code> 变量的指令排序。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 即使 `volatile` 能够阻止编译器调整顺序，也无法阻止 CPU 动态调度换序。</span><br><br><span class="hljs-comment">// 要保证线程安全，阻止 CPU 换序是必须的。遗憾的是，现在并不存在可移植的阻止换序的方法。</span><br><span class="hljs-comment">//通常情况下是调用 CPU 提供的一条指令，这条指令常常被称为 barrier。</span><br><span class="hljs-comment">// 一条 barrier 指令会阻止 CPU 将该指令之前的指令交换到 barrier 之后。</span><br></code></pre></div></td></tr></table></figure><p>对 <code>volatile</code> 的三点理解：</p><ol><li>只能保证赋值原子性，复合操作不能保证；</li><li>告诉编译器不进行指令重排（ JMM 中还会追加 CPU 内存屏障），以避免过度优化；</li><li>保证内存可见性。</li></ol><h3 id="25-什么情况下一定要用-volatile，-能否和-const-一起使用？-star-2"><a href="#25-什么情况下一定要用-volatile，-能否和-const-一起使用？-star-2" class="headerlink" title="25 什么情况下一定要用 volatile， 能否和 const 一起使用？:star:2"></a>25 什么情况下一定要用 volatile， 能否和 const 一起使用？:star:2</h3><p>使用  <code>volatile</code> 关键字的场景：</p><ul><li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用  <code>volatile</code> 关键字对该变量进行修饰；</li><li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用  <code>volatile</code> 关键字修饰。</li><li><code>volatile</code> 关键字和 <code>const</code> 关键字可以同时使用，某种类型可以既是 <code>volatile</code> 又是 <code>const</code>，同时具有二者的属性。</li></ul><p>解决多线程中变量同步问题，最好使用 <code>automic</code> 保持吧，<code>volatile</code> 并不一定能够保持。</p><h3 id="26-返回函数中静态变量的地址会发生什么？-star-2"><a href="#26-返回函数中静态变量的地址会发生什么？-star-2" class="headerlink" title="26 返回函数中静态变量的地址会发生什么？:star:2"></a>26 返回函数中静态变量的地址会发生什么？:star:2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">10</span>;<br>    var *= tmp;<br>    <span class="hljs-keyword">return</span> &amp;var;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; *<span class="hljs-built_in">fun</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">50</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p>说明：上述代码中在函数 fun 中定义了静态局部变量 <code>var</code>，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p><h3 id="27-extern-C-的作用？-star-2"><a href="#27-extern-C-的作用？-star-2" class="headerlink" title="27 extern C 的作用？:star:2"></a>27 extern C 的作用？:star:2</h3><p>当 C++ 程序需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>C++ 和 C语言编译函数签名方式不一样， extern关键字可以让两者保持统一，这样才能找到对应的函数。</p><h3 id="28-sizeof-1-1-在-C-和-C-中分别是什么结果？-star-1"><a href="#28-sizeof-1-1-在-C-和-C-中分别是什么结果？-star-1" class="headerlink" title="28 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？:star:1"></a>28 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？:star:1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// C 语言</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">1</span>==<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// sizeof（1 == 1） === sizeof（1）</span><br><span class="hljs-comment">// 按照整数处理，所以是4字节，这里也有可能是8字节（看操作系统）</span><br><br><br><span class="hljs-comment">// C++</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">1</span>==<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 因为有bool 类型</span><br><span class="hljs-comment">// sizeof（1 == 1） == sizeof（true） 按照bool类型处理，所以是1个字节</span><br><br></code></pre></div></td></tr></table></figure><h3 id="29-memcpy-函数的底层原理？-star-3"><a href="#29-memcpy-函数的底层原理？-star-3" class="headerlink" title="29 memcpy 函数的底层原理？:star:3"></a>29 memcpy 函数的底层原理？:star:3</h3><p>参考资料：<a href="https://blog.csdn.net/yuanrxdu/article/details/23771459">关于C函数memcpy的实现细节思考</a></p><h3 id="30-strcpy-函数有什么缺陷？-star-2"><a href="#30-strcpy-函数有什么缺陷？-star-2" class="headerlink" title="30 strcpy 函数有什么缺陷？:star:2"></a>30 strcpy 函数有什么缺陷？:star:2</h3><p><code>strcpy</code> 函数的缺陷：<code>strcpy</code> 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">0x11112222</span>;<br>    <span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;<br>    <span class="hljs-built_in">strcpy</span>(arr, <span class="hljs-string">&quot;hello world!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="hljs-comment">// 将变量 var 以 16 进制输出</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Address : var 0x23fe4c</span><br><span class="hljs-comment">Address : arr 0x23fe42</span><br><span class="hljs-comment">var:11002164</span><br><span class="hljs-comment">arr:hello world!</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>说明</strong>：从上述代码中可以看出，变量 <code>var</code> 的后六位被字符串 <code>&quot;hello world!&quot;</code> 的 <code>&quot;d!\0&quot;</code> 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：<code>\0</code> (0x00)，<code>!</code> (0x21)，<code>d</code> (0x64)。</p><p><strong>原因</strong>：变量 <code>arr</code> 只分配的 10 个内存空间，通过上述程序中的地址可以看出 <code>arr</code> 和 <code>var</code> 在内存中是连续存放的，但是在调用 <code>strcpy</code> 函数进行拷贝时，源字符串 <code>&quot;hello world!&quot;</code> 所占的内存空间为 13，因此在拷贝的过程中会占用 <code>var</code> 的内存空间，导致 <code>var</code> 的后六位被覆盖。</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB8.png" width="550px" /></div><h3 id="31-auto-类型推导的原理-star-2"><a href="#31-auto-类型推导的原理-star-2" class="headerlink" title="31 auto 类型推导的原理:star:2"></a>31 auto 类型推导的原理:star:2</h3><p><code>auto</code> 类型推导的原理：</p><p>编译器根据初始值来推算变量的类型，要求用 <code>auto</code> 定义变量时必须有初始值。编译器推断出来的 <code>auto</code> 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_3面向对象</title>
    <link href="/2021/09/03/C++%E9%9D%A2%E8%AF%95_3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/09/03/C++%E9%9D%A2%E8%AF%95_3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象的理解、三大特性、多态。</p><span id="more"></span><h3 id="1-什么是面向对象？面向对象的三大特性-star-5"><a href="#1-什么是面向对象？面向对象的三大特性-star-5" class="headerlink" title="1 什么是面向对象？面向对象的三大特性 :star:5"></a>1 什么是面向对象？面向对象的三大特性 :star:5</h3><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p><p>面向对象的三大特性：</p><ul><li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为，子类有父类的非 <code>private</code> 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 <code>final</code> 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li></ul><h3 id="2-重载、重写、隐藏的区别-star-5"><a href="#2-重载、重写、隐藏的区别-star-5" class="headerlink" title="2 重载、重写、隐藏的区别 :star:5"></a>2 重载、重写、隐藏的区别 :star:5</h3><ul><li><strong>重载</strong>：同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">float</span> tmp)</span></span>;        <span class="hljs-comment">// 重载 参数类型不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp, <span class="hljs-keyword">float</span> tmp1)</span></span>; <span class="hljs-comment">// 重载 参数个数不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">float</span> tmp, <span class="hljs-keyword">int</span> tmp1)</span></span>; <span class="hljs-comment">// 重载 参数顺序不同（相对于上一个函数）</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>;            <span class="hljs-comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>隐藏</strong>：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp, <span class="hljs-keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 隐藏基类中的同名函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive ex;<br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// Derive::fun(int tmp)</span><br>    ex.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.01</span>); <span class="hljs-comment">// error: candidate expects 1 argument, 2 provided</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：上述代码中 <code>ex.fun(1, 0.01);</code> 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 <code>ex.Base::fun(1, 0.01);</code>，这样就可以调用基类中的同名函数。</p></li></ul><ul><li><p><strong>重写</strong>(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 <code>virtual</code> 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="hljs-comment">// 重写基类中的 fun 函数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    p-&gt;<span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// Derived::fun(int) : 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>重写和重载的区别</strong>：</p><ul><li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li><li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 <code>virtual</code> 修饰。</li><li><code>virtual</code> 关键字：重写的函数基类中必须有 <code>virtua</code> 关键字的修饰，重载的函数可以有 <code>virtual</code> 关键字的修饰也可以没有。</li></ul><p><strong>隐藏和重写，重载的区别</strong>：</p><ul><li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li><li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 <code>virtual</code> 修饰，基类函数都是被隐藏，而不是重写。</li></ul><h3 id="3-如何理解-C-是面向对象编程-star-3"><a href="#3-如何理解-C-是面向对象编程-star-3" class="headerlink" title="3 如何理解 C++ 是面向对象编程 :star:3"></a>3 如何理解 C++ 是面向对象编程 :star:3</h3><ul><li>面向过程编程：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li></ul><ul><li>面向对象编程（Object-Oriented Programming, OOP）：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</li></ul><p><strong>面向对象编程进一步说明</strong>：</p><p>面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（<code>public、private、protected</code>），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</p><h3 id="4-什么是多态？多态如何实现？-star-5"><a href="#4-什么是多态？多态如何实现？-star-5" class="headerlink" title="4 什么是多态？多态如何实现？ :star:5"></a>4 什么是多态？多态如何实现？ :star:5</h3><p><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 <code>virtual</code> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p><p><strong>实现方法</strong>：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><p><strong>实现过程</strong>：</p><ol><li>在类中用 <code>virtual</code> 关键字声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（<u>虚函数表和类对应的，虚表指针是和对象对应</u>）；</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// Derive::fun() 调用派生类中的虚函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>基类的虚函数表如下</strong>：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB6.png" width="500px" /></div><p><strong>派生类的对象虚函数表如下</strong>：</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB7.png" width="700px" /></div><p>解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 <code>Derive::f()</code> 进行调用。</p><p>补充：</p><ol><li>如果使用虚函数，父类指针指向子类对象并调用对象方法时，使用的是子类的方法;</li><li>如果未使用虚函数，则是普通的重写，则父类指针指向子类对象时，使用的是父类的方法（与指针类型看齐）</li><li>父类指针能指向子类对象，但是子类指针不能指向父类对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_2语言对比</title>
    <link href="/2021/09/02/C++%E9%9D%A2%E8%AF%95_2%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/"/>
    <url>/2021/09/02/C++%E9%9D%A2%E8%AF%95_2%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>C++11, C 和 Python 以及 Java 的区别与联系。</p><span id="more"></span><h3 id="1-C-11-新特性-star-4"><a href="#1-C-11-新特性-star-4" class="headerlink" title="1 C++ 11 新特性 :star:4"></a>1 C++ 11 新特性 :star:4</h3><p>说明：C++11 的新特性有很多，从面试的角度来讲，如果面试官问到该问题，常以该问题作为引子，对面试者提到的知识点进行深入展开提问。面试者尽可能的列举常用的并且熟悉的特性，尽可能的掌握相关原理，下文只是对相关知识点进行了简单的阐述，有关细节还需要结合相关知识点的相关问题。</p><p>下面对常用的做一下总结：</p><ol><li><p><code>auto</code> 类型推导</p><p><code>auto</code> 关键字：自动类型推导，编译器会在 <strong>编译期间</strong> 通过初始值推导出变量的类型，通过 <code>auto</code> 定义的变量<strong>必须有初始值</strong>。</p><p><code>auto</code> 关键字基本的使用语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> var = val1 + val2; <span class="hljs-comment">// 根据 val1 和 val2 相加的结果推断出 var 的类型，</span><br></code></pre></div></td></tr></table></figure><p>注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p></li><li><p><code>decltype</code> 类型推导<br><code>decltype</code> 关键字：<code>decltype</code> 是“declare type”的缩写，译为“声明类型”。和 <code>auto</code> 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 <code>auto</code> 。<code>decltype</code> 作用是选择并返回操作数的数据类型。</p><p>区别：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> var = val1 + val2; <br><span class="hljs-keyword">decltype</span>(val1 + val2) var1 = <span class="hljs-number">0</span>; <br></code></pre></div></td></tr></table></figure><ul><li><code>auto</code> 根据 = 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；<code>decltype</code> 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</li><li><code>auto</code> 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 <code>decltype</code> 不要求，定义变量的时候可初始化也可以不初始化。</li></ul></li><li><p><code>lambda</code> 表达式</p><p><code>lambda</code> 表达式，又被称为 <code>lambda</code> 函数或者 <code>lambda</code> 匿名函数。</p><p><code>lambda</code>匿名函数的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[capture list] (parameter list) -&gt; <span class="hljs-keyword">return</span> type<br>&#123;<br>   function body;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">//对 a 数组中的元素进行升序排序</span><br>    <span class="hljs-built_in">sort</span>(arr, arr+<span class="hljs-number">4</span>, [=](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; <span class="hljs-keyword">bool</span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; );<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : arr)&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>范围 <code>for</code> 语句</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression)&#123;<br>    statement<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数的含义：</p><ul><li>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、<code>vector</code> ，<code>string</code> 等，这些类型的共同特点是拥有能返回迭代器的 <code>beign</code>、<code>end</code> 成员。</li><li>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 <code>auto</code> 类型说明符。</li></ul></li><li><p>右值引用</p><p>右值引用：绑定到右值的引用，用 <code>&amp;&amp;</code> 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">int</span> &amp;l_var = var;<br>    <span class="hljs-keyword">int</span> &amp;&amp;r_var = var; <span class="hljs-comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上</span><br><br>    <span class="hljs-keyword">int</span> &amp;&amp;r_var2 = var + <span class="hljs-number">40</span>; <span class="hljs-comment">// 正确：将 r_var2 绑定到求和结果上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>标准库 <code>move()</code> 函数</p><p><code>move()</code> 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。</p></li><li><p>智能指针</p></li><li><p><code>delete</code> 函数和 <code>default</code> 函数</p><ul><li><code>delete</code> 函数：<code>= delete</code> 表示该函数不能被调用。</li><li><code>default</code> 函数：<code>= default</code> 表示编译器生成默认的函数，例如：生成默认的构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 表示使用默认的构造函数</span><br>~<span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">// 表示使用默认的析构函数</span><br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 表示类的对象禁止拷贝构造</span><br>A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 表示类的对象禁止拷贝赋值</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A ex1;<br>A ex2 = ex1; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(const A&amp;)&#x27;</span><br>A ex3;<br>ex3 = ex1; <span class="hljs-comment">// error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="2-C-和-C-的区别-star-2"><a href="#2-C-和-C-的区别-star-2" class="headerlink" title="2 C 和 C++ 的区别 :star:2"></a>2 C 和 C++ 的区别 :star:2</h3><p><strong>面向对象和面向过程</strong>：</p><ul><li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li><li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li></ul><p><strong>区别和联系</strong>：</p><ul><li><p>语言自身：</p><p>C 语言是面向过程的编程，它最重要的特点是函数，通过 <code>main</code> 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。</p><p>C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 <code>main</code> 函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</p></li><li><p>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域。C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</p></li></ul><ul><li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 <code>const</code> 关键字，等等。</li></ul><ul><li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li></ul><h3 id="3-Java-和-C-的区别-star-3"><a href="#3-Java-和-C-的区别-star-3" class="headerlink" title="3 Java 和 C++ 的区别 :star:3"></a>3 Java 和 C++ 的区别 :star:3</h3><p><strong>语言特性上区别较大</strong>：</p><ul><li>指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li><li>多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li><li>数据类型和类：Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li></ul><p><strong>垃圾回收</strong>：</p><ul><li>Java 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。</li><li>Java 所有的对象都是用 <code>new</code> 操作符建立在内存堆栈上，类似于 C++ 中的 <code>new</code> 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 Java 中的内存回收是以<strong>线程</strong>的方式在<strong>后台运行</strong>的，利用空闲时间。</li></ul><p><strong>应用场景</strong>：</p><ul><li>Java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持。</li><li>C++ 可以直接编译成可执行文件，运行效率比 Java 高。</li><li>Java 主要用来开发 Web 应用。</li><li>C++ 主要用在嵌入式开发、网络、并发编程的方面。</li></ul><h3 id="4-Python-和-C-的区别-star-3"><a href="#4-Python-和-C-的区别-star-3" class="headerlink" title="4 Python 和 C++ 的区别 :star:3"></a>4 Python 和 C++ 的区别 :star:3</h3><p><strong>区别</strong>：</p><ul><li>语言自身：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li><li>运行效率：C++ 运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机 CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li><li>开发效率：Python 开发效率高。原因：Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li><li>书写格式和语法不同：Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试_1编译内存相关</title>
    <link href="/2021/09/01/C++%E9%9D%A2%E8%AF%95_1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/09/01/C++%E9%9D%A2%E8%AF%95_1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>:star: <strong>编译内存相关的主要内容</strong>：C++ 程序的编译过程、内存以及头文件的一些知识点，重点在内存方面进行展开，包括内存的分区、内存对齐、内存泄漏、内存泄漏的防止方法、现有的检测内存泄漏的工具等等。</p><span id="more"></span><h3 id="1-C-程序编译过程-star-4"><a href="#1-C-程序编译过程-star-4" class="headerlink" title="1 C++ 程序编译过程 :star:4"></a>1 C++ 程序编译过程 :star:4</h3><p>编译过程分为四步：编译（编译预处理、编译、优化），汇编，链接。</p><ul><li><strong>编译预处理</strong>：处理以 <code>#</code> 开头的指令；</li><li><strong>编译、优化</strong>：将源码 <code>.cpp</code> 文件翻译成 <code>.s</code> 汇编代码；</li><li><strong>汇编</strong>：将汇编代码 <code>.s</code> 翻译成机器指令 <code>.o</code> 文件；</li><li><strong>链接</strong>：汇编程序生成的目标文件，即 <code>.o</code> 文件不会立即执行。<u>因为可能会出现</u>：<code>.cpp</code> 文件中的函数引用了另一个 <code>.cpp</code> 文件中定义的符号或者调用了某个库文件中的函数。<strong>链接的目的是</strong>：将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 <code>.exe</code> 文件。</li></ul><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB1.png" width="550px" /></div><p>两种链接：</p><ol><li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ol><p>优缺点：</p><ol><li><strong>静态链接</strong>：<strong>优点</strong>：执行时的运行<u>速度快</u>。因为它会将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库（可执行程序具备了程序运行的所有内容）。<strong>缺点</strong>：<u>浪费空间</u>，链接的时候可能会对同一个目标文件进行多次链接（库或者目标代码）；而且如果目标文件进行了更新，则整个程序需要重新进行编译链接生成可执行程序（<u>更新困难</u>）；</li><li><strong>动态链接</strong>：<strong>优点</strong>：节省内存、更新方便。<strong>缺点</strong>：每次运行程序都需要执行链接，相比于静态链接有一定的性能损失。</li></ol><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB2.png" width="800px" /></div><h3 id="2-C-内存管理-star-5"><a href="#2-C-内存管理-star-5" class="headerlink" title="2 C++ 内存管理 :star:5"></a>2 C++ 内存管理 :star:5</h3><p><strong>C++ 内存分区</strong>：栈、堆、全局/静态存储区、常量存储区、代码区。</p><ul><li><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li><li><strong>堆</strong>：动态申请的内存空间，就是由 <code>malloc</code> 分配的内存块，由程序员控制它的分配和释放。如果程序执行结束还没有释放，操作系统会自动回收。</li><li><strong>全局区/静态存储区</strong>（<code>.bss</code> 段和 <code>.data</code> 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放。在 C 语言中，未初始化的放在 <code>.bss</code> 段中，初始化的放在 <code>.data</code> 段中，而 C++ 中不再区分。</li><li><strong>常量存储区</strong>（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</li><li><strong>代码区</strong>（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li></ul><p>说明：</p><ul><li>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 —&gt; .data 段 —&gt; .bss 段 —&gt; 堆 —&gt; unused —&gt; 栈 —&gt; env</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> g_var = <span class="hljs-number">0</span>; <span class="hljs-comment">// g_var 在全局区（.data 段）</span><br><span class="hljs-keyword">char</span> *gp_var;  <span class="hljs-comment">// gp_var 在全局区（.bss 段）</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var;                    <span class="hljs-comment">// var 在栈区</span><br>    <span class="hljs-keyword">char</span> *p_var;                <span class="hljs-comment">// p_var 在栈区</span><br>    <span class="hljs-keyword">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;         <span class="hljs-comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">char</span> *p_var1 = <span class="hljs-string">&quot;123456&quot;</span>;    <span class="hljs-comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var = <span class="hljs-number">0</span>;       <span class="hljs-comment">// s_var 为静态变量，存在静态存储区（.data 段）</span><br>    p_var = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配得来的 10 个字节的区域在堆区</span><br>    <span class="hljs-built_in">free</span>(p_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB3.png" width="550px" /></div><center>csapp,Linux虚拟内存系统地址空间分配</center><h3 id="3-栈和堆的区别-star-5"><a href="#3-栈和堆的区别-star-5" class="headerlink" title="3 栈和堆的区别 :star:5"></a>3 栈和堆的区别 :star:5</h3><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB4.png" width="750px" /></div><p>C++ 堆内存为什么不连续？</p><ol><li>堆的内存是分配是我们 malloc 空间时，申请的空间大小不一样造成了碎片。使用 malloc 的时候系统内部有一个空闲内存映射表，系统会自动查找空闲内存中第一个合适大小的空间分配；</li></ol><h3 id="4-变量的区别-star-3"><a href="#4-变量的区别-star-3" class="headerlink" title="4 变量的区别 :star:3"></a>4 变量的区别 :star:3</h3><p><strong>全局变量、局部变量、静态全局变量、静态局部变量的区别？</strong></p><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p><p><u>从作用域看：</u></p><ul><li><strong>全局变量</strong>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</li><li><strong>静态全局变量</strong>：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li><li><strong>局部变量</strong>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li><li><strong>静态局部变量</strong>：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li></ul><p><u>从分配内存空间看：</u></p><ul><li>静态存储区：全局变量，静态局部变量，静态全局变量。</li><li>栈：局部变量。</li></ul><p>说明：</p><ul><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li><li>静态变量和全局变量的区别：静态变量用 <code>static</code> 告知编译器，自己仅仅在变量的作用范围内可见。</li></ul><h3 id="5-全局变量定义在头文件中有什么问题？-star-1"><a href="#5-全局变量定义在头文件中有什么问题？-star-1" class="headerlink" title="5 全局变量定义在头文件中有什么问题？:star:1"></a>5 全局变量定义在头文件中有什么问题？:star:1</h3><p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p><blockquote><p>参考<a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">详细介绍</a></p></blockquote><h3 id="6-对象创建限制在堆或栈-star-3"><a href="#6-对象创建限制在堆或栈-star-3" class="headerlink" title="6 对象创建限制在堆或栈 :star:3"></a>6 对象创建限制在堆或栈 :star:3</h3><p><strong>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</strong></p><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p><ul><li><strong>静态建立</strong>：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：<code>A a</code>;</li><li><strong>动态建立</strong>：使用 <code>new</code> 关键字在堆空间上创建对象，底层首先调用 <code>operator new()</code> 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li></ul><p><u>限制对象只能建立在堆上：</u></p><ul><li>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 <code>new</code> 来建立对象。但是由于 <code>new</code> 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 <code>new</code> 创建对象了。因此，这种方法不可行。</li></ul><ul><li><p>解决方法 1：</p><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>() &#123; &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>该方法存在的问题：</p><ul><li>用 <code>new</code> 创建的对象，通常会使用 <code>delete</code> 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 <code>destory()</code> 函数，用来释放 new 创建的对象。</li><li>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 <code>virtual</code>，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</li></ul></li><li><p>解决方法2：</p><p>构造函数设置为 <code>protected</code>，并提供一个 <code>public</code> 的静态函数来完成构造，而不是在类的外部使用 <code>new</code> 构造；将析构函数设置为 <code>protected</code>。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 <code>create()</code> 函数在堆上创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A *<span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><p><u>限制对象只能建立在栈上：</u></p><ul><li><p>解决方法：将 <code>operator new()</code> 设置为私有。原因：当对象建立在堆上时，是采用 <code>new</code> 的方式进行建立，其底层会调用 <code>operator new()</code> 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="7-内存对齐-star-2"><a href="#7-内存对齐-star-2" class="headerlink" title="7 内存对齐 :star:2"></a>7 内存对齐 :star:2</h3><p><strong>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</strong></p><p><strong>内存对齐</strong>：编译器将程序中的每个“数据单元” 安排在字的整数倍的地址指向的内存之中</p><p><strong>内存对齐的原则</strong>：</p><ol><li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的，对齐基数默认是 8</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">short</span> var; <span class="hljs-comment">// 2 字节</span><br>    <span class="hljs-keyword">int</span> var1;  <span class="hljs-comment">// 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8</span><br>    <span class="hljs-keyword">long</span> var2; <span class="hljs-comment">// 12 字节 8 + 4 (long) = 12</span><br>    <span class="hljs-keyword">char</span> var3; <span class="hljs-comment">// 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16</span><br>    string s;  <span class="hljs-comment">// 48 字节 16 + 32 (string) = 48</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">short</span> var;<br>    <span class="hljs-keyword">int</span> var1;<br>    <span class="hljs-keyword">long</span> var2;<br>    <span class="hljs-keyword">char</span> var3;<br>    string s;<br>    A ex1;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var) &lt;&lt; endl;  <span class="hljs-comment">// 2 short</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var1) &lt;&lt; endl; <span class="hljs-comment">// 4 int</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var2) &lt;&lt; endl; <span class="hljs-comment">// 4 long</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var3) &lt;&lt; endl; <span class="hljs-comment">// 1 char</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s) &lt;&lt; endl;    <span class="hljs-comment">// 32 string</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl;  <span class="hljs-comment">// 48 struct</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>进行内存对齐的原因</strong>：（主要是硬件设备方面的问题）</p><ol><li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p><strong>内存对齐的优点</strong>：</p><ol><li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><h3 id="8-类的大小-star-2"><a href="#8-类的大小-star-2" class="headerlink" title="8 类的大小 :star:2"></a>8 类的大小 :star:2</h3><p><strong>类大小的计算</strong></p><p>说明：类的大小是指类的实例化对象的大小，用 <code>sizeof</code> 对类型名操作时，结果是该类型的对象的大小。</p><p><strong>计算原则</strong>：</p><ul><li>遵循结构体的对齐原则。</li><li>与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li>虚函数对类的大小有影响，是因为虚函数表指针的影响。</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响。</li><li>空类的大小是一个特殊情况，空类的大小为 1，当用 <code>new</code> 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li></ul><p><strong>实例1</strong>：简单情况和空类情况</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                    <span class="hljs-comment">// 不影响类的大小</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    B ex2;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 12 字节</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex2) &lt;&lt; endl; <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>实例：</strong>带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                      <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::f&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::g&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::h&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    A *p;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl;   <span class="hljs-comment">// 8 字节 注意：指针所占的空间和指针指向的数据类型无关</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 24 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-什么是内存泄露-star-4"><a href="#9-什么是内存泄露-star-4" class="headerlink" title="9 什么是内存泄露 :star:4"></a>9 什么是内存泄露 :star:4</h3><p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p><p>进一步解释：</p><ul><li><p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p></li><li><p>常指<u>堆内存泄漏</u>，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p></li><li><p>使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>new</code>  等分配内存时，使用完后要调用相应的 <code>free</code> 或 <code>delete</code> 释放内存，否则这块内存就会造成内存泄漏。</p></li><li><p>指针重新赋值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">char</span> *p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>p = np;<br></code></pre></div></td></tr></table></figure><p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p></li></ul><p>大概分为这么3类内存泄漏：</p><ul><li>堆内存泄漏：new/mallc分配内存，未使用对应的delete/free回收；</li><li>系统资源泄漏， Bitmap, handle, socket 等资源未释放；</li><li>没有将基类析构函数定义称为虚函数，（使用基类指针或者引用指向派生类对象时）派生类对象释放时将不能正确释放派生对象部分。</li></ul><h3 id="10-怎么防止内存泄漏？内存泄漏检测工具的原理？-star-3"><a href="#10-怎么防止内存泄漏？内存泄漏检测工具的原理？-star-3" class="headerlink" title="10 怎么防止内存泄漏？内存泄漏检测工具的原理？:star:3"></a>10 怎么防止内存泄漏？内存泄漏检测工具的原理？:star:3</h3><p><strong>防止内存泄漏的方法：</strong></p><ol><li><p><strong>内部封装</strong>：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造函数中分配内存空间</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>    &#125;;<br>    ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 析构函数中释放内存空间</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>            p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况，请看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = ex; <br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单解释：对于 <code>fun1</code> 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间，但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过<strong>增加计数机制</strong>来避免这种情况，看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br>    <span class="hljs-keyword">int</span> *p_count; <span class="hljs-comment">// 计数变量</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 在构造函数中申请内存</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>        p_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>        *p_count = <span class="hljs-number">1</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;temp)<br>    &#123;<br>        p = temp.p;<br>        p_size = temp.p_size;<br>        p_count = temp.p_count;<br>        (*p_count)++; <span class="hljs-comment">// 复制时，计数变量 +1</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        (*p_count)--; <span class="hljs-comment">// 析构时，计数变量 -1</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl; <br><br>        <span class="hljs-keyword">if</span> (*p_count == <span class="hljs-number">0</span>) <span class="hljs-comment">// 只有当计数变量为 0 的时候才会释放该块内存空间</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;buf is deleted&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <br>            &#123;<br>                <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>                p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>                <span class="hljs-keyword">if</span> (p_count != <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    <span class="hljs-keyword">delete</span> p_count;<br>                    p_count = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br><br>    A ex1 = ex; <span class="hljs-comment">// 此时计数变量会 +1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;ex1.p = &quot;</span> &lt;&lt; ex1.<span class="hljs-built_in">GetPointer</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出结果：<br><span class="hljs-comment">// count is : 1</span><br><span class="hljs-comment">// Test</span><br><span class="hljs-comment">// count is : 2</span><br><span class="hljs-comment">// ex1.p = Test</span><br><span class="hljs-comment">// count is : 1</span><br><span class="hljs-comment">// count is : 0</span><br><span class="hljs-comment">// buf is deleted</span><br></code></pre></div></td></tr></table></figure><p>解释下：程序运行结果的倒数 2、3 行是调用两次析构函数时进行的操作，在第二次调用析构函数时，进行内存空间的释放，从而会有倒数第 1 行的输出结果。</p></li><li><p><strong>智能指针</strong><br>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</p></li></ol><p><strong>内存泄漏检测工具的实现原理：</strong></p><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p><div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/C%2B%2B%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB5.png" width="700px" /></div><p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li><p>Massif：检查程序中堆栈使用中出现的问题。</p></li><li><p>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</p></li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li></ul><p>检测原理：</p><ul><li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li><li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li></ul><h3 id="11-智能指针有哪几种？智能指针的实现原理？-star-5"><a href="#11-智能指针有哪几种？智能指针的实现原理？-star-5" class="headerlink" title="11 智能指针有哪几种？智能指针的实现原理？ :star:5"></a>11 智能指针有哪几种？智能指针的实现原理？ :star:5</h3><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p><p>C++11 中智能指针包括以下三种：</p><ul><li>共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li><li>独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</li><li>弱指针（weak_ptr）：指向 <code>share_ptr</code> 指向的对象，能够解决由 <code>shared_ptr</code> 带来的循环引用问题。</li></ul><p><strong>智能指针的实现原理</strong>： 计数原理。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 代码有问题</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br><span class="hljs-keyword">private</span> : <br>T *_ptr;<br><span class="hljs-keyword">size_t</span> *_count;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) : _ptr(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (_ptr)<br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">SmartPtr</span>()<br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">SmartPtr</span>(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 拷贝构造：计数 +1</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>&#125;<br>&#125;<br><br>SmartPtr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 赋值运算符重载 </span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) <span class="hljs-comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span><br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++; <span class="hljs-comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>T &amp;<span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>&#125;<br><br>T *<span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;count;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="12-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？-star-2"><a href="#12-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？-star-2" class="headerlink" title="12 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？:star:2"></a>12 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？:star:2</h3><p>借助 <code>std::move()</code> 可以实现将一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，其目的是实现所有权的转移。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// A 作为一个类 </span><br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::unique_ptr&lt;A&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br></code></pre></div></td></tr></table></figure><p>可以看成ptr1变成了一个野指针。unique_ptr采用的是所有权的概念，一个指针对象赋值给另一个后，原来的智能指针不再指向之前它指向的内存。不过由于原指针会变成野指针，所以一般直接用一个智能指针对象赋值给另一个是不被允许的，编译阶段就会报错。不过由于使用了move，所以对编译器作出了不再使用ptr1的值的承诺，可以避免解引用野指针带来的错误，因此可以通过编译。</p><h3 id="13-使用智能指针会出现什么问题？怎么解决？-star-5"><a href="#13-使用智能指针会出现什么问题？怎么解决？-star-5" class="headerlink" title="13 使用智能指针会出现什么问题？怎么解决？:star:5"></a>13 使用智能指针会出现什么问题？怎么解决？:star:5</h3><p><strong>智能指针可能出现的问题</strong>：循环引用</p><p>在如下例子中定义了两个类 <code>Parent</code>、<code>Child</code>，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>循环引用的解决方法</strong>： <code>weak_ptr</code></p><p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p><ul><li><code>weak_ptr</code> 对被 <code>shared_ptr</code> 管理的对象存在 <strong>非拥有性（弱）引用</strong>，在访问所引用的对象前必须先转化为 <code>shared_ptr</code>；</li><li><code>weak_ptr</code>用来打断 <code>shared_ptr</code> 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），<code>shared_ptr</code> 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li><li><code>weak_ptr</code> 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 <code>weak_ptr</code> 跟踪该对象；需要获得所有权时将其转化为 <code>shared_ptr</code>，此时如果原来的 <code>shared_ptr</code> 被销毁，则该对象的生命期被延长至这个临时的 <code>shared_ptr</code> 同样被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//shared_ptr&lt;Child&gt; ChildPtr;</span><br>    weak_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//new shared_ptr</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">lock</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>weak_ptr</code> 的实现：</p><ol><li>说的高大上就是 <code>weak_ptr</code> 只能拥有 <code>shared_ptr</code> 的观测权，没有使用权，想要使用的时候，就将 <code>weak_ptr</code> 转为 <code>shared_ptr</code> ，这个时候新产生的 <code>shared_ptr</code> 对象是不会引起循环引用的问题，因为它在它的作用域结束后肯定要释放的，和 <code>weak_ptr</code> 所在的类对象没有任何关系了。</li><li>有这样的想法也很正常，既然都使用 <code>shared_ptr</code> 会出现循环引用的问题，所以只要将其中某一条引用链断了就可以了，自然而然可以想到使用一个中间产品（<code>weak_ptr</code>），并且提供 <code>weak_ptr</code> 像 <code>shared_ptr</code> 转换的方法即可。</li><li>查看MSVC的memory文件，可以看到 <code>shared_ptr</code> 和 <code>weak_ptr</code> 都是继承于 <code>ptr_base</code> 的，在 <code>ptr_base</code> 中存放了资源指针 <code>_Ptr</code> 以及引用计数指针 <code>_Rep</code>，而 <code>shared_ptr</code> 类中定义了一些对资源 <code>_Ptr</code> 操作的方法，但是在 <code>weak_ptr</code> 中，只有“资源观测权”的方法：</li></ol><p><strong>expired（查看资源是否还存在）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD <span class="hljs-keyword">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return true if resource no longer exists</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">use_count</span>() == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>lock(将weak_ptr构造为shared_ptr)：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// convert to shared_ptr</span><br>        shared_ptr&lt;_Ty&gt; _Ret;<br>        (<span class="hljs-keyword">void</span>) _Ret._Construct_from_weak(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> (_Ret);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
