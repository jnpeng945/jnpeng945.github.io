

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browserIcon.png">
  <link rel="icon" href="/img/browserIcon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Zrosor">
  <meta name="keywords" content="">
  <meta name="description" content="本文简要介绍算法复杂度分析，并给出《剑指 Offer 第 2 版》 系列题目的解题思路以及参考答案。 算法复杂度算法复杂度旨在计算在输入数据量 $N$ 的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 $N$ 」而增大的速度。 有关算法时间复杂度的详细叙述可见知乎高赞答案[1]。 根据从小到大排列，常见的算法时间复杂度主要有：  O(1)">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer题解">
<meta property="og:url" content="https://jnpeng945.github.io/2021/10/01/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/">
<meta property="og:site_name" content="JN&#39;s blog">
<meta property="og:description" content="本文简要介绍算法复杂度分析，并给出《剑指 Offer 第 2 版》 系列题目的解题思路以及参考答案。 算法复杂度算法复杂度旨在计算在输入数据量 $N$ 的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 $N$ 」而增大的速度。 有关算法时间复杂度的详细叙述可见知乎高赞答案[1]。 根据从小到大排列，常见的算法时间复杂度主要有：  O(1)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201155933.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160148.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160148.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160908.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161047.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161148.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211115173654.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211116191037.png">
<meta property="og:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161340.png">
<meta property="article:published_time" content="2021-10-01T07:35:46.000Z">
<meta property="article:modified_time" content="2021-12-01T09:44:40.451Z">
<meta property="article:author" content="Zrosor">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201155933.png">
  
  <title>剑指Offer题解 - JN&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"jnpeng945.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>It&#39;s worth.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                文档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/jnpeng945/JianZhi-Offer">
                    
                    剑指Offer
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/docs/">
                    
                    Fluid手册
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.4)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="剑指Offer题解">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Zrosor
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-01 15:35" pubdate>
        2021年10月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      176 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">剑指Offer题解</h1>
            
            <div class="markdown-body">
              <p>本文简要介绍算法复杂度分析，并给出《剑指 Offer 第 2 版》 系列题目的解题思路以及参考答案。</p>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>算法复杂度旨在计算在输入数据量 $N$ 的情况下，算法的「时间使用」和「空间使用」情况；体现算法运行使用的时间和空间随「数据大小 $N$ 」而增大的速度。</p>
<p>有关算法时间复杂度的详细叙述可见知乎高赞答案<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="如何理解算法时间复杂度的表示法(http://www.zhihu.com/question/21387264)
">[1]</span></a></sup>。</p>
<p>根据从小到大排列，常见的算法时间复杂度主要有：</p>
<script type="math/tex; mode=display">
O(1)<O(\log N)<O(N)<O(N \log N)<O\left(N^{2}\right)<O\left(2^{N}\right)<O(N !)</script><p>本部分复杂度分析详细可见<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="图解算法与数据结构(https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/)
">[2]</span></a></sup>。</p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">9. 用两个栈实现队列</a></h3><p><strong>题目描述</strong>：用两个栈实现一个队列。完成两个操作：</p>
<ul>
<li>队列尾部插入整数；</li>
<li>队列头部删除整数，队列为空则返回 -1。</li>
</ul>
<p><strong>解题思路</strong>：本题只需理清从队列头部删除整数的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stk1, stk2;<br>    <span class="hljs-built_in">CQueue</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        stk1.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(!stk1.<span class="hljs-built_in">empty</span>()) &#123;<br>                stk2.<span class="hljs-built_in">push</span>(stk1.<span class="hljs-built_in">top</span>());<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>            res = stk2.<span class="hljs-built_in">top</span>();<br>            stk2.<span class="hljs-built_in">pop</span>(); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">30. 包含min函数的栈</a></h3><p><strong>题目描述</strong>：定义栈的数据结构，实现四个操作：</p>
<ul>
<li><code>void push(int x)</code>，元素入栈；</li>
<li><code>void pop()</code>，元素出栈；</li>
<li><code>int top()</code>，返回栈顶元素；</li>
<li><code>int min()</code>，返回栈中最小的元素；</li>
</ul>
<p>调用 <code>min</code>、<code>push</code> 及 <code>pop</code> 的时间复杂度都是 O(1)。</p>
<p><strong>解题思路</strong>：维护 <code>stk2</code> 为单调递减的单调栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stk1, stk2;<br>    <span class="hljs-built_in">MinStack</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">empty</span>() || stk2.<span class="hljs-built_in">top</span>() &gt;= x) &#123;<br>            stk2.<span class="hljs-built_in">push</span>(x);<br>        &#125; <br>        stk1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">top</span>() == stk2.<span class="hljs-built_in">top</span>()) stk2.<span class="hljs-built_in">pop</span>();<br>        stk1.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk1.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 - I. 滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">59 - I. 滑动窗口的最大值</a></h3><p><strong>题意描述</strong>：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br></code></pre></div></td></tr></table></figure>
<p>注意：<em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p><strong>解题思路</strong>：单调队列，滑动窗口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (deq.<span class="hljs-built_in">size</span>() &amp;&amp; deq.<span class="hljs-built_in">front</span>() &lt;= i - k) deq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(deq.<span class="hljs-built_in">size</span>() &amp;&amp; nums[deq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) deq.<span class="hljs-built_in">pop_back</span>();<br>        deq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) res.<span class="hljs-built_in">push_back</span>(nums[deq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59 - II. 队列的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">59 - II. 队列的最大值</a></h3><p><strong>题意描述</strong>：请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数 <code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的均摊时间复杂度都是 $O(1)$ 。若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 $-1$。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: <br>[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双端队列 + 队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : deq.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span>(deq.<span class="hljs-built_in">size</span>() &amp;&amp; deq.<span class="hljs-built_in">back</span>() &lt; value) deq.<span class="hljs-built_in">pop_back</span>();<br>        deq.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (que.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> res = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (deq.<span class="hljs-built_in">front</span>() == res) deq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">6. 从尾到头打印链表</a></h3><p><strong>题意描述</strong>：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [1,3,2]<br>输出：[2,3,1]<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span>(head) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(res.<span class="hljs-built_in">rbegin</span>(), res.<span class="hljs-built_in">rend</span>());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">24. 反转链表</a></h3><p><strong>题意描述</strong>：输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br></code></pre></div></td></tr></table></figure>
<p>递归法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;<br>    ListNode* pre = <span class="hljs-literal">nullptr</span>, *cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        ListNode* p = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35. 复杂链表的复制</a></h3><p><strong>题意描述</strong>：实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p>示例 1：</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201155933.png" srcset="/img/loading.gif" lazyload width = "600px" /></div>

<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br></code></pre></div></td></tr></table></figure>
<p>示例 2：</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160148.png" srcset="/img/loading.gif" lazyload width = "600px" /></div>

<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：假设原始链表为下图所示。</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160148.png" srcset="/img/loading.gif" lazyload width = "600px" /></div>

<p>第一步：在每个节点的后面加上它的复制，将原链表和复制链表连在一起。</p>
<div align=center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201160908.png" srcset="/img/loading.gif" lazyload width = "500px" /></div>


<p>第二步：复制 <code>random</code> 指针，遍历链表，对于非空的 <code>cur-&gt;random</code> ，让 <code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</code>。</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161047.png" srcset="/img/loading.gif" lazyload width = "500px" /></div>

<p>第三步：分离两个链表。</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161148.png" srcset="/img/loading.gif" lazyload width = "500px" /></div>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>    Node* cur = head;<br>    <span class="hljs-comment">// 链表复制</span><br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        Node* tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>        tmp-&gt;next = cur-&gt;next;<br>        cur-&gt;next = tmp;<br>        cur = tmp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// random 指针复制</span><br>    cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;random) &#123;<br>            cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 链表分割</span><br>    Node* pre = head;<br>    cur = head-&gt;next;<br>    Node* newHead = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next) &#123;<br>        pre-&gt;next = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        pre = pre-&gt;next;<br>        cur = cur-&gt;next;<br>    &#125;<br>    pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>vector</code> 数组实现：</p>
<ul>
<li>初始：空数组，分配常数空间；</li>
<li><code>push_back()</code> ：若空间不够，重新申请 $2$ 倍大小的连续空间，拷贝到新空间，释放旧空间；</li>
<li><code>pop_back()</code> ：若空间利用率不到 $25\%$ ，释放一半的空间；</li>
</ul>
<p>均摊 $O(1)$ </p>
<p>在空数组中连续插入 $n$ 个元素，总插入 / 拷贝次数为 $n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}… &lt; 2n$ </p>
<p>一次扩容到下次释放，至少需要再删除 $(1-2\times0.25)*n=0.5n$ 次</p>
<h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h3><p><strong>题意描述</strong>：把字符串 <code>s</code> 中的每个空格替换成 <code>&quot;%20&quot;</code>。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;We are happy.&quot;<br>输出：&quot;We%20are%20happy.&quot;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：假设初始字符串 <code>s</code> 的长度为 $n$。 </p>
<ul>
<li>统计字符串 <code>s</code> 中的空格个数 $cnt$，将字符串长度调整为 $n + 2 \times cnt$；</li>
<li>从后往前遍历字符串，遇到空格就替换为字符串 <code>&quot;%20&quot;</code>。</li>
</ul>
<p>在本题中我们用两个指针 <code>i</code> 和 <code>j</code> 分别指向 <code>n - 1</code> 和  <code>n + 2 * cnt - 1</code> 的位置，直到 <code>i == j</code> 时我们结束循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * cnt);<br>    <span class="hljs-keyword">int</span> j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) s[j--] = s[i--];<br>        <span class="hljs-keyword">else</span> &#123;<br>            i--;<br>            s[j--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            s[j--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            s[j--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58 - II. 左旋转字符串</a></h3><p><strong>题意描述</strong>：实现字符串的左旋操作，也就是把字符串前面的若干个字符转移到字符串的尾部。</p>
<p><strong>解题思路</strong>：字符串三次翻转。———-&gt;—-&gt;，&lt;—-&lt;———-，—-&gt;&lt;———-，—-&gt;———-&gt;</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: s = &quot;abcdefg&quot;, k = 2<br>输出: &quot;cdefgab&quot;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n - k);<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n - k, s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">20. 表示数值的字符串</a></h3><p><strong>题意描述</strong>：实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">数值：[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]<br>非数值：[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]<br></code></pre></div></td></tr></table></figure>
<ul>
<li>小数可以没有整数部分，例如 <code>.123</code> 等于 <code>0.123</code>；</li>
<li><p>小数点后面可以没有数字，例如 <code>233.</code> 等于 <code>233.0</code>；</p>
</li>
<li><p>小数点前面和后面可以有数字，例如 <code>233.666</code>；</p>
</li>
<li>当 <code>e</code> 或 <code>E</code> 前面没有数字时，整个字符串不能表示数字，例如 <code>.e1</code>、<code>e1</code>；</li>
<li>当 <code>e</code> 或 <code>E</code> 后面没有整数时，整个字符串不能表示数字，例如 <code>12e</code>、<code>12e+5.4</code>;</li>
</ul>
<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li>
</ul>
<p><strong>解题思路1</strong>：模拟字符串处理，整个字符串遍历一次，时间复杂度为 $O(N)$。</p>
<ol>
<li>先去除行首和行尾空格；</li>
<li>行首如果有一个正负号，直接忽略；</li>
<li>如果字符串为空或只有一个 <code>&#39;.&#39;</code> ，则不是一个合法数；</li>
<li>循环整个字符串，去掉以下几种情况：<ol>
<li><code>&#39;.&#39;</code> 或 <code>&#39;e&#39;</code> 多于 1 个；</li>
<li><code>&#39;.&#39;</code> 在 <code>&#39;e&#39;</code> 后面出现；</li>
<li><code>&#39;e&#39;</code> 后面或前面为空，或者 <code>&#39;e&#39;</code> 前面紧跟着 <code>&#39;.&#39;</code>；</li>
<li><code>&#39;e&#39;</code> 后面紧跟着正负号，但正负号后面为空；</li>
</ol>
</li>
<li>剩下的都是合法情况；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-comment">// 去除行首行尾空格</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; s[j] == <span class="hljs-string">&#x27; &#x27;</span>) j--;<br>    <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 行首如果只有一个正负号，直接忽略</span><br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>() || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">int</span> dot = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>        &#123;<br>            dot++;<br>            <span class="hljs-keyword">if</span> (e || dot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <span class="hljs-comment">// . 多余一个，. 在 e 后面出现</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;e&#x27;</span> || s[i] == <span class="hljs-string">&#x27;E&#x27;</span>) <br>        &#123;<br>            e++;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == s.<span class="hljs-built_in">size</span>() || !i || e &gt; <span class="hljs-number">1</span> || i == <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// . 后面紧跟正负号，但是正负号后面为空</span><br>            <span class="hljs-keyword">if</span> (s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">67. 把字符串转换成整数</a></h3><p><strong>题意描述</strong>：写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 <code>atoi</code> 或者其他类似的库函数。</p>
<ul>
<li>函数需要移除开头空格字符，从第一个非空格的字符开始；</li>
<li>当第一个非空字符为 <code>+</code> 或者 <code>-</code> 时，需要将该符号和后面尽可能多的连续数字组合起来，作为该整数的正负号；</li>
<li>若第一个非空字符是数字，则直接将其余之后连续的数字字符组合起来，形成整数；</li>
<li>有效的整数部分之后多余的字符应当忽略；</li>
<li>假设该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</li>
</ul>
<p>在任何情况下，若函数不能进行有效的转换，返回 0；</p>
<p><strong>解题思路</strong>：根据题意需要考虑以下四种情况：</p>
<ol>
<li>首部空格：删除即可；</li>
<li>符号位：<code>+</code>, <code>-</code>, <code>无符号位</code>；新建一个变量保存符号位，返回前判断正负号；</li>
<li>非数字字符：遇到首个非数字的字符，立即返回；</li>
<li>数字字符：<ul>
<li>字符转数字：ASCII 码直接相减即可；</li>
<li>数字拼接：从左向右遍历数字，设当前位字符为 <code>c</code>，数字结果为 <code>res</code>：<code>res = 10*res+c-&#39;0&#39;</code></li>
</ul>
</li>
</ol>
<p><strong>数字越界处理：</strong></p>
<p>题目要求返回的数值范围在 $[-2^{31}, 2^{31} - 1]$ ，因此需要考虑数字越界问题。而题目指出环境只能存储 <code>32</code> 位大小的有符号整数，因此判断数字越界时，要保持 <code>res</code> 在 <code>int</code> 类型的取值范围内。</p>
<p>在每轮数字拼接前，判断 <code>res</code> 在此轮拼接之后是否超过 $2147483647$ ，若超过则加上符号位直接返回。设数字拼接边界为 $214748364$，则以下两种情况越界：</p>
<script type="math/tex; mode=display">
\left \{ 
\begin{align}{}
& res>214748364 \qquad \qquad \text{情况1:执行拼接} 10\times res \geq 2147483650 \text{越界} \\ 
& res = 214748364,x>7 \quad \text{情况2:拼接后是}2147483648\text{或者}2147483649越界\\ 
\end{align}
\right.</script><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">// 全是空格</span><br><br>    <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;              <span class="hljs-comment">// 记录正负</span><br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) is_minus = <span class="hljs-literal">true</span>, i++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;+&#x27;</span>) i++;<br><br>    <span class="hljs-keyword">if</span> (str[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || str[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 首个非空字符为非数字字符</span><br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, boundry = INT_MAX / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; str.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (str[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || str[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 非法字符停止遍历</span><br>        <span class="hljs-keyword">if</span> (res &gt; boundry || res == boundry &amp;&amp; str[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> is_minus ? INT_MIN : INT_MAX;<br>        &#125;<br>        res = res * <span class="hljs-number">10</span> + (str[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> is_minus ? -res : res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">03. 数组中重复的数字</a></h3><p><strong>题意描述</strong>：在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0～n-1$ 的范围内。找出数组中任意一个重复的数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 <br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：</p>
<ul>
<li>方法1：哈希表统计，一次遍历数组中的元素，当遍历到重复数字时 <code>break</code>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>  x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (hash[x] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x;<br>        hash[x]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>方法2：原地交换。</li>
</ul>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211115173654.png" srcset="/img/loading.gif" lazyload width =" 600px" /></div>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(i != nums[i] &amp;&amp; nums[i] != nums[nums[i]]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="53-I-在排序数组中查找数字-I"><a href="#53-I-在排序数组中查找数字-I" class="headerlink" title="53 - I. 在排序数组中查找数字 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">53 - I. 在排序数组中查找数字 I</a></h3><p><strong>题意描述</strong>：统计一个数字在排序数组中出现的次数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br><br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：两次二分查找，在数组中找出这个数字的左边界和右边界。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[r] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = r;<br>        l = left, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53 - II. 0～n-1中缺失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">53 - II. 0～n-1中缺失的数字</a></h3><p><strong>题意描述</strong>：一个长度为 $n-1$ 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 $0 \sim n-1$ 之内。在范围 $0 \sim n-1$ 内的 $n$ 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [0,1,3]<br>输出: 2<br><br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：二分查找。查找满足性质 <code>mid != nums[mid]</code> 的区段的左边界。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mid != nums[mid]) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04. 二维数组中的查找</a></h3><p><strong>题意描述</strong>：在一个 $n \times m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">matrix = [<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><br>target = 5, return true;<br>target = 20, return false;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：从数组右上角开始遍历，当该元素大于 <code>target</code> 时，到下一列的位置开始遍历，否则到下一行的位置开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11. 旋转数组的最小数字</a></h3><p><strong>题意描述</strong>：数组的旋转是指把数组最开始的若干个元素搬到数组的末尾。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：[3,4,5,1,2]<br>输出：1<br></code></pre></div></td></tr></table></figure>
<p>解题思路：题中数组满足部分有序，可尝试使用二分查找解法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) r = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == nums[r]) r--;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[r];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50. 第一个只出现一次的字符</a></h3><p><strong>题意描述</strong>：在字符串 $s$ 中找出第一个只出现一次的字符。如果没有，返回一个单空格。$s $ 只包含小写字母。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;abaccdeff&quot;<br>输出：&#x27;b&#x27;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：两次遍历，第一次用哈希表统计字符串中每个字母出现的次数，第二次遍历查看出现一次的字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>        hash[x]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>        <span class="hljs-keyword">if</span> (hash[x] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h3 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">07. 重建二叉树</a></h3><p><strong>题意描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]<br></code></pre></div></td></tr></table></figure>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
<p><strong>解题思路</strong>：分治思想。前序遍历的首元素是根节点 <code>root</code> 的值。利用哈希表 <code>hash</code> 存储中序遍历中值与索引的映射，提高查询效率。<code>preL &gt; preR</code> 表示已经越过了叶节点，函数返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hash[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preL &gt; preR || inL &gt; inR) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preL]);<br>        <span class="hljs-keyword">int</span> index = hash[preorder[preL]];<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, preL + <span class="hljs-number">1</span>, index - inL + preL, inorder, inL, index - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, index - inL + preL + <span class="hljs-number">1</span>, preR, inorder, index + <span class="hljs-number">1</span>, inR);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">16. 数值的整数次方</a></h3><p><strong>题意描述</strong>：实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：x = 2.00000, n = 10<br>输出：1024.00000<br><br>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25<br></code></pre></div></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>$-100.0 &lt; x &lt; 100.0$</li>
<li>$-2^{31} &lt;= n &lt;= 2^{31}-1$</li>
<li>$-10^4 &lt;= x^n &lt;= 10^4$</li>
</ul>
<p><strong>解题思路</strong>：分治思想，快速幂模板题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k = n;<br>    <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>        is_minus = <span class="hljs-literal">true</span>;<br>        k = -k;<br>    &#125;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res *= x;<br>        x *= x;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> is_minus ? <span class="hljs-number">1</span> / res : res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">33. 二叉搜索树的后序遍历序列</a></h3><p><strong>题意描述</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,3,2,6,5]<br>输出: true<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：基于分治的思想，递归实现。</p>
<ul>
<li><code>l &gt;= r</code> 表示到达叶子节点，返回 <code>true</code>；</li>
<li>左子树节点值应当小于根节点的值 <code>rootVal</code>，且右子树节点值应当大于根节点的值 <code>rootVal</code>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> rootVal = postorder[r];<br>        <span class="hljs-keyword">int</span> k = l;<br>        <span class="hljs-keyword">while</span>(k &lt; r &amp;&amp; postorder[k] &lt; rootVal) k++;     <span class="hljs-comment">// k 应指向右子树首个节点的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; r; i++) &#123;<br>            <span class="hljs-keyword">if</span> (postorder[i] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, l, k - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">dfs</span>(postorder, k, r - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">17. 打印从1到最大的n位数</a></h3><p><strong>题意描述</strong>：输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]<br></code></pre></div></td></tr></table></figure>
<p>说明：用返回一个整数列表来代替打印；n 为正整数</p>
<p><strong>解题思路</strong>：打印数范围 $[1,10^n-1]$</p>
<div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161254.png" width = "500px" /></div>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    string s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        s.<span class="hljs-built_in">resize</span>(n, <span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            <span class="hljs-built_in">save</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            s[u] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(n, u + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 除去首部的 0</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(ptr &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[ptr] == <span class="hljs-string">&#x27;0&#x27;</span>) ptr++;<br>        <span class="hljs-keyword">if</span> (ptr != s.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(ptr)));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">51. 数组中的逆序对</a></h3><p><strong>题意描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [7,5,6,4]<br>输出: 5<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>0 &lt;= 数组长度 &lt;= 50000</code></p>
<p><strong>解题思路</strong>：归并排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        tmp.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        res += <span class="hljs-built_in">merge_sort</span>(nums, l, mid);<br>        res += <span class="hljs-built_in">merge_sort</span>(nums, mid + <span class="hljs-number">1</span>, r);<br><br>        <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) tmp[k++] = nums[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                tmp[k++] = nums[j++];<br>                res += mid - i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) nums[i] = tmp[j];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="搜索与回溯算法"><a href="#搜索与回溯算法" class="headerlink" title="搜索与回溯算法"></a>搜索与回溯算法</h2><h3 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32 - I. 从上到下打印二叉树</a></h3><p><strong>题意描述</strong>：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7]<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>   <br>输出：[3,9,20,15,7]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：BFS，二叉树的层序遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="32-II-从上到下打印二叉树-II"><a href="#32-II-从上到下打印二叉树-II" class="headerlink" title="32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">32 - II. 从上到下打印二叉树 II</a></h3><p><strong>题意描述</strong>：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>输出其层序遍历结果：<br>[ [3],<br>  [9,20],<br>  [15,7]]<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">32 - III. 从上到下打印二叉树 III</a></h3><p><strong>题意描述</strong>：实现一个函数按照之字形顺序打印二叉树。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>输出层次遍历结果：<br>[ [3],<br>  [20,9],<br>  [15,7]]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：同前几题类似，直接贴出代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        flag = !flag;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            tmp.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) res.<span class="hljs-built_in">emplace_back</span>(tmp.<span class="hljs-built_in">rbegin</span>(), tmp.<span class="hljs-built_in">rend</span>());<br>        <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">emplace_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">26. 树的子结构</a></h3><p><strong>题意描述</strong>：输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。（约定空树不是任意一个树的子结构）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定的树 A:<br>     3<br>    / \<br>   4   5<br>  / \<br> 1   2<br>给定的树 B：<br>   4 <br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：递归法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;		<span class="hljs-comment">// 空树不是任何树的子结构</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSubStr</span>(A, B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStr</span><span class="hljs-params">(TreeNode* p1, TreeNode* p2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p1 || p1-&gt;val != p2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStr</span>(p1-&gt;left, p2-&gt;left) &amp;&amp; <span class="hljs-built_in">isSubStr</span>(p1-&gt;right, p2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">27. 二叉树的镜像</a></h3><p><strong>题意描述</strong>：输入一个二叉树，该函数输出它的镜像。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>     4<br>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>镜像输出：<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1<br></code></pre></div></td></tr></table></figure>
<p>递归解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">auto</span> tmp = root-&gt;right;<br>    root-&gt;right = <span class="hljs-built_in">mirrorTree</span>(root-&gt;left);<br>    root-&gt;left = <span class="hljs-built_in">mirrorTree</span>(tmp);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>辅助栈解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    stack&lt;TreeNode*&gt; stk;<br>    stk.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> node = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node-&gt;left) stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">28. 对称的二叉树</a></h3><p><strong>题意描述</strong>：判断一棵二叉树是不是对称的。对称二叉树定义：二叉树和它的镜像一样。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">二叉树 [1,2,2,3,4,4,3] 是对称的<br>	1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：递归法。</p>
<ul>
<li>空树满足对称二叉树的性质；</li>
<li>不满足对称二叉树的情况：左右子儿子中存在空节点，左右子儿子节点值不相等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">12. 矩阵中的路径</a></h3><p><strong>题意描述</strong>：给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;<br>输出：true<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：DFS + 回溯。首先遍历网格 <code>board</code> ，查找单词首字母。由于同一个单元格内的字母不能重复使用，因此在搜索的过程中我们需要标记已经访问过的位置，并在本次搜索结束时进行回溯。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == word[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;		<span class="hljs-comment">// 标记已访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n &amp;&amp; board[a][b] == word[u]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, a, b, u + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        board[x][y] = t;        <span class="hljs-comment">// 回溯</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">13. 机器人的运动范围</a></h3><p><strong>题意描述</strong>：地上有一个 $m$ 行 $n$ 列的方格，从坐标 [0, 0] 到坐标 [m - 1, n - 1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。求机器人能够到达多少个格子。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。<br><br>输入：m = 2, n = 3, k = 1<br>输出：3<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：DFS。<code>vis</code> 数组标记已经访问过的位置，<code>canArrived</code> 函数判断数组的位置是否可达。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; vis;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vis = vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(m, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">canArrived</span>(x, y, k)) <span class="hljs-keyword">return</span>;<br><br>        res++;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n &amp;&amp; !vis[a][b]) &#123;<br>                <span class="hljs-built_in">dfs</span>(a, b, m, n, k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canArrived</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a) &#123;<br>            t += a % <span class="hljs-number">10</span>;<br>            a /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b) &#123;<br>            t += b % <span class="hljs-number">10</span>;<br>            b /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t &lt;= k;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">34. 二叉树中和为某一值的路径</a></h3><p><strong>题意描述</strong>：给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：DFS + 回溯。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> curSum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>        curSum += root-&gt;val;		<span class="hljs-comment">// curSum 是传值，所以不需要回溯</span><br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (curSum == target &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, curSum, target);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, curSum, target);<br>        path.<span class="hljs-built_in">pop_back</span>();		<span class="hljs-comment">// 回溯</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">36. 二叉搜索树与双向链表</a></h3><p><strong>题意描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211116191037.png" srcset="/img/loading.gif" lazyload width = “300px” /></div>

<div align = center><img src="https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161340.png" srcset="/img/loading.gif" lazyload width = “500px” /></div>



<p><strong>解题思路</strong>：二叉搜索树的中序遍历为<strong>递增序列</strong>。算法流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">dfs(cur): 递归法中序遍历；<br>1. 终止条件：当 cur 为 空表示越过叶子节点，需返回；<br>2. 递归左子树 dfs(cur-&gt;left)<br>3. 构建链表：<br>	当 pre 为空时：代表正在访问链表头节点，记为 head；<br>	当 pre 不为空时：修改双向节点指向，pre-&gt;right = cur，cur-&gt;left = pre；<br>	保存 cur: 更新 pre = cur, 即节点 cur 是后继节点的 pre；<br>4. 递归右子树 dfs(cur-&gt;right)<br></code></pre></div></td></tr></table></figure>
<p>注意：在本算法中，需要特判根节点为 <code>nullptr</code> 的情况，中序遍历完成后，<code>head</code> 指向头节点，<code>pre</code> 指向尾节点，主函数中修改 <code>head</code> 和 <code>pre</code> 的双向节点指向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Node *pre, *head;<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">nullptr</span>) head = cur;<br>        <span class="hljs-keyword">else</span> &#123;<br>            pre-&gt;right = cur;<br>            cur-&gt;left = pre;<br>        &#125;<br>        pre = cur;<br>        <span class="hljs-built_in">dfs</span>(cur-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">54. 二叉搜索树的第k大节点</a></h3><p><strong>题意描述</strong>：给定一棵二叉搜索树，请找出其中第 $k$ 大的节点。（1 ≤ k ≤ 二叉搜索树元素个数）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / \<br> 1   4<br>  \<br>   2<br>输出: 4<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：二叉搜索树的中序遍历为递增序列。若按照右中左顺序遍历就可以得到递减序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, k);<br>        k--;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k) <span class="hljs-built_in">dfs</span>(root-&gt;left, k);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 - I. 二叉树的深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">55 - I. 二叉树的深度</a></h3><p><strong>题意描述</strong>：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树 [3,9,20,null,null,15,7]，<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路 1</strong>：DFS 遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// DFS 遍历</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span> (!left || !right) <span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路 2</strong>：BFS 求二叉树的层数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> n = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(n--) &#123;<br>            <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55 - II. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">55 - II. 平衡二叉树</a></h3><p><strong>题意描述</strong>：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定二叉树 [3,9,20,null,null,15,7]<br><br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回 true 。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：平衡二叉树的定义是其<strong>任意节点</strong>的左右子树的深度相差不超过 1。本题本质上是需要求二叉树的高度，因此可以套用上一题的解题思路来解本题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="68-I-叉搜索树的最近公共祖先"><a href="#68-I-叉搜索树的最近公共祖先" class="headerlink" title="68 - I. 叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68 - I. 叉搜索树的最近公共祖先</a></h3><p><strong>题意描述</strong>：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>祖先</strong>： 若节点 $p$ 在节点 $root$ 的左（右）子树中，或 $p = root$ ，则称 $root$ 是 $p$ 的祖先。</p>
<p><strong>最近公共祖先</strong>： 设节点 $root$ 为节点 $p, q$ 的某公共祖先，若其左子节点 <code>root-&gt;left</code> 和右子节点 <code>root-&gt;right</code> 都不是 $p, q$ 的公共祖先，则称 $root$ 是最近的公共祖先。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6 <br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br></code></pre></div></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li>所有节点的值都是唯一的；</li>
<li><code>p</code> 与 <code>q</code> 为不同节点且均存在于给定的二叉搜索树中；</li>
</ul>
<p><strong>解题思路</strong>：题中两个重要条件：1）树为二叉搜索树；2）树中所有节点的值都是唯一的。根据这两个条件可以得到 <code>p,q</code> 与 <code>root</code> 的关系：</p>
<ul>
<li>若 <code>root-&gt;val == p-&gt;val</code>，<code>root</code> 和 <code>p</code> 指向同一个节点；</li>
<li>若 <code>root-&gt;val &gt; p-&gt;val</code>，<code>p</code> 在 <code>root</code> 的左子树中；</li>
<li>若 <code>root-&gt;val &lt; p-&gt;val</code>，<code>p</code> 在 <code>root</code> 的右子树中；</li>
</ul>
<p><strong>解法 1：迭代</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">// 算法流程<br>while root 不为空<br>	if p,q 都在 root 的右子树中：<br>		遍历 root-&gt;right<br>	else if p,q 都在 root 的左子树中：<br>		遍历 root-&gt;left<br>	else 找到了最近公共祖先，break<br>return root<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(root) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) <br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">// 迭代法优化：有序性——&gt; p-&gt;val &lt;= q-&gt;val</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;val &gt; q-&gt;val) &#123;<br>        <span class="hljs-built_in">swap</span>(p, q);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(root) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; q-&gt;val) <br>            root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val) <br>            root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>解法 2：递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">// 算法流程<br>当 p,q 都在 root 的右子树中，进入递归 root-&gt;right 并返回<br>当 p,q 都在 root 的左子树中，进入递归 root-&gt;left 并返回<br>返回值：最近公共祖先 root<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="68-II-二叉树的最近公共祖先"><a href="#68-II-二叉树的最近公共祖先" class="headerlink" title="68 - II. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68 - II. 二叉树的最近公共祖先</a></h3><p><strong>题意描述</strong>：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><br></code></pre></div></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p><strong>解题思路</strong>：针对 <code>root</code> 是 <code>p,q</code> 的最近公共祖先，则可能是以下情况之一：</p>
<ol>
<li><code>p</code> 和 <code>q</code> 在 <code>root</code> 的子树中，且分别位于 <code>root</code> 的两侧；</li>
<li><code>p == root</code> ，且 <code>q</code> 在 <code>root</code> 的左或右子树中；</li>
<li><code>q == root</code> ，且 <code>p</code> 在 <code>root</code> 的左或右子树中。</li>
</ol>
<p><strong>函数返回值分析</strong>：</p>
<ul>
<li><code>left</code> 和 <code>right</code> 同时为空：<code>root</code> 的左 / 右子树中都不包含 <code>p,q</code> ，返回 <code>nullptr</code>；</li>
<li><code>left</code> 和 <code>right</code> 同时不为空：说明 <code>p,q</code> 分列在 <code>root</code> 的异侧，因此 <code>root</code> 为最近公共祖先，返回 <code>root</code>；</li>
<li><code>left</code> 为空，<code>right</code> 不为空：<code>p,q</code> 都不在 <code>root</code> 的左子树中，直接返回 <code>right</code>，具体可分为两种情况：<ul>
<li><code>p,q</code> 其中一个在 <code>root</code> 的右子树中，此时 <code>right</code> 指向 <code>p</code> （假设为 <code>p</code>）；</li>
<li><code>p,q</code> 两节点都在 <code>root</code> 的右子树中，此时 <code>right</code> 指向 最近公共祖先节点。</li>
</ul>
</li>
<li><code>left</code> 不为空，<code>right</code> 为空：与情况 3 类似分析过程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">37. 序列化二叉树</a></h3><p><strong>题意描述</strong>：请实现两个函数，分别用来序列化和反序列化二叉树。你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-built_in">dfs_s</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode* root, string&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            res += <span class="hljs-string">&quot;null &quot;</span>;                     <span class="hljs-comment">// null + 空格表示</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        res += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span>;      <span class="hljs-comment">// 节点值 + 空格表示</span><br>        <br>        <span class="hljs-comment">// 递归处理左子树和右子树</span><br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, res);<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;right, res);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 当前遍历字符串中的位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(data, u);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs_d</span><span class="hljs-params">(string&amp; data, <span class="hljs-keyword">int</span>&amp; u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == data.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        // data 中字符的下标从 0 到 data.size() - 1, data[data.size() - 1] 的位置是空格</span><br><span class="hljs-comment">        // 最后一次递归结束，u = k + 1，所以 u == data.size() 为函数终止条件</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-keyword">int</span> k = u;      <span class="hljs-comment">// 记录空格的位置</span><br>        <span class="hljs-keyword">while</span> (data[k] != <span class="hljs-string">&#x27; &#x27;</span>) k++;<br>        <br>        <span class="hljs-keyword">if</span> (data[u] == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;       <span class="hljs-comment">// 当前遍历的是 &quot;null&quot;，此时 u 指向 &#x27;n&#x27;, k 指向 &quot;null&quot; 后的空格</span><br>            u = k + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;         <span class="hljs-comment">// 结束本次递归，返回空指针</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> is_minus = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 判断当前值是否是负数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                is_minus = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            val = val * <span class="hljs-number">10</span> + data[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (is_minus) val = -val;       <span class="hljs-comment">// 负数特判</span><br>        u = k + <span class="hljs-number">1</span>;                      <span class="hljs-comment">// 下一个需要遍历的位置</span><br>        <br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        root-&gt;left = <span class="hljs-built_in">dfs_d</span>(data, u);<br>        root-&gt;right = <span class="hljs-built_in">dfs_d</span>(data, u);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">38. 字符串的排列</a></h3><p><strong>题意描述</strong>：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：s = &quot;abc&quot;<br>输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>1 &lt;= s 的长度 &lt;= 8</code></p>
<p><strong>解题思路</strong>：对于一个长度为 $n$ 的字符串（假设字符互不重复），其排列方案数有：$n \times (n - 1) \times (n - 2) \times … \times 2 \times 1$</p>
<p>当字符串存在重复的字符时，排列方案也存在重复的排列方案。为排除重复方案，需要在固定某位字符的时候，保证每种字符只在此位固定一次，即遇到重复字符时不交换，直接跳过。</p>
<div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201161410.png" width = "500px" /></div>



<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string str;<br>    <span class="hljs-keyword">int</span> state;			<span class="hljs-comment">// 记录访问状态</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());		<span class="hljs-comment">// 记得先排序，方便去重</span><br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; s[i - <span class="hljs-number">1</span>] == s[i] &amp;&amp; !(state &amp; (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)))) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!(state &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>                state ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>                str += s[i];<br>                <span class="hljs-built_in">dfs</span>(s, u + <span class="hljs-number">1</span>);<br>                str.<span class="hljs-built_in">pop_back</span>();<br>                state ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">10- I. 斐波那契数列</a></h3><p><strong>题意描述</strong>：输入 $n$ 求斐波那契（Fibonacci）数列的第 <code>n</code> 项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br></code></pre></div></td></tr></table></figure>
<p>答案需要取模 1e9+7（1000000007），<code>0 &lt;= n &lt;= 100</code>。</p>
<p><strong>解题思路</strong>：题中已经给出了 $f[n]$ 的状态表示，考虑动态规划。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = b;<br>        b = (a + b) % MOD;<br>        a = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>快速幂解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; res = <span class="hljs-built_in">qmi</span>(A, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">qmi</span>(vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A, <span class="hljs-keyword">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(k) &#123;<br>            <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br>                ret = <span class="hljs-built_in">mul</span>(ret, A);<br>            &#125;<br>            A = <span class="hljs-built_in">mul</span>(A, A);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">mul</span>(vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; A, vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; B) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; res = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                res[i][j] = (A[i][<span class="hljs-number">0</span>] * B[<span class="hljs-number">0</span>][j] + A[i][<span class="hljs-number">1</span>] * B[<span class="hljs-number">1</span>][j])  % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10- II. 青蛙跳台阶问题</a></h3><p><strong>题意描述</strong>：每次可以跳 $1$ 级台阶也可以跳 $2$ 级台阶，求青蛙跳上一个 $n$ 级台阶总共有多少种跳法。答案对 $1e9+7$ 取模。</p>
<p><strong>解题思路</strong>：状态计算：$f[i] = f[i - 1] + f[i - 2]$。特别地，对于第 $0$ 级台阶有 $1$ 种跳法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> c = (a + b) % <span class="hljs-number">1000000007</span>;<br>        a = b;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">63. 股票的最大利润</a></h3><p><strong>题意描述</strong>：把某股票的价格按照时间先后顺序存储在数组中，求买卖该股票一次可能获得的最大利润。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [7,1,5,3,6,4]<br>输出: 5<br><br>输入: [7,6,4,3,1]<br>输出: 0<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：遍历整个数组，每次遍历到一个元素时计算到目前为止的最低价格，并求得当前股价与最低价格之差（差值与本来结果取 $max$）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minPrice = INT_MAX, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : prices) &#123;<br>        minPrice = <span class="hljs-built_in">min</span>(minPrice, x);<br>        res = <span class="hljs-built_in">max</span>(res, x - minPrice);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">42. 连续子数组的最大和</a></h3><p><strong>题意描述</strong>：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：贪心。直接在原数组上进行遍历，只有数组中前一个元素大于 0 时才会对当前连续子数组的最大和有贡献价值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>        res = <span class="hljs-built_in">max</span>(res, nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">47. 礼物的最大价值</a></h3><p><strong>题意描述</strong>：在一个 $m \times n$ 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，求礼物最大价值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: <br>[ [1,3,1],<br>  [1,5,1],<br>  [4,2,1]]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：DP 状态计算：$\text{f[i][j] = max(f[i][j - 1], f[i - 1][j]) + grid[i][j]}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[m][n];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">46. 把数字翻译成字符串</a></h3><p><strong>题意描述</strong>：给定一个数字，我们定义翻译规则：$0 \sim 25$  分别翻译成 $a \sim z$ 。给定一个数字，求一共有多少种不同的翻译方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：考虑动态规划。定义状态表示：$dp[i]$ 为将前 $i$ 个数字翻译为字符串的方案数，其中 $dp[0] = 1$。</p>
<p>状态计算：$dp[i] = dp[i - 1] + dp[i - 2]$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    string s = <span class="hljs-built_in">to_string</span>(num);<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 边界情况 dp[0] = 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> t = (s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">9</span> &amp;&amp; t &lt; <span class="hljs-number">26</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">48. 最长不含重复字符的子字符串</a></h3><p><strong>题意描述</strong>：给定一个字符串，求它的最长的不包含重复字符的子字符串的长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：哈希表 + 滑动窗口。核心思想：保持窗口 $\text{[j, i]}$ 内不含有重复字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        hash[s[i]]++;<br>        <span class="hljs-keyword">while</span>(hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j++]]--;<br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">19. 正则表达式匹配</a></h3><p><strong>题意描述</strong>：实现一个函数用来匹配包含 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code> 的正则表达式。模式中的字符 <code>&#39;.&#39;</code> 表示任意一个字符，而 <code>&#39;*&#39;</code> 表示它前面的字符可以出现任意次（含0次）。模板串需要匹配整个字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">s = &quot;aa&quot;<br>p = &quot;a*&quot;<br>输出: true<br><br>s = &quot;aab&quot;<br>p = &quot;c*a*b&quot;<br>输出: true<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母；</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code> ，无连续的 <code>*</code></li>
</ul>
<p><strong>解题思路 1</strong>：动态规划。</p>
<p><strong>状态表示</strong> <code>f[i][j]</code>：</p>
<ul>
<li><p>集合：所有 $s[1] \sim s[i]$ 和 $p[1] \sim p[j]$ 的匹配方案，这里假设下标从 $1$ 开始，并有 <code>f[0][0] = true</code>。</p>
</li>
<li><p>属性：<code>bool</code> 是否存在一个合法方案</p>
</li>
</ul>
<p><strong>状态计算</strong>：</p>
<ul>
<li><p>$p[j] \neq *$  </p>
<p><code>f[i][j] = (s[i] == p[j] || p[j] == &#39;.&#39;) &amp;&amp; f[i - 1][j - 1]</code></p>
</li>
<li><p>$p[j] = *$</p>
<p><code>f[i][j] = f[i][j-2] || f[i-1][j-2] &amp;&amp; (s[i] == p[j-1] || p[j-1] == &#39;.&#39;) || f[i-2][j-2] &amp;&amp; (s[i] == p[j-1] &amp;&amp; s[i-1] == p[j-1] || p[j-1] == &#39;.&#39;) || ...</code></p>
<p>上述式子表示：<code>p[j-1]p[j]</code> 匹配 $s$ 中 $0$ 个字符的情况 || 匹配 $s$ 中 $1$ 个字符的情况 || 匹配 $s$ 中 $2$ 个字符的情况 || …</p>
<p>状态转移过程优化到 $O(1)$ 时间：考虑 <code>f[i-1][j]</code> 的情况</p>
<p><code>f[i-1][j] = f[i-1][j-2] || f[i-2][j-2] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &#39;.&#39;) || ...</code></p>
<p><strong>找到共同点：</strong></p>
<p><code>f[i][j] = f[i][j-2] || f[i-1][j] &amp;&amp; (s[i] == p[j-1] || p[j-1] == &#39;.&#39;)</code></p>
</li>
</ul>
<p>循环枚举 $i$ 从 $0 \sim n$ ，$j$ 从 $1 \sim m$ ，因为 <code>f[0][j]</code> 有意义。</p>
<p>此时状态数量是 $nm$，转移需要 $O(1)$ 时间，总的时间复杂度就是 $n^2$ 级别。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = p.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>        s = <span class="hljs-string">&#x27; &#x27;</span> + s, p = <span class="hljs-string">&#x27; &#x27;</span> + p;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= m &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (i &amp;&amp; p[j] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    f[i][j] = f[i][j - <span class="hljs-number">2</span>] || i &amp;&amp; f[i - <span class="hljs-number">1</span>][j] &amp;&amp; (s[i] == p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路 2</strong>：动态规划（记忆化搜索），$n,m$ 分别表示 $s,p$ 的长度，状态转移复杂度是 $O(1)$，总的时间复杂度为 $O(nm)$。</p>
<p><strong>状态表示</strong> <code>f[i][j]</code>：</p>
<ul>
<li><p>集合： $s[i,…]$ 和 $p[j…]$ 的匹配方案。</p>
</li>
<li><p>属性：<code>bool</code> 是否存在一个合法方案</p>
</li>
</ul>
<p><strong>状态计算</strong>：</p>
<p>由于 <code>.</code> 可以匹配任意字符，<code>*</code> 表示其前面的字符可以出现任意次数。</p>
<ol>
<li><p>$p[j+1]$ 不是 <code>*</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f[i][j] = (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; f[i + <span class="hljs-number">1</span>][j +<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>$p[j + 1]$ 是 <code>*</code> </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// p[j]p[j+1] 表示 p[j] 出现 0次 || ... 出现 1 次 || ... 出现 2 次</span><br>f[i][j] = f[i][j + <span class="hljs-number">2</span>] || (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; f[i + <span class="hljs-number">1</span>][j]<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p><u>第二种情况解释</u>：</p>
<p>最直观的转移方式是：枚举通配符 <code>*</code> 可以匹配多少个 <code>p[j]</code>，只要有一种情况可以匹配，则 <code>f[i][j]</code> 就为真。但是，我们可以发现，<code>f[i][j]</code> 除了枚举 $0$ 个 <code>p[j]</code> 之外，其余的枚举操作都包含在 <code>f[i + 1][j]</code> 中，因此我们只要判断 <code>(s[i] == p[j] || p[j] == &#39;.&#39;) &amp;&amp; f[i + 1][j]</code> 即可。</p>
<p>边界：<code>f[n][m] = true</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; f;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        m = p.<span class="hljs-built_in">size</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s, p);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, string&amp; s, string&amp; p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][y];<br>        <span class="hljs-keyword">if</span> (y == m) &#123;<br>            <span class="hljs-keyword">return</span> f[x][y] = x == n;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> first_match = x &lt; n &amp;&amp; (s[x] == p[y] || p[y] == <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">bool</span> ans;<br>        <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; m &amp;&amp; p[y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            ans = <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">2</span>, s, p) || first_match &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, s, p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = first_match &amp;&amp; <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, s, p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x][y] = ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">49. 丑数</a></h3><p><strong>题意描述</strong>：丑数是指：只包含质因子 <code>2,3,5</code> 的数。求按照从小到大的顺序的第 $n$ 个丑数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：从小到大枚举每一个丑数，并用指针索引 <code>a,b,c</code> 分别指示由 <code>2,3,5</code> 因子转移而来的丑数位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span> * dp[a], <span class="hljs-built_in">min</span>(<span class="hljs-number">3</span> * dp[b], <span class="hljs-number">5</span> * dp[c]));<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">2</span> * dp[a]) a++;<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">3</span> * dp[b]) b++;<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">5</span> * dp[c]) c++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60. n个骰子的点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">60. n个骰子的点数</a></h3><p><strong>题意描述</strong>：将一个骰子投掷 $n$ 次，获得的总点数为 $s$ ，$s$ 的可能范围是 $n \sim 6n$ 。输入 $n$ ，打印出 $s$ 的所有可能的值出现的概率。用一个浮点数数组返回答案，其中第 $i$ 个元素代表这 $n$ 个骰子所能掷出的点数集合中第 $i$ 小的那个的概率。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>1 &lt;= n &lt;= 11</code></p>
<p><strong>解题思路 1</strong>：DFS。<code>dfs(n, s)</code>：一共投掷了 $n$ 次，总和是 $s$ 的情况下的方案数目。（<strong>TLE</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= n * <span class="hljs-number">6</span>; i++) &#123;<br>            nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dfs</span>(n, i));       <span class="hljs-comment">// 投掷 n 次，总和是 i 的方案数目</span><br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res[i] = (<span class="hljs-keyword">double</span>)nums[i] / sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> !sum;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            res += <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, sum - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路 2</strong>：动态规划。<code>f[i][j]</code>：前 <code>i</code> 次，总和是 <code>j</code> 的方案数。由于第 <code>i</code> 次可能扔出的点数为 $1 \sim 6$，所以：</p>
<script type="math/tex; mode=display">
f[i][j] = f[i - 1][j - 1] + f[i - 1][j - 2] + f[i - 1][j - 3]+f[i - 1][j - 4]+ f[i - 1][j - 5] + f[i - 1][j - 6]</script><p>，我们只需要用到最后一次的结果，可以使用滚动数组优化空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化前</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;      <span class="hljs-comment">// 枚举 n 次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i * <span class="hljs-number">6</span>; j++) &#123;      <span class="hljs-comment">// 枚举总点数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-number">6</span>, j); k++) &#123;      <span class="hljs-comment">// 最后一次投掷的点数</span><br>                f[i][j] += f[i - <span class="hljs-number">1</span>][j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= n * <span class="hljs-number">6</span>; i++) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(f[n][i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans[i] = (<span class="hljs-keyword">double</span>)res[i] / sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 优化后</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) dp[i] = <span class="hljs-number">1</span>;     <span class="hljs-comment">// DP初始值，表示1个骰子扔出的可能数为 1~6</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;              <span class="hljs-comment">// 第 2 ~ n 次投掷</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">6</span> * i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;      <span class="hljs-comment">// 投掷总点数</span><br>            dp[j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">6</span>; k &gt;= <span class="hljs-number">1</span>; k--) &#123;      <span class="hljs-comment">// 上一次投掷结果</span><br>                <span class="hljs-keyword">if</span> (j - k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                dp[j] += dp[j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(dp.begin() + n, dp.end())</span></span>;<br><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(res.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans[i] = (<span class="hljs-keyword">double</span>)res[i] / sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>用于解决一类<strong>基于 “子段” 的统计问题</strong>。子段：数组中连续的一段（下标范围可以用一个闭区间来表示）。这类题目的朴素做法都是两重循环的枚举，枚举左端点 $l$ 、右端点 $r$ （$l \leq r$） ，优化手段都是找到枚举中的冗余部分，将其去除。</p>
<p><strong>优化策略：</strong></p>
<ul>
<li>固定右端点，看左端点的取值范围<ul>
<li>例如左端点的取值范围是一个前缀，可以用<u>前缀和</u>等算法维护前缀信息</li>
</ul>
</li>
<li>移动一个端点，看另一个端点的变化情况<ul>
<li>例如一个端点跟随另一个端点单调移动，<u>滑动窗口</u></li>
<li><u>双指针扫描</u></li>
</ul>
</li>
</ul>
<h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">18. 删除链表的节点</a></h3><p><strong>题意描述</strong>：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br></code></pre></div></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<p><strong>解题思路</strong>：题中说了链表节点值互不相同，我们只需按照节点的值进行查找遍历即可。注意要删除的点可能是链表的头节点，因此我们需要设置虚拟头节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* cur = dummy;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22. 链表中倒数第k个节点</a></h3><p><strong>题意描述</strong>：输入一个链表，输出该链表中倒数第k个节点。（链表的尾节点是倒数第1个节点。）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双指针。设置指针 $\text{p1}$ 指向 $\text{head}$，指针 $\text{p2}$ 指向 $\text{head}$ 后面的第 $k$ 个节点的位置。同时移动两个指针节点，直到 $\text{p2}$ 指向 $\text{nullptr}$ 为止。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode *p1 = head, *p2 = head;<br>    <span class="hljs-keyword">while</span> (k--) <br>        p2 = p2-&gt;next;<br>    <span class="hljs-keyword">while</span>(p2) &#123;<br>        p1 = p1-&gt;next, p2 = p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25. 合并两个排序的链表</a></h3><p><strong>题意描述</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双指针。两个指针分别指向链表当前遍历到的节点，比较大小关系即可。同样本题需要设置虚拟头节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">auto</span> cur = dummy;<br>    <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            cur-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1) cur-&gt;next = l1;<br>    <span class="hljs-keyword">else</span> cur-&gt;next = l2;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h3><p><strong>题意描述</strong>：输入两个链表，找出它们的第一个公共节点。如果两个链表没有交点，返回空节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br>输出第一个公共节点c1<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双指针。两个指针分别指向两个链表，各自依次往后遍历，直到两个指针指向的链表节点相等为止。循环内，当某个节点遍历到 $\text{nullptr}$ 时，我们让其从另一个链表的位置开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p1 = headA, p2 = headB;<br>    <span class="hljs-keyword">while</span>(p1 != p2) &#123;<br>        p1 = p1 ? p1-&gt;next : headB;<br>        p2 = p2 ? p2-&gt;next : headA;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">21. 调整数组顺序使奇数位于偶数前面</a></h3><p><strong>题意描述</strong>：输入一个整数数组，我们需要调整数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [1,2,3,4]<br>输出：[1,3,2,4] <br>注：[3,1,2,4] 也是正确的答案之一。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双指针。两个指针分别数组的头和尾，指针 $i$ 从前往后找偶数位置，指针 $j$ 从后往前找奇数位置，满足 $i &lt; j$ 时则交换两个元素的值，直到两个指针位置交错时循环结束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>)) i++;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)) j--;<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">57. 和为s的两个数字</a></h3><p><strong>题意描述</strong>：输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：双指针。两个指针分别指向数组的头和尾，根据判断条件向中间收缩。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> &#123;nums[i], nums[j]&#125;;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58 - I. 翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">58 - I. 翻转单词顺序</a></h3><p><strong>题意描述</strong>：输入一个字符串，翻转字符串中单词的顺序，但单词内字符的顺序不变。（标点符号和普通字母一样处理）</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: &quot;  hello world!  &quot;<br>输出: &quot;world! hello&quot;<br></code></pre></div></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
</li>
<li><p>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</li>
</ul>
<p><strong>解题思路</strong>：双指针。保持区间 $[i, j)$ 内的字符串恰好是一个单词，然后我们翻转该单词，并用 $k$ 来标记期望输出字符串的长度。循环结束我们 <code>resize</code> 字符串长度，并反转字符串即可得到符合要求的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>        <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">int</span> j = i;<br>        <span class="hljs-keyword">while</span>(j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + j);<br>        <span class="hljs-keyword">if</span> (k) s[k++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) s[k++] = s[i++];<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(k);<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">45. 把数组排成最小的数</a></h3><p><strong>题意描述</strong>：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [10,2]<br>输出: &quot;102&quot;<br><br>输入: [3,30,34,5,9]<br>输出: &quot;3033459&quot;<br></code></pre></div></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>输出结果可能非常大，我们返回一个字符串即可；</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0；</li>
</ul>
<p><strong>解题思路</strong>：自定义一个排序逻辑，针对数组 $nums$ 中任意两个数字的字符串为 $x$ 和 $y$，规定 $x + y &lt; y + x$ ，则 $x$ 应该排在 $y$ 的前面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [=](<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)&#123;<br>        string stra = <span class="hljs-built_in">to_string</span>(a), strb = <span class="hljs-built_in">to_string</span>(b);<br>        <span class="hljs-keyword">return</span> stra + strb &lt; strb + stra;<br>    &#125;);<br><br>    <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>        res += <span class="hljs-built_in">to_string</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title=" 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/"> 61. 扑克牌中的顺子</a></h3><p><strong>题意描述</strong>：从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,2,3,4,5]<br>输出: True<br><br>输入: [0,0,1,2,5]<br>输出: True<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：对数组进行排序，并统计数组中为 0 的元素个数。5 张牌是顺子的条件：</p>
<ul>
<li>除了大小王之外，不含有重复的元素；</li>
<li>数组中最大的元素 - 数组中最小的非零元素 $\leq$ 4；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nums[cnt] == <span class="hljs-number">0</span>) &#123;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cnt + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">back</span>() - nums[cnt] &lt;= <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">40. 最小的k个数</a></h3><p><strong>题意描述</strong>：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：排序：快速排序，归并排序，堆排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">quick_sort</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        arr.<span class="hljs-built_in">resize</span>(k);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[(l + r) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>        <span class="hljs-built_in">quick_sort</span>(arr, l, j), <span class="hljs-built_in">quick_sort</span>(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 归并排序子函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(arr, l, mid), <span class="hljs-built_in">merge_sort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = arr[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = arr[j++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) arr[i] = tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">41. 数据流中的中位数</a></h3><p><strong>题意描述</strong>：设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code> ：从数据流中添加一个整数到数据结构中。</li>
<li><code>double findMedian()</code>：返回目前所有元素的中位数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：<br>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：设计两个堆，一个大根堆 <code>maxHeap</code>，一个小根堆 <code>minHeap</code>。</p>
<ul>
<li>维持大根堆 <code>maxHeap</code> 内元素数量<strong>至多</strong>比小根堆 <code>minHeap</code> 多一个。<ul>
<li>若 <code>maxHeap.size() == minHeap.size()</code>，中位数是两者堆顶元素的均值；</li>
<li>若 <code>maxHeap.size() == minHeap.size() + 1</code>，中位数是 <code>maxHeap.top()</code>； </li>
</ul>
</li>
<li>有序性：<code>maxHeap.top() &lt;= minHeap.top()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    priority_queue&lt;<span class="hljs-keyword">int</span>&gt; maxHeap;    <span class="hljs-comment">// 默认大根堆</span><br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap; <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-built_in">MedianFinder</span>() &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        maxHeap.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() &gt; minHeap.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(maxHeap.<span class="hljs-built_in">top</span>());<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (minHeap.<span class="hljs-built_in">size</span>() &amp;&amp; maxHeap.<span class="hljs-built_in">top</span>() &gt; minHeap.<span class="hljs-built_in">top</span>()) &#123;<br>            <span class="hljs-keyword">int</span> x = maxHeap.<span class="hljs-built_in">top</span>(), y = minHeap.<span class="hljs-built_in">top</span>();<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            maxHeap.<span class="hljs-built_in">push</span>(y);<br>            minHeap.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() == minHeap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (maxHeap.<span class="hljs-built_in">top</span>() + minHeap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">15. 二进制中1的个数</a></h3><p><strong>题意描述</strong>：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<p><strong>解题思路</strong>：<code>n&amp;(n-1)</code> 每次移除最低位上的比特 <code>1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        res++;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">65. 不用加减乘除做加法</a></h3><p><strong>题意描述</strong>：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: a = 1, b = 1<br>输出: 2<br></code></pre></div></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<p><strong>解题思路</strong>：不进位加法：<code>a^b</code>，进位：<code>a&amp;b</code>。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b) &#123;<br>        <span class="hljs-keyword">int</span> sum = a ^ b;<br>        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        a = sum;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56 - I. 数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">56 - I. 数组中数字出现的次数</a></h3><p><strong>题意描述</strong>：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：位运算，假设答案分别为 $a$ 和 $b$，且 <code>t = a ^ b</code>。</p>
<ul>
<li>遍历数组先求 $t$ ；</li>
<li>求 $t$ 的第几位上是 $1$；</li>
<li>遍历数组求 $a$，<code>b = t ^ a</code>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>        t ^= num;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!(t &gt;&gt; i &amp; <span class="hljs-number">1</span>)) &#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num &gt;&gt; i &amp; <span class="hljs-number">1</span>) a ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;a, t ^ a&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="56-II-数组中数字出现的次数-II"><a href="#56-II-数组中数字出现的次数-II" class="headerlink" title="56 - II. 数组中数字出现的次数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">56 - II. 数组中数字出现的次数 II</a></h3><p><strong>题意描述</strong>：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：nums = [3,4,3,3]<br>输出：4<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：$res$ 的第 $i$ 个二进制位就是数组中所有元素的第 $i$ 个二进制位之和除以 $3$ 的余数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;num : nums) &#123;<br>            t += (num &gt;&gt; i &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        res += (t % <span class="hljs-number">3</span>) &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">64. 求1+2+…+n</a></h3><p><strong>题意描述</strong>：求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: n = 3<br>输出: 6<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：运算符 <code>&amp;&amp;</code> 的短路求值特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = n;<br>    n &amp;&amp; (res += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">39. 数组中出现次数超过一半的数字</a></h3><p><strong>题意描述</strong>：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：一共三种解法，其中摩尔投票法为最优解法。</p>
<ul>
<li>解法1：数组由小到大排序，取中位数；</li>
<li>解法2：哈希表统计数组元素出现次数；</li>
<li><strong>解法3</strong>：摩尔投票法，票数正负抵消；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>], cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>            res = nums[i];<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (res == nums[i]) cnt++;<br>            <span class="hljs-keyword">else</span> cnt--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">66. 构建乘积数组</a></h3><p><strong>题意描述</strong>：给定一个数组 $A[0,1,…,n-1]$，请构建一个数组 $B[0,1,…,n-1]$，其中 $B[i]$ 的值是数组 $A$ 中除了下标 $i$ 以外的元素的积, 即 $B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]$。不能使用除法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]<br></code></pre></div></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li><code>a.length &lt;= 100000</code></li>
</ul>
<p><strong>解题思路</strong>：构建前后缀差分数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, t = a[<span class="hljs-number">0</span>]; i &lt; n; i++) &#123;<br>        b[i] = t;<br>        t *= a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>, t = a[n - <span class="hljs-number">1</span>]; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        b[i] *= t;<br>        t *= a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">14- I. 剪绳子</a></h3><p><strong>题意描述</strong>：将一根长度为 $n$ 的绳子剪成整数长度的 $m$ 段（$m,n$ 都是整数，$n,m&gt;1$），每段绳子的长度记为 $k[0],k[1]…k[m-1]$ 。请问  $k[0] \times k[1] \times…\times k[m-1]$ 可能的最大乘积是多少。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br></code></pre></div></td></tr></table></figure>
<p>提示：<code>2 &lt;= n &lt;= 58</code></p>
<p><strong>解题思路 1</strong>：<strong>贪心</strong>：将一个正整数 $N$ 拆分成若干个整数有有限种拆法，所以存在最大乘积。<u>重要推论</u>：1）所有绳段长度相等时，乘积最大；2）最优绳段长度为 3；</p>
<p>假设 $N=n_1 + n_2 + … + n_k$，并且 $n_1 \times n_2 \times n_3 \times … \times n_k$ 是最大乘积。</p>
<ul>
<li>显然，$1$ 不会出现在其中；</li>
<li>如果对于某个 $n_i \geq 5$，那么将 $n_i$ 拆分成 $3 + (n_i - 3)$ ，有 $3 * (n_i - 3) &gt; n_i$</li>
<li>如果 $n_i = 4$ ，拆分成 $2 + 2$ 乘积不变，所以假设没有 $4$</li>
<li>如果有 $3$ 个连续以上 $2$，那么 $3 \times 3 &gt; 2 \times 2 \times 2$ ，所以替换成 $3$ 乘积更大；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;       <span class="hljs-comment">// 不能有 4，2 * 2 &gt; 3 * 1</span><br>        res = <span class="hljs-number">4</span>;<br>        n -= <span class="hljs-number">4</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>        res = <span class="hljs-number">2</span>;<br>        n -= <span class="hljs-number">2</span>;<br>    &#125; <br>    <span class="hljs-keyword">while</span>(n) &#123;      <span class="hljs-comment">// e 处取</span><br>        res *= <span class="hljs-number">3</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路 2</strong>：<strong>动态规划</strong>。定义状态 <code>f[i]</code> 为将长度为 $i$ 的绳子剪成若干段后各段长度乘积的最大值。剪第一刀时，我们有 $n - 1$ 种可能的选择，也就是剪出来的第一段绳子的可能长度分别是 $1,2,..,n-1$。因此 $f[i] = max(f[i], max(j <em> (i - j), j </em> f[i - j]))$。</p>
<p>减去第一段长度为 $j$ 的绳子之后，可以选择不再剪断，也可选择继续往下剪。若是继续剪，则需要继续求子问题 $f[i - j]$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>            f[i] = <span class="hljs-built_in">max</span>(f[i], <span class="hljs-built_in">max</span>(j * (i - j), j * f[i - j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="14-II-剪绳子-II"><a href="#14-II-剪绳子-II" class="headerlink" title="14- II. 剪绳子 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">14- II. 剪绳子 II</a></h3><p><strong>题意描述</strong>：将一根长度为 $n$ 的绳子剪成整数长度的 $m$ 段（$m,n$ 都是整数，$n,m&gt;1$），每段绳子的长度记为 $k[0],k[1]…k[m-1]$ 。请问  $k[0] \times k[1] \times…\times k[m-1]$ 可能的最大乘积是多少。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>提示：<code>2 &lt;= n &lt;= 1000</code></p>
<p><strong>解题思路</strong>：本题只能数学推导出答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>        res = <span class="hljs-number">4</span>;<br>        n -= <span class="hljs-number">4</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>        res = <span class="hljs-number">2</span>;<br>        n -= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        res = (res* <span class="hljs-number">3</span>) % <span class="hljs-number">1000000007</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="57-II-和s的连续正数序列"><a href="#57-II-和s的连续正数序列" class="headerlink" title="57 - II. 和s的连续正数序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">57 - II. 和s的连续正数序列</a></h3><p><strong>题意描述</strong>：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>1 &lt;= target &lt;= 10^5</code></p>
<p><strong>解题思路</strong>：<strong>双指针（滑动窗口）</strong>。设连续正整数序列的左边界 $left$ 和右边界 $right$ ，则可构建滑动窗口从左向右滑动。循环中，每轮判断滑动窗口内的元素和与目标值 $target$ 的大小关系。若相等则记录，若大于 $target$ 则移动左边界 $left$ （以减少窗口内的元素和），若小于 $target$ 则移动右边界 $right$ （以增加窗口内的元素和）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-keyword">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">2</span>, sum = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>            sum -= left;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right++;<br>            sum += right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">62. 圆圈中最后剩下的数字</a></h3><p><strong>题意描述</strong>：$0,1,···,n-1$ 这 $n$ 个数字排成一个圆圈，从数字 $0$ 开始，每次从这个圆圈里删除第 $m$ 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：约瑟夫环问题。由下往上递推：$(\text{当前索引编号} index + m) \mod \text{上一轮元素个数} i$ </p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        index = (index + m) % i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 简化版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">lastRemaining</span>(n - <span class="hljs-number">1</span>, m) + m) % n;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="43-1～n-整数中-1-出现的次数"><a href="#43-1～n-整数中-1-出现的次数" class="headerlink" title="43. 1～n 整数中 1 出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">43. 1～n 整数中 1 出现的次数</a></h3><p><strong>题意描述</strong>：输入一个整数 $n$ ，求 $1～n$ 这 $n$ 个整数的十进制表示中 $1$ 出现的次数。$1 &lt;= n &lt; 2^{31}$</p>
<p><strong>解题思路</strong>：本题实际上是数位统计 DP 问题。具体可见算法基础课。假设有一个数为 $abcdefg$，我们需要分析其每一位上 $1$ 的情况，下面我们讨论 $d$ 所在位上 $1$ 的个数。</p>
<ul>
<li>假设 $d=0$，是一个组合问题，方案数为 $abc$ 的取值方案数乘以 $efg$ 的取值方案数，也即 $abc$ 可取 $000 \sim abc - 1$， $efg$ 可取 $000 \sim 999$， 得 $abc \times 1000$；</li>
<li>假设 $d=1$，一共是 $abc \times 1000 + efg+1$ 种，为方便理解分为两种情况计算：<ul>
<li>$abc$ 取 $000 \sim abc - 1$， 则 $efg$ 取 $000 \sim 999$， 得 $abc \times 1000$；</li>
<li>$abc$ 取 $abc$， 则 $efg$ 取 $000 \sim efg$， 得 $efg+1$；</li>
</ul>
</li>
<li>假设 $d&gt;1$，即 $abc$ 可取 $000 \sim abc$， $efg$ 可取 $000 \sim 999$， 得 $(abc+1) \times 1000$；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>        <span class="hljs-keyword">while</span>(n) &#123;<br>            nums.<span class="hljs-built_in">push_back</span>(n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 低位到高位逐位计算 1 出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= i + <span class="hljs-number">1</span>; j--) &#123;<br>                left = left * <span class="hljs-number">10</span> + nums[j];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                right = right * <span class="hljs-number">10</span> + nums[j];<br>                p *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) res += left * p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) res += left * p + right + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> res += (left + <span class="hljs-number">1</span>) * p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44. 数字序列中某一位的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">44. 数字序列中某一位的数字</a></h3><p><strong>题意描述</strong>：数字以 <code>0123456789101112131415…</code> 的格式序列化到一个字符序列中。在这个序列中，第 $5$ 位（从下标0开始计数）是 $5$，第 $13$ 位是 $1$，第 $19$ 位是$4$，等等。请写一个函数，求任意第 $n$ 位对应的数字。</p>
<p>限制：<code>0 &lt;= n &lt; 2^31</code></p>
<p><strong>解题思路</strong>：</p>
<ol>
<li>将 $01234567…$ 中的每一位称为<strong>数位</strong>，记为 $n$；</li>
<li>将 $0,1,2,…$ 称为<strong>数字</strong>，记为 $num$；</li>
<li>数字 $1$ 是一个一位数，此数字的<strong>位数</strong>为 $1$，记为 $digit$；</li>
<li>每个 $digit$ 位数的起始数字（即：$1,10,…$），记为 $start$。</li>
</ol>
<div align = center><img src = "https://figs-1308257758.cos.ap-nanjing.myqcloud.com/img/20211201165503.png" width = 500px /></div>

<p>解题过程分为三步：</p>
<ol>
<li>确定 $n$ 所在数字的位数 $digit$；</li>
<li>确定 $n$ 所在数字 $num$；</li>
<li>确定 $n$ 是 $num$ 中的哪一位数位，返回结果；</li>
</ol>
<hr>
<p>一、确定 $n$ 所在数字的位数 $digit$</p>
<p>循环执行 $n$ 减去一位数、两位数、… 的数位数量 $count$，直到 $n \leq count$ 跳出。</p>
<p>循环结束时，$n$ 是从每个 $digit$ 位数的起始数字 $start$ 开始计数的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>, start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">while</span>(n &gt; count) &#123;<br>    n -= count;<br>    start *= <span class="hljs-number">10</span>;<br>    digit++;<br>    count = <span class="hljs-number">9</span> * start * digit;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>二、确定 $n$ 所在数字 $num$</p>
<p>所求数位在从数字 $start$ 开始的第 $\frac{n-1}{digit}$ 个数字中，$start$ 为第 $0$ 个数字；</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">num = start + (n - <span class="hljs-number">1</span>) / digit;<br></code></pre></div></td></tr></table></figure>
<p>三、确定 $n$ 是 $num$ 中的哪一位数位，返回结果</p>
<p>所求数位为数字 $num$ 的第 $(n - 1) \% digit$ 位（数字的首个数位为第 $0$ 位）</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">s = <span class="hljs-built_in">to_string</span>(num);<br>res = <span class="hljs-built_in">stoi</span>(s[(n - <span class="hljs-number">1</span>) % digit]);<br></code></pre></div></td></tr></table></figure>
<hr>
<ul>
<li>时间复杂度 $O(\text{log }n)$：所求数位 $n$ 对应数字 $num$ 的位数 $digit$ 最大为  $O(\text{log }n)$ ；第一步最多循环  $O(\text{log }n)$ 次；第三步中将 $num$ 转化为字符串使用  $O(\text{log }n)$ 时间；因此总体为  $O(\text{log }n)$。</li>
<li>空间复杂度  $O(\text{log }n)$：将数字 $num$ 转化为字符串 $s$ ，占用  $O(\text{log }n)$ 的空间。</li>
</ul>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/">Krahets 题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; count) &#123;<br>        n -= count;<br>        start *= <span class="hljs-number">10</span>;<br>        digit++;<br>        count = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">9</span> * start * digit;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = start + (n - <span class="hljs-number">1</span>) / digit;<br>    string s = <span class="hljs-built_in">to_string</span>(num);<br>    <span class="hljs-keyword">return</span> s[(n - <span class="hljs-number">1</span>) % digit] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">29. 顺时针打印矩阵</a></h3><p><strong>题意描述</strong>：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br></code></pre></div></td></tr></table></figure>
<p>限制：<code>0 &lt;= matrix.length &lt;= 100</code>，<code>0 &lt;= matrix[i].length &lt;= 100</code></p>
<p><strong>解题思路</strong>：代码中以 <code>st</code> 数组来标记元素是否被访问过，尽管有点浪费空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(m, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(matrix[x][y]);<br>        st[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> a = x + dx[d], b = y + dy[d];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= m || b &lt; <span class="hljs-number">0</span> || b &gt;= n || st[a][b]) &#123;<br>            d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            a = x + dx[d], b = y + dy[d];<br>        &#125;<br>        x = a, y = b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">31. 栈的压入、弹出序列</a></h3><p><strong>题意描述</strong>：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br></code></pre></div></td></tr></table></figure>
<p><strong>解题思路</strong>：见代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pushed.<span class="hljs-built_in">size</span>() != popped.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : pushed) &#123;<br>            stk.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() == popped[i]) &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>如何理解算法时间复杂度的表示法(<a target="_blank" rel="noopener" href="http://www.zhihu.com/question/21387264">http://www.zhihu.com/question/21387264</a>)
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>图解算法与数据结构(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/</a>)
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms">Master theorem</a>)
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.acwing.com/">https://www.acwing.com/</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF/Data-Structures-and-Algorithms/">Data Structures and Algorithms</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Algorithm/">Algorithm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/10/vim%E4%B8%8Etmux%E7%9A%84%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">Linux下vim与tmux的使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
